/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/leaflet-control-geocoder";
exports.ids = ["vendor-chunks/leaflet-control-geocoder"];
exports.modules = {

/***/ "(ssr)/./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.js":
/*!************************************************************************!*\
  !*** ./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.js ***!
  \************************************************************************/
/***/ (() => {

eval("var leafletControlGeocoder = (function (exports, L) {\n\n  function _interopNamespace(e) {\n    if (e && e.__esModule) return e;\n    var n = Object.create(null);\n    if (e) {\n      Object.keys(e).forEach(function (k) {\n        if (k !== 'default') {\n          var d = Object.getOwnPropertyDescriptor(e, k);\n          Object.defineProperty(n, k, d.get ? d : {\n            enumerable: true,\n            get: function () {\n              return e[k];\n            }\n          });\n        }\n      });\n    }\n    n['default'] = e;\n    return n;\n  }\n\n  var L__namespace = /*#__PURE__*/_interopNamespace(L);\n\n  function _inheritsLoose(subClass, superClass) {\n    subClass.prototype = Object.create(superClass.prototype);\n    subClass.prototype.constructor = subClass;\n    subClass.__proto__ = superClass;\n  }\n\n  function _assertThisInitialized(self) {\n    if (self === void 0) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return self;\n  }\n\n  /**\r\n   * @internal\r\n   */\n\n  function geocodingParams(options, params) {\n    return L__namespace.Util.extend(params, options.geocodingQueryParams);\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function reverseParams(options, params) {\n    return L__namespace.Util.extend(params, options.reverseQueryParams);\n  }\n\n  /**\r\n   * @internal\r\n   */\n\n  var lastCallbackId = 0; // Adapted from handlebars.js\n  // https://github.com/wycats/handlebars.js/\n\n  /**\r\n   * @internal\r\n   */\n\n  var badChars = /[&<>\"'`]/g;\n  /**\r\n   * @internal\r\n   */\n\n  var possible = /[&<>\"'`]/;\n  /**\r\n   * @internal\r\n   */\n\n  var escape = {\n    '&': '&amp;',\n    '<': '&lt;',\n    '>': '&gt;',\n    '\"': '&quot;',\n    \"'\": '&#x27;',\n    '`': '&#x60;'\n  };\n  /**\r\n   * @internal\r\n   */\n\n  function escapeChar(chr) {\n    return escape[chr];\n  }\n  /**\r\n   * @internal\r\n   */\n\n\n  function htmlEscape(string) {\n    if (string == null) {\n      return '';\n    } else if (!string) {\n      return string + '';\n    } // Force a string conversion as this will be done by the append regardless and\n    // the regex test will do this transparently behind the scenes, causing issues if\n    // an object's to string has escaped characters in it.\n\n\n    string = '' + string;\n\n    if (!possible.test(string)) {\n      return string;\n    }\n\n    return string.replace(badChars, escapeChar);\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function jsonp(url, params, callback, context, jsonpParam) {\n    var callbackId = '_l_geocoder_' + lastCallbackId++;\n    params[jsonpParam || 'callback'] = callbackId;\n    window[callbackId] = L__namespace.Util.bind(callback, context);\n    var script = document.createElement('script');\n    script.type = 'text/javascript';\n    script.src = url + getParamString(params);\n    script.id = callbackId;\n    document.getElementsByTagName('head')[0].appendChild(script);\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function getJSON(url, params, callback) {\n    var xmlHttp = new XMLHttpRequest();\n\n    xmlHttp.onreadystatechange = function () {\n      if (xmlHttp.readyState !== 4) {\n        return;\n      }\n\n      var message;\n\n      if (xmlHttp.status !== 200 && xmlHttp.status !== 304) {\n        message = '';\n      } else if (typeof xmlHttp.response === 'string') {\n        // IE doesn't parse JSON responses even with responseType: 'json'.\n        try {\n          message = JSON.parse(xmlHttp.response);\n        } catch (e) {\n          // Not a JSON response\n          message = xmlHttp.response;\n        }\n      } else {\n        message = xmlHttp.response;\n      }\n\n      callback(message);\n    };\n\n    xmlHttp.open('GET', url + getParamString(params), true);\n    xmlHttp.responseType = 'json';\n    xmlHttp.setRequestHeader('Accept', 'application/json');\n    xmlHttp.send(null);\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function template(str, data) {\n    return str.replace(/\\{ *([\\w_]+) *\\}/g, function (str, key) {\n      var value = data[key];\n\n      if (value === undefined) {\n        value = '';\n      } else if (typeof value === 'function') {\n        value = value(data);\n      }\n\n      return htmlEscape(value);\n    });\n  }\n  /**\r\n   * @internal\r\n   */\n\n  function getParamString(obj, existingUrl, uppercase) {\n    var params = [];\n\n    for (var i in obj) {\n      var key = encodeURIComponent(uppercase ? i.toUpperCase() : i);\n      var value = obj[i];\n\n      if (!Array.isArray(value)) {\n        params.push(key + '=' + encodeURIComponent(String(value)));\n      } else {\n        for (var j = 0; j < value.length; j++) {\n          params.push(key + '=' + encodeURIComponent(value[j]));\n        }\n      }\n    }\n\n    return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n  }\n\n  /**\r\n   * Implementation of the [ArcGIS geocoder](https://developers.arcgis.com/features/geocoding/)\r\n   */\n\n  var ArcGis = /*#__PURE__*/function () {\n    function ArcGis(options) {\n      this.options = {\n        serviceUrl: 'https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer',\n        apiKey: ''\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = ArcGis.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        token: this.options.apiKey,\n        SingleLine: query,\n        outFields: 'Addr_Type',\n        forStorage: false,\n        maxLocations: 10,\n        f: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/findAddressCandidates', params, function (data) {\n        var results = [];\n\n        if (data.candidates && data.candidates.length) {\n          for (var i = 0; i <= data.candidates.length - 1; i++) {\n            var loc = data.candidates[i];\n            var latLng = L__namespace.latLng(loc.location.y, loc.location.x);\n            var latLngBounds = L__namespace.latLngBounds(L__namespace.latLng(loc.extent.ymax, loc.extent.xmax), L__namespace.latLng(loc.extent.ymin, loc.extent.xmin));\n            results[i] = {\n              name: loc.address,\n              bbox: latLngBounds,\n              center: latLng\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        location: location.lng + ',' + location.lat,\n        distance: 100,\n        f: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/reverseGeocode', params, function (data) {\n        var result = [];\n\n        if (data && !data.error) {\n          var center = L__namespace.latLng(data.location.y, data.location.x);\n          var bbox = L__namespace.latLngBounds(center, center);\n          result.push({\n            name: data.address.Match_addr,\n            center: center,\n            bbox: bbox\n          });\n        }\n\n        cb.call(context, result);\n      });\n    };\n\n    return ArcGis;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link ArcGis}\r\n   * @param options the options\r\n   */\n\n  function arcgis(options) {\n    return new ArcGis(options);\n  }\n\n  /**\r\n   * Implementation of the [Bing Locations API](https://docs.microsoft.com/en-us/bingmaps/rest-services/locations/)\r\n   */\n\n  var Bing = /*#__PURE__*/function () {\n    function Bing(options) {\n      this.options = {\n        serviceUrl: 'https://dev.virtualearth.net/REST/v1/Locations'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Bing.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        query: query,\n        key: this.options.apiKey\n      });\n      jsonp(this.options.apiKey, params, function (data) {\n        var results = [];\n\n        if (data.resourceSets.length > 0) {\n          for (var i = data.resourceSets[0].resources.length - 1; i >= 0; i--) {\n            var resource = data.resourceSets[0].resources[i],\n                bbox = resource.bbox;\n            results[i] = {\n              name: resource.name,\n              bbox: L__namespace.latLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]),\n              center: L__namespace.latLng(resource.point.coordinates)\n            };\n          }\n        }\n\n        cb.call(context, results);\n      }, this, 'jsonp');\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey\n      });\n      jsonp(this.options.serviceUrl + location.lat + ',' + location.lng, params, function (data) {\n        var results = [];\n\n        for (var i = data.resourceSets[0].resources.length - 1; i >= 0; i--) {\n          var resource = data.resourceSets[0].resources[i],\n              bbox = resource.bbox;\n          results[i] = {\n            name: resource.name,\n            bbox: L__namespace.latLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]),\n            center: L__namespace.latLng(resource.point.coordinates)\n          };\n        }\n\n        cb.call(context, results);\n      }, this, 'jsonp');\n    };\n\n    return Bing;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Bing}\r\n   * @param options the options\r\n   */\n\n  function bing(options) {\n    return new Bing(options);\n  }\n\n  var Google = /*#__PURE__*/function () {\n    function Google(options) {\n      this.options = {\n        serviceUrl: 'https://maps.googleapis.com/maps/api/geocode/json'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Google.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        key: this.options.apiKey,\n        address: query\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i <= data.results.length - 1; i++) {\n            var loc = data.results[i];\n            var latLng = L__namespace.latLng(loc.geometry.location);\n            var latLngBounds = L__namespace.latLngBounds(L__namespace.latLng(loc.geometry.viewport.northeast), L__namespace.latLng(loc.geometry.viewport.southwest));\n            results[i] = {\n              name: loc.formatted_address,\n              bbox: latLngBounds,\n              center: latLng,\n              properties: loc.address_components\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey,\n        latlng: location.lat + ',' + location.lng\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i <= data.results.length - 1; i++) {\n            var loc = data.results[i];\n            var center = L__namespace.latLng(loc.geometry.location);\n            var bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.geometry.viewport.northeast), L__namespace.latLng(loc.geometry.viewport.southwest));\n            results[i] = {\n              name: loc.formatted_address,\n              bbox: bbox,\n              center: center,\n              properties: loc.address_components\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return Google;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Google}\r\n   * @param options the options\r\n   */\n\n  function google(options) {\n    return new Google(options);\n  }\n\n  /**\r\n   * Implementation of the [HERE Geocoder API](https://developer.here.com/documentation/geocoder/topics/introduction.html)\r\n   */\n\n  var HERE = /*#__PURE__*/function () {\n    function HERE(options) {\n      this.options = {\n        serviceUrl: 'https://geocoder.api.here.com/6.2/',\n        app_id: '',\n        app_code: '',\n        apiKey: '',\n        maxResults: 5\n      };\n      L__namespace.Util.setOptions(this, options);\n      if (options.apiKey) throw Error('apiKey is not supported, use app_id/app_code instead!');\n    }\n\n    var _proto = HERE.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        searchtext: query,\n        gen: 9,\n        app_id: this.options.app_id,\n        app_code: this.options.app_code,\n        jsonattributes: 1,\n        maxresults: this.options.maxResults\n      });\n      this.getJSON(this.options.serviceUrl + 'geocode.json', params, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var prox = location.lat + ',' + location.lng;\n\n      if (this.options.reverseGeocodeProxRadius) {\n        prox += ',' + this.options.reverseGeocodeProxRadius;\n      }\n\n      var params = reverseParams(this.options, {\n        prox: prox,\n        mode: 'retrieveAddresses',\n        app_id: this.options.app_id,\n        app_code: this.options.app_code,\n        gen: 9,\n        jsonattributes: 1,\n        maxresults: this.options.maxResults\n      });\n      this.getJSON(this.options.serviceUrl + 'reversegeocode.json', params, cb, context);\n    };\n\n    _proto.getJSON = function getJSON$1(url, params, cb, context) {\n      getJSON(url, params, function (data) {\n        var results = [];\n\n        if (data.response.view && data.response.view.length) {\n          for (var i = 0; i <= data.response.view[0].result.length - 1; i++) {\n            var loc = data.response.view[0].result[i].location;\n            var center = L__namespace.latLng(loc.displayPosition.latitude, loc.displayPosition.longitude);\n            var bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.mapView.topLeft.latitude, loc.mapView.topLeft.longitude), L__namespace.latLng(loc.mapView.bottomRight.latitude, loc.mapView.bottomRight.longitude));\n            results[i] = {\n              name: loc.address.label,\n              properties: loc.address,\n              bbox: bbox,\n              center: center\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return HERE;\n  }();\n  /**\r\n   * Implementation of the new [HERE Geocoder API](https://developer.here.com/documentation/geocoding-search-api/api-reference-swagger.html)\r\n   */\n\n  var HEREv2 = /*#__PURE__*/function () {\n    function HEREv2(options) {\n      this.options = {\n        serviceUrl: 'https://geocode.search.hereapi.com/v1',\n        apiKey: '',\n        app_id: '',\n        app_code: '',\n        maxResults: 10\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto2 = HEREv2.prototype;\n\n    _proto2.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        q: query,\n        apiKey: this.options.apiKey,\n        limit: this.options.maxResults\n      });\n\n      if (!params.at && !params[\"in\"]) {\n        throw Error('at / in parameters not found. Please define coordinates (at=latitude,longitude) or other (in) in your geocodingQueryParams.');\n      }\n\n      this.getJSON(this.options.serviceUrl + '/discover', params, cb, context);\n    };\n\n    _proto2.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        at: location.lat + ',' + location.lng,\n        limit: this.options.reverseGeocodeProxRadius,\n        apiKey: this.options.apiKey\n      });\n      this.getJSON(this.options.serviceUrl + '/revgeocode', params, cb, context);\n    };\n\n    _proto2.getJSON = function getJSON$1(url, params, cb, context) {\n      getJSON(url, params, function (data) {\n        var results = [];\n\n        if (data.items && data.items.length) {\n          for (var i = 0; i <= data.items.length - 1; i++) {\n            var item = data.items[i];\n            var latLng = L__namespace.latLng(item.position.lat, item.position.lng);\n            var bbox = void 0;\n\n            if (item.mapView) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(item.mapView.south, item.mapView.west), L__namespace.latLng(item.mapView.north, item.mapView.east));\n            } else {\n              // Using only position when not provided\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(item.position.lat, item.position.lng), L__namespace.latLng(item.position.lat, item.position.lng));\n            }\n\n            results[i] = {\n              name: item.address.label,\n              properties: item.address,\n              bbox: bbox,\n              center: latLng\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return HEREv2;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link HERE}\r\n   * @param options the options\r\n   */\n\n  function here(options) {\n    if (options.apiKey) {\n      return new HEREv2(options);\n    } else {\n      return new HERE(options);\n    }\n  }\n\n  /**\r\n   * Parses basic latitude/longitude strings such as `'50.06773 14.37742'`, `'N50.06773 W14.37742'`, `'S 50° 04.064 E 014° 22.645'`, or `'S 50° 4′ 03.828″, W 14° 22′ 38.712″'`\r\n   * @param query the latitude/longitude string to parse\r\n   * @returns the parsed latitude/longitude\r\n   */\n\n  function parseLatLng(query) {\n    var match; // regex from https://github.com/openstreetmap/openstreetmap-website/blob/master/app/controllers/geocoder_controller.rb\n\n    if (match = query.match(/^([NS])\\s*(\\d{1,3}(?:\\.\\d*)?)\\W*([EW])\\s*(\\d{1,3}(?:\\.\\d*)?)$/)) {\n      // [NSEW] decimal degrees\n      return L__namespace.latLng((/N/i.test(match[1]) ? 1 : -1) * +match[2], (/E/i.test(match[3]) ? 1 : -1) * +match[4]);\n    } else if (match = query.match(/^(\\d{1,3}(?:\\.\\d*)?)\\s*([NS])\\W*(\\d{1,3}(?:\\.\\d*)?)\\s*([EW])$/)) {\n      // decimal degrees [NSEW]\n      return L__namespace.latLng((/N/i.test(match[2]) ? 1 : -1) * +match[1], (/E/i.test(match[4]) ? 1 : -1) * +match[3]);\n    } else if (match = query.match(/^([NS])\\s*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\W*([EW])\\s*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?$/)) {\n      // [NSEW] degrees, decimal minutes\n      return L__namespace.latLng((/N/i.test(match[1]) ? 1 : -1) * (+match[2] + +match[3] / 60), (/E/i.test(match[4]) ? 1 : -1) * (+match[5] + +match[6] / 60));\n    } else if (match = query.match(/^(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\s*([NS])\\W*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\s*([EW])$/)) {\n      // degrees, decimal minutes [NSEW]\n      return L__namespace.latLng((/N/i.test(match[3]) ? 1 : -1) * (+match[1] + +match[2] / 60), (/E/i.test(match[6]) ? 1 : -1) * (+match[4] + +match[5] / 60));\n    } else if (match = query.match(/^([NS])\\s*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?\\W*([EW])\\s*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?$/)) {\n      // [NSEW] degrees, minutes, decimal seconds\n      return L__namespace.latLng((/N/i.test(match[1]) ? 1 : -1) * (+match[2] + +match[3] / 60 + +match[4] / 3600), (/E/i.test(match[5]) ? 1 : -1) * (+match[6] + +match[7] / 60 + +match[8] / 3600));\n    } else if (match = query.match(/^(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]\\s*([NS])\\W*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?\\s*([EW])$/)) {\n      // degrees, minutes, decimal seconds [NSEW]\n      return L__namespace.latLng((/N/i.test(match[4]) ? 1 : -1) * (+match[1] + +match[2] / 60 + +match[3] / 3600), (/E/i.test(match[8]) ? 1 : -1) * (+match[5] + +match[6] / 60 + +match[7] / 3600));\n    } else if (match = query.match(/^\\s*([+-]?\\d+(?:\\.\\d*)?)\\s*[\\s,]\\s*([+-]?\\d+(?:\\.\\d*)?)\\s*$/)) {\n      return L__namespace.latLng(+match[1], +match[2]);\n    }\n  }\n  /**\r\n   * Parses basic latitude/longitude strings such as `'50.06773 14.37742'`, `'N50.06773 W14.37742'`, `'S 50° 04.064 E 014° 22.645'`, or `'S 50° 4′ 03.828″, W 14° 22′ 38.712″'`\r\n   */\n\n  var LatLng = /*#__PURE__*/function () {\n    function LatLng(options) {\n      this.options = {\n        next: undefined,\n        sizeInMeters: 10000\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = LatLng.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var center = parseLatLng(query);\n\n      if (center) {\n        var results = [{\n          name: query,\n          center: center,\n          bbox: center.toBounds(this.options.sizeInMeters)\n        }];\n        cb.call(context, results);\n      } else if (this.options.next) {\n        this.options.next.geocode(query, cb, context);\n      }\n    };\n\n    return LatLng;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link LatLng}\r\n   * @param options the options\r\n   */\n\n  function latLng(options) {\n    return new LatLng(options);\n  }\n\n  /**\r\n   * Implementation of the [Mapbox Geocoding](https://www.mapbox.com/api-documentation/#geocoding)\r\n   */\n\n  var Mapbox = /*#__PURE__*/function () {\n    function Mapbox(options) {\n      this.options = {\n        serviceUrl: 'https://api.mapbox.com/geocoding/v5/mapbox.places/'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Mapbox.prototype;\n\n    _proto._getProperties = function _getProperties(loc) {\n      var properties = {\n        text: loc.text,\n        address: loc.address\n      };\n\n      for (var j = 0; j < (loc.context || []).length; j++) {\n        var id = loc.context[j].id.split('.')[0];\n        properties[id] = loc.context[j].text; // Get country code when available\n\n        if (loc.context[j].short_code) {\n          properties['countryShortCode'] = loc.context[j].short_code;\n        }\n      }\n\n      return properties;\n    };\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var _this = this;\n\n      var params = geocodingParams(this.options, {\n        access_token: this.options.apiKey\n      });\n\n      if (params.proximity !== undefined && params.proximity.lat !== undefined && params.proximity.lng !== undefined) {\n        params.proximity = params.proximity.lng + ',' + params.proximity.lat;\n      }\n\n      getJSON(this.options.serviceUrl + encodeURIComponent(query) + '.json', params, function (data) {\n        var results = [];\n\n        if (data.features && data.features.length) {\n          for (var i = 0; i <= data.features.length - 1; i++) {\n            var loc = data.features[i];\n            var center = L__namespace.latLng(loc.center.reverse());\n            var bbox = void 0;\n\n            if (loc.bbox) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.bbox.slice(0, 2).reverse()), L__namespace.latLng(loc.bbox.slice(2, 4).reverse()));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results[i] = {\n              name: loc.place_name,\n              bbox: bbox,\n              center: center,\n              properties: _this._getProperties(loc)\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var _this2 = this;\n\n      var url = this.options.serviceUrl + location.lng + ',' + location.lat + '.json';\n      var param = reverseParams(this.options, {\n        access_token: this.options.apiKey\n      });\n      getJSON(url, param, function (data) {\n        var results = [];\n\n        if (data.features && data.features.length) {\n          for (var i = 0; i <= data.features.length - 1; i++) {\n            var loc = data.features[i];\n            var center = L__namespace.latLng(loc.center.reverse());\n            var bbox = void 0;\n\n            if (loc.bbox) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.bbox.slice(0, 2).reverse()), L__namespace.latLng(loc.bbox.slice(2, 4).reverse()));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results[i] = {\n              name: loc.place_name,\n              bbox: bbox,\n              center: center,\n              properties: _this2._getProperties(loc)\n            };\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return Mapbox;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Mapbox}\r\n   * @param options the options\r\n   */\n\n  function mapbox(options) {\n    return new Mapbox(options);\n  }\n\n  /**\r\n   * Implementation of the [MapQuest Geocoding API](http://developer.mapquest.com/web/products/dev-services/geocoding-ws)\r\n   */\n\n  var MapQuest = /*#__PURE__*/function () {\n    function MapQuest(options) {\n      this.options = {\n        serviceUrl: 'https://www.mapquestapi.com/geocoding/v1'\n      };\n      L__namespace.Util.setOptions(this, options); // MapQuest seems to provide URI encoded API keys,\n      // so to avoid encoding them twice, we decode them here\n\n      this.options.apiKey = decodeURIComponent(this.options.apiKey);\n    }\n\n    var _proto = MapQuest.prototype;\n\n    _proto._formatName = function _formatName() {\n      return [].slice.call(arguments).filter(function (s) {\n        return !!s;\n      }).join(', ');\n    };\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        key: this.options.apiKey,\n        location: query,\n        limit: 5,\n        outFormat: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/address', params, L__namespace.Util.bind(function (data) {\n        var results = [];\n\n        if (data.results && data.results[0].locations) {\n          for (var i = data.results[0].locations.length - 1; i >= 0; i--) {\n            var loc = data.results[0].locations[i];\n            var center = L__namespace.latLng(loc.latLng);\n            results[i] = {\n              name: this._formatName(loc.street, loc.adminArea4, loc.adminArea3, loc.adminArea1),\n              bbox: L__namespace.latLngBounds(center, center),\n              center: center\n            };\n          }\n        }\n\n        cb.call(context, results);\n      }, this));\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey,\n        location: location.lat + ',' + location.lng,\n        outputFormat: 'json'\n      });\n      getJSON(this.options.serviceUrl + '/reverse', params, L__namespace.Util.bind(function (data) {\n        var results = [];\n\n        if (data.results && data.results[0].locations) {\n          for (var i = data.results[0].locations.length - 1; i >= 0; i--) {\n            var loc = data.results[0].locations[i];\n            var center = L__namespace.latLng(loc.latLng);\n            results[i] = {\n              name: this._formatName(loc.street, loc.adminArea4, loc.adminArea3, loc.adminArea1),\n              bbox: L__namespace.latLngBounds(center, center),\n              center: center\n            };\n          }\n        }\n\n        cb.call(context, results);\n      }, this));\n    };\n\n    return MapQuest;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link MapQuest}\r\n   * @param options the options\r\n   */\n\n  function mapQuest(options) {\n    return new MapQuest(options);\n  }\n\n  /**\r\n   * Implementation of the [Neutrino API](https://www.neutrinoapi.com/api/geocode-address/)\r\n   */\n\n  var Neutrino = /*#__PURE__*/function () {\n    function Neutrino(options) {\n      this.options = {\n        userId: undefined,\n        apiKey: undefined,\n        serviceUrl: 'https://neutrinoapi.com/'\n      };\n      L__namespace.Util.setOptions(this, options);\n    } // https://www.neutrinoapi.com/api/geocode-address/\n\n\n    var _proto = Neutrino.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        apiKey: this.options.apiKey,\n        userId: this.options.userId,\n        //get three words and make a dot based string\n        address: query.split(/\\s+/).join('.')\n      });\n      getJSON(this.options.serviceUrl + 'geocode-address', params, function (data) {\n        var results = [];\n\n        if (data.locations) {\n          data.geometry = data.locations[0];\n          var center = L__namespace.latLng(data.geometry['latitude'], data.geometry['longitude']);\n          var bbox = L__namespace.latLngBounds(center, center);\n          results[0] = {\n            name: data.geometry.address,\n            bbox: bbox,\n            center: center\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    } // https://www.neutrinoapi.com/api/geocode-reverse/\n    ;\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        apiKey: this.options.apiKey,\n        userId: this.options.userId,\n        latitude: location.lat,\n        longitude: location.lng\n      });\n      getJSON(this.options.serviceUrl + 'geocode-reverse', params, function (data) {\n        var results = [];\n\n        if (data.status.status == 200 && data.found) {\n          var center = L__namespace.latLng(location.lat, location.lng);\n          var bbox = L__namespace.latLngBounds(center, center);\n          results[0] = {\n            name: data.address,\n            bbox: bbox,\n            center: center\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return Neutrino;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Neutrino}\r\n   * @param options the options\r\n   */\n\n  function neutrino(options) {\n    return new Neutrino(options);\n  }\n\n  /**\r\n   * Implementation of the [Nominatim](https://wiki.openstreetmap.org/wiki/Nominatim) geocoder.\r\n   *\r\n   * This is the default geocoding service used by the control, unless otherwise specified in the options.\r\n   *\r\n   * Unless using your own Nominatim installation, please refer to the [Nominatim usage policy](https://operations.osmfoundation.org/policies/nominatim/).\r\n   */\n\n  var Nominatim = /*#__PURE__*/function () {\n    function Nominatim(options) {\n      this.options = {\n        serviceUrl: 'https://nominatim.openstreetmap.org/',\n        htmlTemplate: function htmlTemplate(r) {\n          var address = r.address;\n          var className;\n          var parts = [];\n\n          if (address.road || address.building) {\n            parts.push('{building} {road} {house_number}');\n          }\n\n          if (address.city || address.town || address.village || address.hamlet) {\n            className = parts.length > 0 ? 'leaflet-control-geocoder-address-detail' : '';\n            parts.push('<span class=\"' + className + '\">{postcode} {city} {town} {village} {hamlet}</span>');\n          }\n\n          if (address.state || address.country) {\n            className = parts.length > 0 ? 'leaflet-control-geocoder-address-context' : '';\n            parts.push('<span class=\"' + className + '\">{state} {country}</span>');\n          }\n\n          return template(parts.join('<br/>'), address);\n        }\n      };\n      L__namespace.Util.setOptions(this, options || {});\n    }\n\n    var _proto = Nominatim.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var _this = this;\n\n      var params = geocodingParams(this.options, {\n        q: query,\n        limit: 5,\n        format: 'json',\n        addressdetails: 1\n      });\n      getJSON(this.options.serviceUrl + 'search', params, function (data) {\n        var results = [];\n\n        for (var i = data.length - 1; i >= 0; i--) {\n          var bbox = data[i].boundingbox;\n\n          for (var j = 0; j < 4; j++) {\n            bbox[j] = +bbox[j];\n          }\n\n          results[i] = {\n            icon: data[i].icon,\n            name: data[i].display_name,\n            html: _this.options.htmlTemplate ? _this.options.htmlTemplate(data[i]) : undefined,\n            bbox: L__namespace.latLngBounds([bbox[0], bbox[2]], [bbox[1], bbox[3]]),\n            center: L__namespace.latLng(data[i].lat, data[i].lon),\n            properties: data[i]\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var _this2 = this;\n\n      var params = reverseParams(this.options, {\n        lat: location.lat,\n        lon: location.lng,\n        zoom: Math.round(Math.log(scale / 256) / Math.log(2)),\n        addressdetails: 1,\n        format: 'json'\n      });\n      getJSON(this.options.serviceUrl + 'reverse', params, function (data) {\n        var result = [];\n\n        if (data && data.lat && data.lon) {\n          var center = L__namespace.latLng(data.lat, data.lon);\n          var bbox = L__namespace.latLngBounds(center, center);\n          result.push({\n            name: data.display_name,\n            html: _this2.options.htmlTemplate ? _this2.options.htmlTemplate(data) : undefined,\n            center: center,\n            bbox: bbox,\n            properties: data\n          });\n        }\n\n        cb.call(context, result);\n      });\n    };\n\n    return Nominatim;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Nominatim}\r\n   * @param options the options\r\n   */\n\n  function nominatim(options) {\n    return new Nominatim(options);\n  }\n\n  /**\r\n   * Implementation of the [Plus codes](https://plus.codes/) (formerly OpenLocationCode) (requires [open-location-code](https://www.npmjs.com/package/open-location-code))\r\n   */\n\n  var OpenLocationCode = /*#__PURE__*/function () {\n    function OpenLocationCode(options) {\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = OpenLocationCode.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      try {\n        var decoded = this.options.OpenLocationCode.decode(query);\n        var result = {\n          name: query,\n          center: L__namespace.latLng(decoded.latitudeCenter, decoded.longitudeCenter),\n          bbox: L__namespace.latLngBounds(L__namespace.latLng(decoded.latitudeLo, decoded.longitudeLo), L__namespace.latLng(decoded.latitudeHi, decoded.longitudeHi))\n        };\n        cb.call(context, [result]);\n      } catch (e) {\n        console.warn(e); // eslint-disable-line no-console\n\n        cb.call(context, []);\n      }\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      try {\n        var code = this.options.OpenLocationCode.encode(location.lat, location.lng, this.options.codeLength);\n        var result = {\n          name: code,\n          center: L__namespace.latLng(location.lat, location.lng),\n          bbox: L__namespace.latLngBounds(L__namespace.latLng(location.lat, location.lng), L__namespace.latLng(location.lat, location.lng))\n        };\n        cb.call(context, [result]);\n      } catch (e) {\n        console.warn(e); // eslint-disable-line no-console\n\n        cb.call(context, []);\n      }\n    };\n\n    return OpenLocationCode;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link OpenLocationCode}\r\n   * @param options the options\r\n   */\n\n  function openLocationCode(options) {\n    return new OpenLocationCode(options);\n  }\n\n  /**\r\n   * Implementation of the [OpenCage Data API](https://opencagedata.com/)\r\n   */\n\n  var OpenCage = /*#__PURE__*/function () {\n    function OpenCage(options) {\n      this.options = {\n        serviceUrl: 'https://api.opencagedata.com/geocode/v1/json'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = OpenCage.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        key: this.options.apiKey,\n        q: query\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i < data.results.length; i++) {\n            var loc = data.results[i];\n            var center = L__namespace.latLng(loc.geometry);\n            var bbox = void 0;\n\n            if (loc.annotations && loc.annotations.bounds) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.annotations.bounds.northeast), L__namespace.latLng(loc.annotations.bounds.southwest));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results.push({\n              name: loc.formatted,\n              bbox: bbox,\n              center: center\n            });\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        key: this.options.apiKey,\n        q: [location.lat, location.lng].join(',')\n      });\n      getJSON(this.options.serviceUrl, params, function (data) {\n        var results = [];\n\n        if (data.results && data.results.length) {\n          for (var i = 0; i < data.results.length; i++) {\n            var loc = data.results[i];\n            var center = L__namespace.latLng(loc.geometry);\n            var bbox = void 0;\n\n            if (loc.annotations && loc.annotations.bounds) {\n              bbox = L__namespace.latLngBounds(L__namespace.latLng(loc.annotations.bounds.northeast), L__namespace.latLng(loc.annotations.bounds.southwest));\n            } else {\n              bbox = L__namespace.latLngBounds(center, center);\n            }\n\n            results.push({\n              name: loc.formatted,\n              bbox: bbox,\n              center: center\n            });\n          }\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return OpenCage;\n  }();\n  function opencage(options) {\n    return new OpenCage(options);\n  }\n\n  /**\r\n   * Implementation of the [Pelias](https://pelias.io/), [geocode.earth](https://geocode.earth/) geocoder (formerly Mapzen Search)\r\n   */\n\n  var Pelias = /*#__PURE__*/function () {\n    function Pelias(options) {\n      this.options = {\n        serviceUrl: 'https://api.geocode.earth/v1'\n      };\n      this._lastSuggest = 0;\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Pelias.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var _this = this;\n\n      var params = geocodingParams(this.options, {\n        api_key: this.options.apiKey,\n        text: query\n      });\n      getJSON(this.options.serviceUrl + '/search', params, function (data) {\n        cb.call(context, _this._parseResults(data, 'bbox'));\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      var _this2 = this;\n\n      var params = geocodingParams(this.options, {\n        api_key: this.options.apiKey,\n        text: query\n      });\n      getJSON(this.options.serviceUrl + '/autocomplete', params, function (data) {\n        if (data.geocoding.timestamp > _this2._lastSuggest) {\n          _this2._lastSuggest = data.geocoding.timestamp;\n          cb.call(context, _this2._parseResults(data, 'bbox'));\n        }\n      });\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      var _this3 = this;\n\n      var params = reverseParams(this.options, {\n        api_key: this.options.apiKey,\n        'point.lat': location.lat,\n        'point.lon': location.lng\n      });\n      getJSON(this.options.serviceUrl + '/reverse', params, function (data) {\n        cb.call(context, _this3._parseResults(data, 'bounds'));\n      });\n    };\n\n    _proto._parseResults = function _parseResults(data, bboxname) {\n      var results = [];\n      L__namespace.geoJSON(data, {\n        pointToLayer: function pointToLayer(feature, latlng) {\n          return L__namespace.circleMarker(latlng);\n        },\n        onEachFeature: function onEachFeature(feature, layer) {\n          var result = {};\n          var bbox;\n          var center;\n\n          if (layer.getBounds) {\n            bbox = layer.getBounds();\n            center = bbox.getCenter();\n          } else if (layer.feature.bbox) {\n            center = layer.getLatLng();\n            bbox = L__namespace.latLngBounds(L__namespace.GeoJSON.coordsToLatLng(layer.feature.bbox.slice(0, 2)), L__namespace.GeoJSON.coordsToLatLng(layer.feature.bbox.slice(2, 4)));\n          } else {\n            center = layer.getLatLng();\n            bbox = L__namespace.latLngBounds(center, center);\n          }\n\n          result.name = layer.feature.properties.label;\n          result.center = center;\n          result[bboxname] = bbox;\n          result.properties = layer.feature.properties;\n          results.push(result);\n        }\n      });\n      return results;\n    };\n\n    return Pelias;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Pelias}\r\n   * @param options the options\r\n   */\n\n  function pelias(options) {\n    return new Pelias(options);\n  }\n  var GeocodeEarth = Pelias;\n  var geocodeEarth = pelias;\n  /**\r\n   * r.i.p.\r\n   * @deprecated\r\n   */\n\n  var Mapzen = Pelias;\n  /**\r\n   * r.i.p.\r\n   * @deprecated\r\n   */\n\n  var mapzen = pelias;\n  /**\r\n   * Implementation of the [Openrouteservice](https://openrouteservice.org/dev/#/api-docs/geocode) geocoder\r\n   */\n\n  var Openrouteservice = /*#__PURE__*/function (_Pelias) {\n    _inheritsLoose(Openrouteservice, _Pelias);\n\n    function Openrouteservice(options) {\n      return _Pelias.call(this, L__namespace.Util.extend({\n        serviceUrl: 'https://api.openrouteservice.org/geocode'\n      }, options)) || this;\n    }\n\n    return Openrouteservice;\n  }(Pelias);\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Openrouteservice}\r\n   * @param options the options\r\n   */\n\n  function openrouteservice(options) {\n    return new Openrouteservice(options);\n  }\n\n  /**\r\n   * Implementation of the [Photon](http://photon.komoot.de/) geocoder\r\n   */\n\n  var Photon = /*#__PURE__*/function () {\n    function Photon(options) {\n      this.options = {\n        serviceUrl: 'https://photon.komoot.io/api/',\n        reverseUrl: 'https://photon.komoot.io/reverse/',\n        nameProperties: ['name', 'street', 'suburb', 'hamlet', 'town', 'city', 'state', 'country']\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = Photon.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      var params = geocodingParams(this.options, {\n        q: query\n      });\n      getJSON(this.options.serviceUrl, params, L__namespace.Util.bind(function (data) {\n        cb.call(context, this._decodeFeatures(data));\n      }, this));\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(latLng, scale, cb, context) {\n      var params = reverseParams(this.options, {\n        lat: latLng.lat,\n        lon: latLng.lng\n      });\n      getJSON(this.options.reverseUrl, params, L__namespace.Util.bind(function (data) {\n        cb.call(context, this._decodeFeatures(data));\n      }, this));\n    };\n\n    _proto._decodeFeatures = function _decodeFeatures(data) {\n      var results = [];\n\n      if (data && data.features) {\n        for (var i = 0; i < data.features.length; i++) {\n          var f = data.features[i];\n          var c = f.geometry.coordinates;\n          var center = L__namespace.latLng(c[1], c[0]);\n          var extent = f.properties.extent;\n          var bbox = extent ? L__namespace.latLngBounds([extent[1], extent[0]], [extent[3], extent[2]]) : L__namespace.latLngBounds(center, center);\n          results.push({\n            name: this._decodeFeatureName(f),\n            html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,\n            center: center,\n            bbox: bbox,\n            properties: f.properties\n          });\n        }\n      }\n\n      return results;\n    };\n\n    _proto._decodeFeatureName = function _decodeFeatureName(f) {\n      return (this.options.nameProperties || []).map(function (p) {\n        return f.properties[p];\n      }).filter(function (v) {\n        return !!v;\n      }).join(', ');\n    };\n\n    return Photon;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Photon}\r\n   * @param options the options\r\n   */\n\n  function photon(options) {\n    return new Photon(options);\n  }\n\n  /**\r\n   * Implementation of the What3Words service\r\n   */\n\n  var What3Words = /*#__PURE__*/function () {\n    function What3Words(options) {\n      this.options = {\n        serviceUrl: 'https://api.what3words.com/v2/'\n      };\n      L__namespace.Util.setOptions(this, options);\n    }\n\n    var _proto = What3Words.prototype;\n\n    _proto.geocode = function geocode(query, cb, context) {\n      //get three words and make a dot based string\n      getJSON(this.options.serviceUrl + 'forward', geocodingParams(this.options, {\n        key: this.options.apiKey,\n        addr: query.split(/\\s+/).join('.')\n      }), function (data) {\n        var results = [];\n\n        if (data.geometry) {\n          var latLng = L__namespace.latLng(data.geometry['lat'], data.geometry['lng']);\n          var latLngBounds = L__namespace.latLngBounds(latLng, latLng);\n          results[0] = {\n            name: data.words,\n            bbox: latLngBounds,\n            center: latLng\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    _proto.suggest = function suggest(query, cb, context) {\n      return this.geocode(query, cb, context);\n    };\n\n    _proto.reverse = function reverse(location, scale, cb, context) {\n      getJSON(this.options.serviceUrl + 'reverse', reverseParams(this.options, {\n        key: this.options.apiKey,\n        coords: [location.lat, location.lng].join(',')\n      }), function (data) {\n        var results = [];\n\n        if (data.status.status == 200) {\n          var center = L__namespace.latLng(data.geometry['lat'], data.geometry['lng']);\n          var bbox = L__namespace.latLngBounds(center, center);\n          results[0] = {\n            name: data.words,\n            bbox: bbox,\n            center: center\n          };\n        }\n\n        cb.call(context, results);\n      });\n    };\n\n    return What3Words;\n  }();\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link What3Words}\r\n   * @param options the options\r\n   */\n\n  function what3words(options) {\n    return new What3Words(options);\n  }\n\n  var geocoders = {\n    __proto__: null,\n    geocodingParams: geocodingParams,\n    reverseParams: reverseParams,\n    ArcGis: ArcGis,\n    arcgis: arcgis,\n    Bing: Bing,\n    bing: bing,\n    Google: Google,\n    google: google,\n    HERE: HERE,\n    HEREv2: HEREv2,\n    here: here,\n    parseLatLng: parseLatLng,\n    LatLng: LatLng,\n    latLng: latLng,\n    Mapbox: Mapbox,\n    mapbox: mapbox,\n    MapQuest: MapQuest,\n    mapQuest: mapQuest,\n    Neutrino: Neutrino,\n    neutrino: neutrino,\n    Nominatim: Nominatim,\n    nominatim: nominatim,\n    OpenLocationCode: OpenLocationCode,\n    openLocationCode: openLocationCode,\n    OpenCage: OpenCage,\n    opencage: opencage,\n    Pelias: Pelias,\n    pelias: pelias,\n    GeocodeEarth: GeocodeEarth,\n    geocodeEarth: geocodeEarth,\n    Mapzen: Mapzen,\n    mapzen: mapzen,\n    Openrouteservice: Openrouteservice,\n    openrouteservice: openrouteservice,\n    Photon: Photon,\n    photon: photon,\n    What3Words: What3Words,\n    what3words: what3words\n  };\n\n  /**\r\n   * Leaflet mixins https://leafletjs.com/reference-1.7.1.html#class-includes\r\n   * for TypeScript https://www.typescriptlang.org/docs/handbook/mixins.html\r\n   * @internal\r\n   */\n\n  var EventedControl = // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  function EventedControl() {// empty\n  };\n\n  L__namespace.Util.extend(EventedControl.prototype, L__namespace.Control.prototype);\n  L__namespace.Util.extend(EventedControl.prototype, L__namespace.Evented.prototype);\n  /**\r\n   * This is the geocoder control. It works like any other [Leaflet control](https://leafletjs.com/reference.html#control), and is added to the map.\r\n   */\n\n  var GeocoderControl = /*#__PURE__*/function (_EventedControl) {\n    _inheritsLoose(GeocoderControl, _EventedControl);\n\n    /**\r\n     * Instantiates a geocoder control (to be invoked using `new`)\r\n     * @param options the options\r\n     */\n    function GeocoderControl(options) {\n      var _this;\n\n      _this = _EventedControl.call(this, options) || this;\n      _this.options = {\n        showUniqueResult: true,\n        showResultIcons: false,\n        collapsed: true,\n        expand: 'touch',\n        position: 'topright',\n        placeholder: 'Search...',\n        errorMessage: 'Nothing found.',\n        iconLabel: 'Initiate a new search',\n        query: '',\n        queryMinLength: 1,\n        suggestMinLength: 3,\n        suggestTimeout: 250,\n        defaultMarkGeocode: true\n      };\n      _this._requestCount = 0;\n      L__namespace.Util.setOptions(_assertThisInitialized(_this), options);\n\n      if (!_this.options.geocoder) {\n        _this.options.geocoder = new Nominatim();\n      }\n\n      return _this;\n    }\n\n    var _proto = GeocoderControl.prototype;\n\n    _proto.addThrobberClass = function addThrobberClass() {\n      L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-throbber');\n    };\n\n    _proto.removeThrobberClass = function removeThrobberClass() {\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-throbber');\n    }\n    /**\r\n     * Returns the container DOM element for the control and add listeners on relevant map events.\r\n     * @param map the map instance\r\n     * @see https://leafletjs.com/reference.html#control-onadd\r\n     */\n    ;\n\n    _proto.onAdd = function onAdd(map) {\n      var _this2 = this;\n\n      var className = 'leaflet-control-geocoder';\n      var container = L__namespace.DomUtil.create('div', className + ' leaflet-bar');\n      var icon = L__namespace.DomUtil.create('button', className + '-icon', container);\n      var form = this._form = L__namespace.DomUtil.create('div', className + '-form', container);\n      this._map = map;\n      this._container = container;\n      icon.innerHTML = '&nbsp;';\n      icon.type = 'button';\n      icon.setAttribute('aria-label', this.options.iconLabel);\n      var input = this._input = L__namespace.DomUtil.create('input', '', form);\n      input.type = 'text';\n      input.value = this.options.query;\n      input.placeholder = this.options.placeholder;\n      L__namespace.DomEvent.disableClickPropagation(input);\n      this._errorElement = L__namespace.DomUtil.create('div', className + '-form-no-error', container);\n      this._errorElement.innerHTML = this.options.errorMessage;\n      this._alts = L__namespace.DomUtil.create('ul', className + '-alternatives leaflet-control-geocoder-alternatives-minimized', container);\n      L__namespace.DomEvent.disableClickPropagation(this._alts);\n      L__namespace.DomEvent.addListener(input, 'keydown', this._keydown, this);\n\n      if (this.options.geocoder.suggest) {\n        L__namespace.DomEvent.addListener(input, 'input', this._change, this);\n      }\n\n      L__namespace.DomEvent.addListener(input, 'blur', function () {\n        if (_this2.options.collapsed && !_this2._preventBlurCollapse) {\n          _this2._collapse();\n        }\n\n        _this2._preventBlurCollapse = false;\n      });\n\n      if (this.options.collapsed) {\n        if (this.options.expand === 'click') {\n          L__namespace.DomEvent.addListener(container, 'click', function (e) {\n            if (e.button === 0 && e.detail !== 2) {\n              _this2._toggle();\n            }\n          });\n        } else if (this.options.expand === 'touch') {\n          L__namespace.DomEvent.addListener(container, L__namespace.Browser.touch ? 'touchstart mousedown' : 'mousedown', function (e) {\n            _this2._toggle();\n\n            e.preventDefault(); // mobile: clicking focuses the icon, so UI expands and immediately collapses\n\n            e.stopPropagation();\n          }, this);\n        } else {\n          L__namespace.DomEvent.addListener(container, 'mouseover', this._expand, this);\n          L__namespace.DomEvent.addListener(container, 'mouseout', this._collapse, this);\n\n          this._map.on('movestart', this._collapse, this);\n        }\n      } else {\n        this._expand();\n\n        if (L__namespace.Browser.touch) {\n          L__namespace.DomEvent.addListener(container, 'touchstart', function () {\n            return _this2._geocode();\n          });\n        } else {\n          L__namespace.DomEvent.addListener(container, 'click', function () {\n            return _this2._geocode();\n          });\n        }\n      }\n\n      if (this.options.defaultMarkGeocode) {\n        this.on('markgeocode', this.markGeocode, this);\n      }\n\n      this.on('startgeocode', this.addThrobberClass, this);\n      this.on('finishgeocode', this.removeThrobberClass, this);\n      this.on('startsuggest', this.addThrobberClass, this);\n      this.on('finishsuggest', this.removeThrobberClass, this);\n      L__namespace.DomEvent.disableClickPropagation(container);\n      return container;\n    }\n    /**\r\n     * Sets the query string on the text input\r\n     * @param string the query string\r\n     */\n    ;\n\n    _proto.setQuery = function setQuery(string) {\n      this._input.value = string;\n      return this;\n    };\n\n    _proto._geocodeResult = function _geocodeResult(results, suggest) {\n      if (!suggest && this.options.showUniqueResult && results.length === 1) {\n        this._geocodeResultSelected(results[0]);\n      } else if (results.length > 0) {\n        this._alts.innerHTML = '';\n        this._results = results;\n        L__namespace.DomUtil.removeClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n        L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-options-open');\n\n        for (var i = 0; i < results.length; i++) {\n          this._alts.appendChild(this._createAlt(results[i], i));\n        }\n      } else {\n        L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-options-error');\n        L__namespace.DomUtil.addClass(this._errorElement, 'leaflet-control-geocoder-error');\n      }\n    }\n    /**\r\n     * Marks a geocoding result on the map\r\n     * @param result the geocoding result\r\n     */\n    ;\n\n    _proto.markGeocode = function markGeocode(event) {\n      var result = event.geocode;\n\n      this._map.fitBounds(result.bbox);\n\n      if (this._geocodeMarker) {\n        this._map.removeLayer(this._geocodeMarker);\n      }\n\n      this._geocodeMarker = new L__namespace.Marker(result.center).bindPopup(result.html || result.name).addTo(this._map).openPopup();\n      return this;\n    };\n\n    _proto._geocode = function _geocode(suggest) {\n      var _this3 = this;\n\n      var value = this._input.value;\n\n      if (!suggest && value.length < this.options.queryMinLength) {\n        return;\n      }\n\n      var requestCount = ++this._requestCount;\n\n      var cb = function cb(results) {\n        if (requestCount === _this3._requestCount) {\n          var _event = {\n            input: value,\n            results: results\n          };\n\n          _this3.fire(suggest ? 'finishsuggest' : 'finishgeocode', _event);\n\n          _this3._geocodeResult(results, suggest);\n        }\n      };\n\n      this._lastGeocode = value;\n\n      if (!suggest) {\n        this._clearResults();\n      }\n\n      var event = {\n        input: value\n      };\n      this.fire(suggest ? 'startsuggest' : 'startgeocode', event);\n\n      if (suggest) {\n        this.options.geocoder.suggest(value, cb);\n      } else {\n        this.options.geocoder.geocode(value, cb);\n      }\n    };\n\n    _proto._geocodeResultSelected = function _geocodeResultSelected(geocode) {\n      var event = {\n        geocode: geocode\n      };\n      this.fire('markgeocode', event);\n    };\n\n    _proto._toggle = function _toggle() {\n      if (L__namespace.DomUtil.hasClass(this._container, 'leaflet-control-geocoder-expanded')) {\n        this._collapse();\n      } else {\n        this._expand();\n      }\n    };\n\n    _proto._expand = function _expand() {\n      L__namespace.DomUtil.addClass(this._container, 'leaflet-control-geocoder-expanded');\n\n      this._input.select();\n\n      this.fire('expand');\n    };\n\n    _proto._collapse = function _collapse() {\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-expanded');\n      L__namespace.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n      L__namespace.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-open');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-error');\n\n      this._input.blur(); // mobile: keyboard shouldn't stay expanded\n\n\n      this.fire('collapse');\n    };\n\n    _proto._clearResults = function _clearResults() {\n      L__namespace.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n      this._selection = null;\n      L__namespace.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-open');\n      L__namespace.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-error');\n    };\n\n    _proto._createAlt = function _createAlt(result, index) {\n      var _this4 = this;\n\n      var li = L__namespace.DomUtil.create('li', ''),\n          a = L__namespace.DomUtil.create('a', '', li),\n          icon = this.options.showResultIcons && result.icon ? L__namespace.DomUtil.create('img', '', a) : null,\n          text = result.html ? undefined : document.createTextNode(result.name),\n          mouseDownHandler = function mouseDownHandler(e) {\n        // In some browsers, a click will fire on the map if the control is\n        // collapsed directly after mousedown. To work around this, we\n        // wait until the click is completed, and _then_ collapse the\n        // control. Messy, but this is the workaround I could come up with\n        // for #142.\n        _this4._preventBlurCollapse = true;\n        L__namespace.DomEvent.stop(e);\n\n        _this4._geocodeResultSelected(result);\n\n        L__namespace.DomEvent.on(li, 'click touchend', function () {\n          if (_this4.options.collapsed) {\n            _this4._collapse();\n          } else {\n            _this4._clearResults();\n          }\n        });\n      };\n\n      if (icon) {\n        icon.src = result.icon;\n      }\n\n      li.setAttribute('data-result-index', String(index));\n\n      if (result.html) {\n        a.innerHTML = a.innerHTML + result.html;\n      } else if (text) {\n        a.appendChild(text);\n      } // Use mousedown and not click, since click will fire _after_ blur,\n      // causing the control to have collapsed and removed the items\n      // before the click can fire.\n\n\n      L__namespace.DomEvent.addListener(li, 'mousedown touchstart', mouseDownHandler, this);\n      return li;\n    };\n\n    _proto._keydown = function _keydown(e) {\n      var _this5 = this;\n\n      var select = function select(dir) {\n        if (_this5._selection) {\n          L__namespace.DomUtil.removeClass(_this5._selection, 'leaflet-control-geocoder-selected');\n          _this5._selection = _this5._selection[dir > 0 ? 'nextSibling' : 'previousSibling'];\n        }\n\n        if (!_this5._selection) {\n          _this5._selection = _this5._alts[dir > 0 ? 'firstChild' : 'lastChild'];\n        }\n\n        if (_this5._selection) {\n          L__namespace.DomUtil.addClass(_this5._selection, 'leaflet-control-geocoder-selected');\n        }\n      };\n\n      switch (e.keyCode) {\n        // Escape\n        case 27:\n          if (this.options.collapsed) {\n            this._collapse();\n          } else {\n            this._clearResults();\n          }\n\n          break;\n        // Up\n\n        case 38:\n          select(-1);\n          break;\n        // Up\n\n        case 40:\n          select(1);\n          break;\n        // Enter\n\n        case 13:\n          if (this._selection) {\n            var index = parseInt(this._selection.getAttribute('data-result-index'), 10);\n\n            this._geocodeResultSelected(this._results[index]);\n\n            this._clearResults();\n          } else {\n            this._geocode();\n          }\n\n          break;\n\n        default:\n          return;\n      }\n\n      L__namespace.DomEvent.preventDefault(e);\n    };\n\n    _proto._change = function _change() {\n      var _this6 = this;\n\n      var v = this._input.value;\n\n      if (v !== this._lastGeocode) {\n        clearTimeout(this._suggestTimeout);\n\n        if (v.length >= this.options.suggestMinLength) {\n          this._suggestTimeout = setTimeout(function () {\n            return _this6._geocode(true);\n          }, this.options.suggestTimeout);\n        } else {\n          this._clearResults();\n        }\n      }\n    };\n\n    return GeocoderControl;\n  }(EventedControl);\n  /**\r\n   * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link GeocoderControl}\r\n   * @param options the options\r\n   */\n\n  function geocoder(options) {\n    return new GeocoderControl(options);\n  }\n\n  /* @preserve\r\n   * Leaflet Control Geocoder\r\n   * https://github.com/perliedman/leaflet-control-geocoder\r\n   *\r\n   * Copyright (c) 2012 sa3m (https://github.com/sa3m)\r\n   * Copyright (c) 2018 Per Liedman\r\n   * All rights reserved.\r\n   */\n  L__namespace.Util.extend(GeocoderControl, geocoders);\n  L__namespace.Util.extend(L__namespace.Control, {\n    Geocoder: GeocoderControl,\n    geocoder: geocoder\n  });\n\n  exports.Geocoder = GeocoderControl;\n  exports.default = GeocoderControl;\n  exports.geocoder = geocoder;\n  exports.geocoders = geocoders;\n\n  return exports;\n\n}({}, L));\n//# sourceMappingURL=Control.Geocoder.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC1jb250cm9sLWdlb2NvZGVyL2Rpc3QvQ29udHJvbC5HZW9jb2Rlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsZUFBZTtBQUNmLGNBQWM7QUFDZCxjQUFjO0FBQ2QsZ0JBQWdCO0FBQ2hCLGdCQUFnQjtBQUNoQixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QiwwQkFBMEI7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QjtBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTs7QUFFQSxnQ0FBZ0M7O0FBRWhDO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCLG9CQUFvQjtBQUM1QztBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7OztBQUcxQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVk7QUFDWjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsNkZBQTZGO0FBQzdGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsQ0FBQyxHQUFHO0FBQ0oiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LW1hcC1hZHZhbmNlLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci9kaXN0L0NvbnRyb2wuR2VvY29kZXIuanM/OTNiNiJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgbGVhZmxldENvbnRyb2xHZW9jb2RlciA9IChmdW5jdGlvbiAoZXhwb3J0cywgTCkge1xuXG4gIGZ1bmN0aW9uIF9pbnRlcm9wTmFtZXNwYWNlKGUpIHtcbiAgICBpZiAoZSAmJiBlLl9fZXNNb2R1bGUpIHJldHVybiBlO1xuICAgIHZhciBuID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBpZiAoZSkge1xuICAgICAgT2JqZWN0LmtleXMoZSkuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuICAgICAgICBpZiAoayAhPT0gJ2RlZmF1bHQnKSB7XG4gICAgICAgICAgdmFyIGQgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGUsIGspO1xuICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLCBrLCBkLmdldCA/IGQgOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgIHJldHVybiBlW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgblsnZGVmYXVsdCddID0gZTtcbiAgICByZXR1cm4gbjtcbiAgfVxuXG4gIHZhciBMX19uYW1lc3BhY2UgPSAvKiNfX1BVUkVfXyovX2ludGVyb3BOYW1lc3BhY2UoTCk7XG5cbiAgZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTtcbiAgICBzdWJDbGFzcy5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBzdWJDbGFzcztcbiAgICBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzO1xuICB9XG5cbiAgZnVuY3Rpb24gX2Fzc2VydFRoaXNJbml0aWFsaXplZChzZWxmKSB7XG4gICAgaWYgKHNlbGYgPT09IHZvaWQgMCkge1xuICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxmO1xuICB9XG5cbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gZ2VvY29kaW5nUGFyYW1zKG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHJldHVybiBMX19uYW1lc3BhY2UuVXRpbC5leHRlbmQocGFyYW1zLCBvcHRpb25zLmdlb2NvZGluZ1F1ZXJ5UGFyYW1zKTtcbiAgfVxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICBmdW5jdGlvbiByZXZlcnNlUGFyYW1zKG9wdGlvbnMsIHBhcmFtcykge1xuICAgIHJldHVybiBMX19uYW1lc3BhY2UuVXRpbC5leHRlbmQocGFyYW1zLCBvcHRpb25zLnJldmVyc2VRdWVyeVBhcmFtcyk7XG4gIH1cblxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICB2YXIgbGFzdENhbGxiYWNrSWQgPSAwOyAvLyBBZGFwdGVkIGZyb20gaGFuZGxlYmFycy5qc1xuICAvLyBodHRwczovL2dpdGh1Yi5jb20vd3ljYXRzL2hhbmRsZWJhcnMuanMvXG5cbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG5cbiAgdmFyIGJhZENoYXJzID0gL1smPD5cIidgXS9nO1xuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICB2YXIgcG9zc2libGUgPSAvWyY8PlwiJ2BdLztcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG5cbiAgdmFyIGVzY2FwZSA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgICByZXR1cm4gZXNjYXBlW2Nocl07XG4gIH1cbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG5cblxuICBmdW5jdGlvbiBodG1sRXNjYXBlKHN0cmluZykge1xuICAgIGlmIChzdHJpbmcgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH0gZWxzZSBpZiAoIXN0cmluZykge1xuICAgICAgcmV0dXJuIHN0cmluZyArICcnO1xuICAgIH0gLy8gRm9yY2UgYSBzdHJpbmcgY29udmVyc2lvbiBhcyB0aGlzIHdpbGwgYmUgZG9uZSBieSB0aGUgYXBwZW5kIHJlZ2FyZGxlc3MgYW5kXG4gICAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gICAgLy8gYW4gb2JqZWN0J3MgdG8gc3RyaW5nIGhhcyBlc2NhcGVkIGNoYXJhY3RlcnMgaW4gaXQuXG5cblxuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nO1xuXG4gICAgaWYgKCFwb3NzaWJsZS50ZXN0KHN0cmluZykpIHtcbiAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgfVxuXG4gICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbiAgfVxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICBmdW5jdGlvbiBqc29ucCh1cmwsIHBhcmFtcywgY2FsbGJhY2ssIGNvbnRleHQsIGpzb25wUGFyYW0pIHtcbiAgICB2YXIgY2FsbGJhY2tJZCA9ICdfbF9nZW9jb2Rlcl8nICsgbGFzdENhbGxiYWNrSWQrKztcbiAgICBwYXJhbXNbanNvbnBQYXJhbSB8fCAnY2FsbGJhY2snXSA9IGNhbGxiYWNrSWQ7XG4gICAgd2luZG93W2NhbGxiYWNrSWRdID0gTF9fbmFtZXNwYWNlLlV0aWwuYmluZChjYWxsYmFjaywgY29udGV4dCk7XG4gICAgdmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gICAgc2NyaXB0LnNyYyA9IHVybCArIGdldFBhcmFtU3RyaW5nKHBhcmFtcyk7XG4gICAgc2NyaXB0LmlkID0gY2FsbGJhY2tJZDtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gIH1cbiAgLyoqXHJcbiAgICogQGludGVybmFsXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gZ2V0SlNPTih1cmwsIHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICB2YXIgeG1sSHR0cCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuXG4gICAgeG1sSHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoeG1sSHR0cC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIG1lc3NhZ2U7XG5cbiAgICAgIGlmICh4bWxIdHRwLnN0YXR1cyAhPT0gMjAwICYmIHhtbEh0dHAuc3RhdHVzICE9PSAzMDQpIHtcbiAgICAgICAgbWVzc2FnZSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgeG1sSHR0cC5yZXNwb25zZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgLy8gSUUgZG9lc24ndCBwYXJzZSBKU09OIHJlc3BvbnNlcyBldmVuIHdpdGggcmVzcG9uc2VUeXBlOiAnanNvbicuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbWVzc2FnZSA9IEpTT04ucGFyc2UoeG1sSHR0cC5yZXNwb25zZSk7XG4gICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAvLyBOb3QgYSBKU09OIHJlc3BvbnNlXG4gICAgICAgICAgbWVzc2FnZSA9IHhtbEh0dHAucmVzcG9uc2U7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1lc3NhZ2UgPSB4bWxIdHRwLnJlc3BvbnNlO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhtZXNzYWdlKTtcbiAgICB9O1xuXG4gICAgeG1sSHR0cC5vcGVuKCdHRVQnLCB1cmwgKyBnZXRQYXJhbVN0cmluZyhwYXJhbXMpLCB0cnVlKTtcbiAgICB4bWxIdHRwLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgICB4bWxIdHRwLnNldFJlcXVlc3RIZWFkZXIoJ0FjY2VwdCcsICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgeG1sSHR0cC5zZW5kKG51bGwpO1xuICB9XG4gIC8qKlxyXG4gICAqIEBpbnRlcm5hbFxyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIHRlbXBsYXRlKHN0ciwgZGF0YSkge1xuICAgIHJldHVybiBzdHIucmVwbGFjZSgvXFx7ICooW1xcd19dKykgKlxcfS9nLCBmdW5jdGlvbiAoc3RyLCBrZXkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFba2V5XTtcblxuICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUoZGF0YSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBodG1sRXNjYXBlKHZhbHVlKTtcbiAgICB9KTtcbiAgfVxuICAvKipcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICBmdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcbiAgICB2YXIgcGFyYW1zID0gW107XG5cbiAgICBmb3IgKHZhciBpIGluIG9iaikge1xuICAgICAgdmFyIGtleSA9IGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKTtcbiAgICAgIHZhciB2YWx1ZSA9IG9ialtpXTtcblxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBwYXJhbXMucHVzaChrZXkgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoU3RyaW5nKHZhbHVlKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWx1ZS5sZW5ndGg7IGorKykge1xuICAgICAgICAgIHBhcmFtcy5wdXNoKGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZVtqXSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtBcmNHSVMgZ2VvY29kZXJdKGh0dHBzOi8vZGV2ZWxvcGVycy5hcmNnaXMuY29tL2ZlYXR1cmVzL2dlb2NvZGluZy8pXHJcbiAgICovXG5cbiAgdmFyIEFyY0dpcyA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQXJjR2lzKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vZ2VvY29kZS5hcmNnaXMuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1dvcmxkL0dlb2NvZGVTZXJ2ZXInLFxuICAgICAgICBhcGlLZXk6ICcnXG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gQXJjR2lzLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIHRva2VuOiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICBTaW5nbGVMaW5lOiBxdWVyeSxcbiAgICAgICAgb3V0RmllbGRzOiAnQWRkcl9UeXBlJyxcbiAgICAgICAgZm9yU3RvcmFnZTogZmFsc2UsXG4gICAgICAgIG1heExvY2F0aW9uczogMTAsXG4gICAgICAgIGY6ICdqc29uJ1xuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJy9maW5kQWRkcmVzc0NhbmRpZGF0ZXMnLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEuY2FuZGlkYXRlcyAmJiBkYXRhLmNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGF0YS5jYW5kaWRhdGVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGRhdGEuY2FuZGlkYXRlc1tpXTtcbiAgICAgICAgICAgIHZhciBsYXRMbmcgPSBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5sb2NhdGlvbi55LCBsb2MubG9jYXRpb24ueCk7XG4gICAgICAgICAgICB2YXIgbGF0TG5nQm91bmRzID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5leHRlbnQueW1heCwgbG9jLmV4dGVudC54bWF4KSwgTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuZXh0ZW50LnltaW4sIGxvYy5leHRlbnQueG1pbikpO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogbG9jLmFkZHJlc3MsXG4gICAgICAgICAgICAgIGJib3g6IGxhdExuZ0JvdW5kcyxcbiAgICAgICAgICAgICAgY2VudGVyOiBsYXRMbmdcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc3VnZ2VzdCA9IGZ1bmN0aW9uIHN1Z2dlc3QocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgbG9jYXRpb246IGxvY2F0aW9uLmxuZyArICcsJyArIGxvY2F0aW9uLmxhdCxcbiAgICAgICAgZGlzdGFuY2U6IDEwMCxcbiAgICAgICAgZjogJ2pzb24nXG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnL3JldmVyc2VHZW9jb2RlJywgcGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEgJiYgIWRhdGEuZXJyb3IpIHtcbiAgICAgICAgICB2YXIgY2VudGVyID0gTF9fbmFtZXNwYWNlLmxhdExuZyhkYXRhLmxvY2F0aW9uLnksIGRhdGEubG9jYXRpb24ueCk7XG4gICAgICAgICAgdmFyIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBkYXRhLmFkZHJlc3MuTWF0Y2hfYWRkcixcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgICAgYmJveDogYmJveFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBBcmNHaXM7XG4gIH0oKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIEFyY0dpc31cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGFyY2dpcyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBBcmNHaXMob3B0aW9ucyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW0JpbmcgTG9jYXRpb25zIEFQSV0oaHR0cHM6Ly9kb2NzLm1pY3Jvc29mdC5jb20vZW4tdXMvYmluZ21hcHMvcmVzdC1zZXJ2aWNlcy9sb2NhdGlvbnMvKVxyXG4gICAqL1xuXG4gIHZhciBCaW5nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBCaW5nKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vZGV2LnZpcnR1YWxlYXJ0aC5uZXQvUkVTVC92MS9Mb2NhdGlvbnMnXG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gQmluZy5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2VvY29kZSA9IGZ1bmN0aW9uIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBxdWVyeTogcXVlcnksXG4gICAgICAgIGtleTogdGhpcy5vcHRpb25zLmFwaUtleVxuICAgICAgfSk7XG4gICAgICBqc29ucCh0aGlzLm9wdGlvbnMuYXBpS2V5LCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEucmVzb3VyY2VTZXRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gZGF0YS5yZXNvdXJjZVNldHNbMF0ucmVzb3VyY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgcmVzb3VyY2UgPSBkYXRhLnJlc291cmNlU2V0c1swXS5yZXNvdXJjZXNbaV0sXG4gICAgICAgICAgICAgICAgYmJveCA9IHJlc291cmNlLmJib3g7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgICBuYW1lOiByZXNvdXJjZS5uYW1lLFxuICAgICAgICAgICAgICBiYm94OiBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKFtiYm94WzBdLCBiYm94WzFdXSwgW2Jib3hbMl0sIGJib3hbM11dKSxcbiAgICAgICAgICAgICAgY2VudGVyOiBMX19uYW1lc3BhY2UubGF0TG5nKHJlc291cmNlLnBvaW50LmNvb3JkaW5hdGVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSwgdGhpcywgJ2pzb25wJyk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAga2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5XG4gICAgICB9KTtcbiAgICAgIGpzb25wKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEucmVzb3VyY2VTZXRzWzBdLnJlc291cmNlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHZhciByZXNvdXJjZSA9IGRhdGEucmVzb3VyY2VTZXRzWzBdLnJlc291cmNlc1tpXSxcbiAgICAgICAgICAgICAgYmJveCA9IHJlc291cmNlLmJib3g7XG4gICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IHJlc291cmNlLm5hbWUsXG4gICAgICAgICAgICBiYm94OiBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKFtiYm94WzBdLCBiYm94WzFdXSwgW2Jib3hbMl0sIGJib3hbM11dKSxcbiAgICAgICAgICAgIGNlbnRlcjogTF9fbmFtZXNwYWNlLmxhdExuZyhyZXNvdXJjZS5wb2ludC5jb29yZGluYXRlcylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0sIHRoaXMsICdqc29ucCcpO1xuICAgIH07XG5cbiAgICByZXR1cm4gQmluZztcbiAgfSgpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgQmluZ31cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGJpbmcob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgQmluZyhvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBHb29nbGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEdvb2dsZShvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL21hcHMuZ29vZ2xlYXBpcy5jb20vbWFwcy9hcGkvZ2VvY29kZS9qc29uJ1xuICAgICAgfTtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IEdvb2dsZS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2VvY29kZSA9IGZ1bmN0aW9uIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIGFkZHJlc3M6IHF1ZXJ5XG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5yZXN1bHRzICYmIGRhdGEucmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkYXRhLnJlc3VsdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gZGF0YS5yZXN1bHRzW2ldO1xuICAgICAgICAgICAgdmFyIGxhdExuZyA9IExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmdlb21ldHJ5LmxvY2F0aW9uKTtcbiAgICAgICAgICAgIHZhciBsYXRMbmdCb3VuZHMgPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmdlb21ldHJ5LnZpZXdwb3J0Lm5vcnRoZWFzdCksIExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmdlb21ldHJ5LnZpZXdwb3J0LnNvdXRod2VzdCkpO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogbG9jLmZvcm1hdHRlZF9hZGRyZXNzLFxuICAgICAgICAgICAgICBiYm94OiBsYXRMbmdCb3VuZHMsXG4gICAgICAgICAgICAgIGNlbnRlcjogbGF0TG5nLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBsb2MuYWRkcmVzc19jb21wb25lbnRzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIGxhdGxuZzogbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nXG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5yZXN1bHRzICYmIGRhdGEucmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkYXRhLnJlc3VsdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gZGF0YS5yZXN1bHRzW2ldO1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmdlb21ldHJ5LmxvY2F0aW9uKTtcbiAgICAgICAgICAgIHZhciBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5nZW9tZXRyeS52aWV3cG9ydC5ub3J0aGVhc3QpLCBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5nZW9tZXRyeS52aWV3cG9ydC5zb3V0aHdlc3QpKTtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSB7XG4gICAgICAgICAgICAgIG5hbWU6IGxvYy5mb3JtYXR0ZWRfYWRkcmVzcyxcbiAgICAgICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IGxvYy5hZGRyZXNzX2NvbXBvbmVudHNcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gR29vZ2xlO1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBHb29nbGV9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICAgKi9cblxuICBmdW5jdGlvbiBnb29nbGUob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgR29vZ2xlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtIRVJFIEdlb2NvZGVyIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIuaGVyZS5jb20vZG9jdW1lbnRhdGlvbi9nZW9jb2Rlci90b3BpY3MvaW50cm9kdWN0aW9uLmh0bWwpXHJcbiAgICovXG5cbiAgdmFyIEhFUkUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhFUkUob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9nZW9jb2Rlci5hcGkuaGVyZS5jb20vNi4yLycsXG4gICAgICAgIGFwcF9pZDogJycsXG4gICAgICAgIGFwcF9jb2RlOiAnJyxcbiAgICAgICAgYXBpS2V5OiAnJyxcbiAgICAgICAgbWF4UmVzdWx0czogNVxuICAgICAgfTtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5hcGlLZXkpIHRocm93IEVycm9yKCdhcGlLZXkgaXMgbm90IHN1cHBvcnRlZCwgdXNlIGFwcF9pZC9hcHBfY29kZSBpbnN0ZWFkIScpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBIRVJFLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIHNlYXJjaHRleHQ6IHF1ZXJ5LFxuICAgICAgICBnZW46IDksXG4gICAgICAgIGFwcF9pZDogdGhpcy5vcHRpb25zLmFwcF9pZCxcbiAgICAgICAgYXBwX2NvZGU6IHRoaXMub3B0aW9ucy5hcHBfY29kZSxcbiAgICAgICAganNvbmF0dHJpYnV0ZXM6IDEsXG4gICAgICAgIG1heHJlc3VsdHM6IHRoaXMub3B0aW9ucy5tYXhSZXN1bHRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICdnZW9jb2RlLmpzb24nLCBwYXJhbXMsIGNiLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwcm94ID0gbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nO1xuXG4gICAgICBpZiAodGhpcy5vcHRpb25zLnJldmVyc2VHZW9jb2RlUHJveFJhZGl1cykge1xuICAgICAgICBwcm94ICs9ICcsJyArIHRoaXMub3B0aW9ucy5yZXZlcnNlR2VvY29kZVByb3hSYWRpdXM7XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBwcm94OiBwcm94LFxuICAgICAgICBtb2RlOiAncmV0cmlldmVBZGRyZXNzZXMnLFxuICAgICAgICBhcHBfaWQ6IHRoaXMub3B0aW9ucy5hcHBfaWQsXG4gICAgICAgIGFwcF9jb2RlOiB0aGlzLm9wdGlvbnMuYXBwX2NvZGUsXG4gICAgICAgIGdlbjogOSxcbiAgICAgICAganNvbmF0dHJpYnV0ZXM6IDEsXG4gICAgICAgIG1heHJlc3VsdHM6IHRoaXMub3B0aW9ucy5tYXhSZXN1bHRzXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICdyZXZlcnNlZ2VvY29kZS5qc29uJywgcGFyYW1zLCBjYiwgY29udGV4dCk7XG4gICAgfTtcblxuICAgIF9wcm90by5nZXRKU09OID0gZnVuY3Rpb24gZ2V0SlNPTiQxKHVybCwgcGFyYW1zLCBjYiwgY29udGV4dCkge1xuICAgICAgZ2V0SlNPTih1cmwsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5yZXNwb25zZS52aWV3ICYmIGRhdGEucmVzcG9uc2Uudmlldy5sZW5ndGgpIHtcbiAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBkYXRhLnJlc3BvbnNlLnZpZXdbMF0ucmVzdWx0Lmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgdmFyIGxvYyA9IGRhdGEucmVzcG9uc2Uudmlld1swXS5yZXN1bHRbaV0ubG9jYXRpb247XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuZGlzcGxheVBvc2l0aW9uLmxhdGl0dWRlLCBsb2MuZGlzcGxheVBvc2l0aW9uLmxvbmdpdHVkZSk7XG4gICAgICAgICAgICB2YXIgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MubWFwVmlldy50b3BMZWZ0LmxhdGl0dWRlLCBsb2MubWFwVmlldy50b3BMZWZ0LmxvbmdpdHVkZSksIExfX25hbWVzcGFjZS5sYXRMbmcobG9jLm1hcFZpZXcuYm90dG9tUmlnaHQubGF0aXR1ZGUsIGxvYy5tYXBWaWV3LmJvdHRvbVJpZ2h0LmxvbmdpdHVkZSkpO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogbG9jLmFkZHJlc3MubGFiZWwsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IGxvYy5hZGRyZXNzLFxuICAgICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBIRVJFO1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuZXcgW0hFUkUgR2VvY29kZXIgQVBJXShodHRwczovL2RldmVsb3Blci5oZXJlLmNvbS9kb2N1bWVudGF0aW9uL2dlb2NvZGluZy1zZWFyY2gtYXBpL2FwaS1yZWZlcmVuY2Utc3dhZ2dlci5odG1sKVxyXG4gICAqL1xuXG4gIHZhciBIRVJFdjIgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEhFUkV2MihvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2dlb2NvZGUuc2VhcmNoLmhlcmVhcGkuY29tL3YxJyxcbiAgICAgICAgYXBpS2V5OiAnJyxcbiAgICAgICAgYXBwX2lkOiAnJyxcbiAgICAgICAgYXBwX2NvZGU6ICcnLFxuICAgICAgICBtYXhSZXN1bHRzOiAxMFxuICAgICAgfTtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90bzIgPSBIRVJFdjIucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvMi5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIHE6IHF1ZXJ5LFxuICAgICAgICBhcGlLZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIGxpbWl0OiB0aGlzLm9wdGlvbnMubWF4UmVzdWx0c1xuICAgICAgfSk7XG5cbiAgICAgIGlmICghcGFyYW1zLmF0ICYmICFwYXJhbXNbXCJpblwiXSkge1xuICAgICAgICB0aHJvdyBFcnJvcignYXQgLyBpbiBwYXJhbWV0ZXJzIG5vdCBmb3VuZC4gUGxlYXNlIGRlZmluZSBjb29yZGluYXRlcyAoYXQ9bGF0aXR1ZGUsbG9uZ2l0dWRlKSBvciBvdGhlciAoaW4pIGluIHlvdXIgZ2VvY29kaW5nUXVlcnlQYXJhbXMuJyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICcvZGlzY292ZXInLCBwYXJhbXMsIGNiLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgYXQ6IGxvY2F0aW9uLmxhdCArICcsJyArIGxvY2F0aW9uLmxuZyxcbiAgICAgICAgbGltaXQ6IHRoaXMub3B0aW9ucy5yZXZlcnNlR2VvY29kZVByb3hSYWRpdXMsXG4gICAgICAgIGFwaUtleTogdGhpcy5vcHRpb25zLmFwaUtleVxuICAgICAgfSk7XG4gICAgICB0aGlzLmdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnL3Jldmdlb2NvZGUnLCBwYXJhbXMsIGNiLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvMi5nZXRKU09OID0gZnVuY3Rpb24gZ2V0SlNPTiQxKHVybCwgcGFyYW1zLCBjYiwgY29udGV4dCkge1xuICAgICAgZ2V0SlNPTih1cmwsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5pdGVtcyAmJiBkYXRhLml0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRhdGEuaXRlbXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IGRhdGEuaXRlbXNbaV07XG4gICAgICAgICAgICB2YXIgbGF0TG5nID0gTF9fbmFtZXNwYWNlLmxhdExuZyhpdGVtLnBvc2l0aW9uLmxhdCwgaXRlbS5wb3NpdGlvbi5sbmcpO1xuICAgICAgICAgICAgdmFyIGJib3ggPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChpdGVtLm1hcFZpZXcpIHtcbiAgICAgICAgICAgICAgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoTF9fbmFtZXNwYWNlLmxhdExuZyhpdGVtLm1hcFZpZXcuc291dGgsIGl0ZW0ubWFwVmlldy53ZXN0KSwgTF9fbmFtZXNwYWNlLmxhdExuZyhpdGVtLm1hcFZpZXcubm9ydGgsIGl0ZW0ubWFwVmlldy5lYXN0KSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAvLyBVc2luZyBvbmx5IHBvc2l0aW9uIHdoZW4gbm90IHByb3ZpZGVkXG4gICAgICAgICAgICAgIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKExfX25hbWVzcGFjZS5sYXRMbmcoaXRlbS5wb3NpdGlvbi5sYXQsIGl0ZW0ucG9zaXRpb24ubG5nKSwgTF9fbmFtZXNwYWNlLmxhdExuZyhpdGVtLnBvc2l0aW9uLmxhdCwgaXRlbS5wb3NpdGlvbi5sbmcpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogaXRlbS5hZGRyZXNzLmxhYmVsLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBpdGVtLmFkZHJlc3MsXG4gICAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICAgIGNlbnRlcjogbGF0TG5nXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIEhFUkV2MjtcbiAgfSgpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgSEVSRX1cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGhlcmUob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmFwaUtleSkge1xuICAgICAgcmV0dXJuIG5ldyBIRVJFdjIob3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBuZXcgSEVSRShvcHRpb25zKTtcbiAgICB9XG4gIH1cblxuICAvKipcclxuICAgKiBQYXJzZXMgYmFzaWMgbGF0aXR1ZGUvbG9uZ2l0dWRlIHN0cmluZ3Mgc3VjaCBhcyBgJzUwLjA2NzczIDE0LjM3NzQyJ2AsIGAnTjUwLjA2NzczIFcxNC4zNzc0MidgLCBgJ1MgNTDCsCAwNC4wNjQgRSAwMTTCsCAyMi42NDUnYCwgb3IgYCdTIDUwwrAgNOKAsiAwMy44MjjigLMsIFcgMTTCsCAyMuKAsiAzOC43MTLigLMnYFxyXG4gICAqIEBwYXJhbSBxdWVyeSB0aGUgbGF0aXR1ZGUvbG9uZ2l0dWRlIHN0cmluZyB0byBwYXJzZVxyXG4gICAqIEByZXR1cm5zIHRoZSBwYXJzZWQgbGF0aXR1ZGUvbG9uZ2l0dWRlXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gcGFyc2VMYXRMbmcocXVlcnkpIHtcbiAgICB2YXIgbWF0Y2g7IC8vIHJlZ2V4IGZyb20gaHR0cHM6Ly9naXRodWIuY29tL29wZW5zdHJlZXRtYXAvb3BlbnN0cmVldG1hcC13ZWJzaXRlL2Jsb2IvbWFzdGVyL2FwcC9jb250cm9sbGVycy9nZW9jb2Rlcl9jb250cm9sbGVyLnJiXG5cbiAgICBpZiAobWF0Y2ggPSBxdWVyeS5tYXRjaCgvXihbTlNdKVxccyooXFxkezEsM30oPzpcXC5cXGQqKT8pXFxXKihbRVddKVxccyooXFxkezEsM30oPzpcXC5cXGQqKT8pJC8pKSB7XG4gICAgICAvLyBbTlNFV10gZGVjaW1hbCBkZWdyZWVzXG4gICAgICByZXR1cm4gTF9fbmFtZXNwYWNlLmxhdExuZygoL04vaS50ZXN0KG1hdGNoWzFdKSA/IDEgOiAtMSkgKiArbWF0Y2hbMl0sICgvRS9pLnRlc3QobWF0Y2hbM10pID8gMSA6IC0xKSAqICttYXRjaFs0XSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaCA9IHF1ZXJ5Lm1hdGNoKC9eKFxcZHsxLDN9KD86XFwuXFxkKik/KVxccyooW05TXSlcXFcqKFxcZHsxLDN9KD86XFwuXFxkKik/KVxccyooW0VXXSkkLykpIHtcbiAgICAgIC8vIGRlY2ltYWwgZGVncmVlcyBbTlNFV11cbiAgICAgIHJldHVybiBMX19uYW1lc3BhY2UubGF0TG5nKCgvTi9pLnRlc3QobWF0Y2hbMl0pID8gMSA6IC0xKSAqICttYXRjaFsxXSwgKC9FL2kudGVzdChtYXRjaFs0XSkgPyAxIDogLTEpICogK21hdGNoWzNdKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gcXVlcnkubWF0Y2goL14oW05TXSlcXHMqKFxcZHsxLDN9KcKwP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1sn4oCyXT9cXFcqKFtFV10pXFxzKihcXGR7MSwzfSnCsD9cXHMqKFxcZHsxLDN9KD86XFwuXFxkKik/KT9bJ+KAsl0/JC8pKSB7XG4gICAgICAvLyBbTlNFV10gZGVncmVlcywgZGVjaW1hbCBtaW51dGVzXG4gICAgICByZXR1cm4gTF9fbmFtZXNwYWNlLmxhdExuZygoL04vaS50ZXN0KG1hdGNoWzFdKSA/IDEgOiAtMSkgKiAoK21hdGNoWzJdICsgK21hdGNoWzNdIC8gNjApLCAoL0UvaS50ZXN0KG1hdGNoWzRdKSA/IDEgOiAtMSkgKiAoK21hdGNoWzVdICsgK21hdGNoWzZdIC8gNjApKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gcXVlcnkubWF0Y2goL14oXFxkezEsM30pwrA/XFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPyk/WyfigLJdP1xccyooW05TXSlcXFcqKFxcZHsxLDN9KcKwP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1sn4oCyXT9cXHMqKFtFV10pJC8pKSB7XG4gICAgICAvLyBkZWdyZWVzLCBkZWNpbWFsIG1pbnV0ZXMgW05TRVddXG4gICAgICByZXR1cm4gTF9fbmFtZXNwYWNlLmxhdExuZygoL04vaS50ZXN0KG1hdGNoWzNdKSA/IDEgOiAtMSkgKiAoK21hdGNoWzFdICsgK21hdGNoWzJdIC8gNjApLCAoL0UvaS50ZXN0KG1hdGNoWzZdKSA/IDEgOiAtMSkgKiAoK21hdGNoWzRdICsgK21hdGNoWzVdIC8gNjApKTtcbiAgICB9IGVsc2UgaWYgKG1hdGNoID0gcXVlcnkubWF0Y2goL14oW05TXSlcXHMqKFxcZHsxLDN9KcKwP1xccyooXFxkezEsMn0pWyfigLJdP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1tcIuKAs10/XFxXKihbRVddKVxccyooXFxkezEsM30pwrA/XFxzKihcXGR7MSwyfSlbJ+KAsl0/XFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPyk/W1wi4oCzXT8kLykpIHtcbiAgICAgIC8vIFtOU0VXXSBkZWdyZWVzLCBtaW51dGVzLCBkZWNpbWFsIHNlY29uZHNcbiAgICAgIHJldHVybiBMX19uYW1lc3BhY2UubGF0TG5nKCgvTi9pLnRlc3QobWF0Y2hbMV0pID8gMSA6IC0xKSAqICgrbWF0Y2hbMl0gKyArbWF0Y2hbM10gLyA2MCArICttYXRjaFs0XSAvIDM2MDApLCAoL0UvaS50ZXN0KG1hdGNoWzVdKSA/IDEgOiAtMSkgKiAoK21hdGNoWzZdICsgK21hdGNoWzddIC8gNjAgKyArbWF0Y2hbOF0gLyAzNjAwKSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaCA9IHF1ZXJ5Lm1hdGNoKC9eKFxcZHsxLDN9KcKwP1xccyooXFxkezEsMn0pWyfigLJdP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1tcIuKAs11cXHMqKFtOU10pXFxXKihcXGR7MSwzfSnCsD9cXHMqKFxcZHsxLDJ9KVsn4oCyXT9cXHMqKFxcZHsxLDN9KD86XFwuXFxkKik/KT9bXCLigLNdP1xccyooW0VXXSkkLykpIHtcbiAgICAgIC8vIGRlZ3JlZXMsIG1pbnV0ZXMsIGRlY2ltYWwgc2Vjb25kcyBbTlNFV11cbiAgICAgIHJldHVybiBMX19uYW1lc3BhY2UubGF0TG5nKCgvTi9pLnRlc3QobWF0Y2hbNF0pID8gMSA6IC0xKSAqICgrbWF0Y2hbMV0gKyArbWF0Y2hbMl0gLyA2MCArICttYXRjaFszXSAvIDM2MDApLCAoL0UvaS50ZXN0KG1hdGNoWzhdKSA/IDEgOiAtMSkgKiAoK21hdGNoWzVdICsgK21hdGNoWzZdIC8gNjAgKyArbWF0Y2hbN10gLyAzNjAwKSk7XG4gICAgfSBlbHNlIGlmIChtYXRjaCA9IHF1ZXJ5Lm1hdGNoKC9eXFxzKihbKy1dP1xcZCsoPzpcXC5cXGQqKT8pXFxzKltcXHMsXVxccyooWystXT9cXGQrKD86XFwuXFxkKik/KVxccyokLykpIHtcbiAgICAgIHJldHVybiBMX19uYW1lc3BhY2UubGF0TG5nKCttYXRjaFsxXSwgK21hdGNoWzJdKTtcbiAgICB9XG4gIH1cbiAgLyoqXHJcbiAgICogUGFyc2VzIGJhc2ljIGxhdGl0dWRlL2xvbmdpdHVkZSBzdHJpbmdzIHN1Y2ggYXMgYCc1MC4wNjc3MyAxNC4zNzc0MidgLCBgJ041MC4wNjc3MyBXMTQuMzc3NDInYCwgYCdTIDUwwrAgMDQuMDY0IEUgMDE0wrAgMjIuNjQ1J2AsIG9yIGAnUyA1MMKwIDTigLIgMDMuODI44oCzLCBXIDE0wrAgMjLigLIgMzguNzEy4oCzJ2BcclxuICAgKi9cblxuICB2YXIgTGF0TG5nID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBMYXRMbmcob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBuZXh0OiB1bmRlZmluZWQsXG4gICAgICAgIHNpemVJbk1ldGVyczogMTAwMDBcbiAgICAgIH07XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBMYXRMbmcucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIGNlbnRlciA9IHBhcnNlTGF0TG5nKHF1ZXJ5KTtcblxuICAgICAgaWYgKGNlbnRlcikge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFt7XG4gICAgICAgICAgbmFtZTogcXVlcnksXG4gICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgYmJveDogY2VudGVyLnRvQm91bmRzKHRoaXMub3B0aW9ucy5zaXplSW5NZXRlcnMpXG4gICAgICAgIH1dO1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubmV4dCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMubmV4dC5nZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBMYXRMbmc7XG4gIH0oKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIExhdExuZ31cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGxhdExuZyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBMYXRMbmcob3B0aW9ucyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW01hcGJveCBHZW9jb2RpbmddKGh0dHBzOi8vd3d3Lm1hcGJveC5jb20vYXBpLWRvY3VtZW50YXRpb24vI2dlb2NvZGluZylcclxuICAgKi9cblxuICB2YXIgTWFwYm94ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBib3gob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9hcGkubWFwYm94LmNvbS9nZW9jb2RpbmcvdjUvbWFwYm94LnBsYWNlcy8nXG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gTWFwYm94LnByb3RvdHlwZTtcblxuICAgIF9wcm90by5fZ2V0UHJvcGVydGllcyA9IGZ1bmN0aW9uIF9nZXRQcm9wZXJ0aWVzKGxvYykge1xuICAgICAgdmFyIHByb3BlcnRpZXMgPSB7XG4gICAgICAgIHRleHQ6IGxvYy50ZXh0LFxuICAgICAgICBhZGRyZXNzOiBsb2MuYWRkcmVzc1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAobG9jLmNvbnRleHQgfHwgW10pLmxlbmd0aDsgaisrKSB7XG4gICAgICAgIHZhciBpZCA9IGxvYy5jb250ZXh0W2pdLmlkLnNwbGl0KCcuJylbMF07XG4gICAgICAgIHByb3BlcnRpZXNbaWRdID0gbG9jLmNvbnRleHRbal0udGV4dDsgLy8gR2V0IGNvdW50cnkgY29kZSB3aGVuIGF2YWlsYWJsZVxuXG4gICAgICAgIGlmIChsb2MuY29udGV4dFtqXS5zaG9ydF9jb2RlKSB7XG4gICAgICAgICAgcHJvcGVydGllc1snY291bnRyeVNob3J0Q29kZSddID0gbG9jLmNvbnRleHRbal0uc2hvcnRfY29kZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9O1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLm9wdGlvbnMuYXBpS2V5XG4gICAgICB9KTtcblxuICAgICAgaWYgKHBhcmFtcy5wcm94aW1pdHkgIT09IHVuZGVmaW5lZCAmJiBwYXJhbXMucHJveGltaXR5LmxhdCAhPT0gdW5kZWZpbmVkICYmIHBhcmFtcy5wcm94aW1pdHkubG5nICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcGFyYW1zLnByb3hpbWl0eSA9IHBhcmFtcy5wcm94aW1pdHkubG5nICsgJywnICsgcGFyYW1zLnByb3hpbWl0eS5sYXQ7XG4gICAgICB9XG5cbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyBlbmNvZGVVUklDb21wb25lbnQocXVlcnkpICsgJy5qc29uJywgcGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLmZlYXR1cmVzICYmIGRhdGEuZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPD0gZGF0YS5mZWF0dXJlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBkYXRhLmZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmNlbnRlci5yZXZlcnNlKCkpO1xuICAgICAgICAgICAgdmFyIGJib3ggPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChsb2MuYmJveCkge1xuICAgICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5iYm94LnNsaWNlKDAsIDIpLnJldmVyc2UoKSksIExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmJib3guc2xpY2UoMiwgNCkucmV2ZXJzZSgpKSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSB7XG4gICAgICAgICAgICAgIG5hbWU6IGxvYy5wbGFjZV9uYW1lLFxuICAgICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX3RoaXMuX2dldFByb3BlcnRpZXMobG9jKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5zdWdnZXN0ID0gZnVuY3Rpb24gc3VnZ2VzdChxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gICAgICB2YXIgdXJsID0gdGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyBsb2NhdGlvbi5sbmcgKyAnLCcgKyBsb2NhdGlvbi5sYXQgKyAnLmpzb24nO1xuICAgICAgdmFyIHBhcmFtID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgYWNjZXNzX3Rva2VuOiB0aGlzLm9wdGlvbnMuYXBpS2V5XG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odXJsLCBwYXJhbSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5mZWF0dXJlcyAmJiBkYXRhLmZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IGRhdGEuZmVhdHVyZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gZGF0YS5mZWF0dXJlc1tpXTtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5jZW50ZXIucmV2ZXJzZSgpKTtcbiAgICAgICAgICAgIHZhciBiYm94ID0gdm9pZCAwO1xuXG4gICAgICAgICAgICBpZiAobG9jLmJib3gpIHtcbiAgICAgICAgICAgICAgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuYmJveC5zbGljZSgwLCAyKS5yZXZlcnNlKCkpLCBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5iYm94LnNsaWNlKDIsIDQpLnJldmVyc2UoKSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgICBuYW1lOiBsb2MucGxhY2VfbmFtZSxcbiAgICAgICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICAgIHByb3BlcnRpZXM6IF90aGlzMi5fZ2V0UHJvcGVydGllcyhsb2MpXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcGJveDtcbiAgfSgpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgTWFwYm94fVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gbWFwYm94KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE1hcGJveChvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbTWFwUXVlc3QgR2VvY29kaW5nIEFQSV0oaHR0cDovL2RldmVsb3Blci5tYXBxdWVzdC5jb20vd2ViL3Byb2R1Y3RzL2Rldi1zZXJ2aWNlcy9nZW9jb2Rpbmctd3MpXHJcbiAgICovXG5cbiAgdmFyIE1hcFF1ZXN0ID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNYXBRdWVzdChvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL3d3dy5tYXBxdWVzdGFwaS5jb20vZ2VvY29kaW5nL3YxJ1xuICAgICAgfTtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7IC8vIE1hcFF1ZXN0IHNlZW1zIHRvIHByb3ZpZGUgVVJJIGVuY29kZWQgQVBJIGtleXMsXG4gICAgICAvLyBzbyB0byBhdm9pZCBlbmNvZGluZyB0aGVtIHR3aWNlLCB3ZSBkZWNvZGUgdGhlbSBoZXJlXG5cbiAgICAgIHRoaXMub3B0aW9ucy5hcGlLZXkgPSBkZWNvZGVVUklDb21wb25lbnQodGhpcy5vcHRpb25zLmFwaUtleSk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IE1hcFF1ZXN0LnByb3RvdHlwZTtcblxuICAgIF9wcm90by5fZm9ybWF0TmFtZSA9IGZ1bmN0aW9uIF9mb3JtYXROYW1lKCkge1xuICAgICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5maWx0ZXIoZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgcmV0dXJuICEhcztcbiAgICAgIH0pLmpvaW4oJywgJyk7XG4gICAgfTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgbG9jYXRpb246IHF1ZXJ5LFxuICAgICAgICBsaW1pdDogNSxcbiAgICAgICAgb3V0Rm9ybWF0OiAnanNvbidcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICcvYWRkcmVzcycsIHBhcmFtcywgTF9fbmFtZXNwYWNlLlV0aWwuYmluZChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLnJlc3VsdHMgJiYgZGF0YS5yZXN1bHRzWzBdLmxvY2F0aW9ucykge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBkYXRhLnJlc3VsdHNbMF0ubG9jYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICB2YXIgbG9jID0gZGF0YS5yZXN1bHRzWzBdLmxvY2F0aW9uc1tpXTtcbiAgICAgICAgICAgIHZhciBjZW50ZXIgPSBMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5sYXRMbmcpO1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgICAgbmFtZTogdGhpcy5fZm9ybWF0TmFtZShsb2Muc3RyZWV0LCBsb2MuYWRtaW5BcmVhNCwgbG9jLmFkbWluQXJlYTMsIGxvYy5hZG1pbkFyZWExKSxcbiAgICAgICAgICAgICAgYmJveDogTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlciksXG4gICAgICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9LCB0aGlzKSk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAga2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICBsb2NhdGlvbjogbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nLFxuICAgICAgICBvdXRwdXRGb3JtYXQ6ICdqc29uJ1xuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJy9yZXZlcnNlJywgcGFyYW1zLCBMX19uYW1lc3BhY2UuVXRpbC5iaW5kKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEucmVzdWx0cyAmJiBkYXRhLnJlc3VsdHNbMF0ubG9jYXRpb25zKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEucmVzdWx0c1swXS5sb2NhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBkYXRhLnJlc3VsdHNbMF0ubG9jYXRpb25zW2ldO1xuICAgICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcobG9jLmxhdExuZyk7XG4gICAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgICBuYW1lOiB0aGlzLl9mb3JtYXROYW1lKGxvYy5zdHJlZXQsIGxvYy5hZG1pbkFyZWE0LCBsb2MuYWRtaW5BcmVhMywgbG9jLmFkbWluQXJlYTEpLFxuICAgICAgICAgICAgICBiYm94OiBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKSxcbiAgICAgICAgICAgICAgY2VudGVyOiBjZW50ZXJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIE1hcFF1ZXN0O1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBNYXBRdWVzdH1cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIG1hcFF1ZXN0KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE1hcFF1ZXN0KG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtOZXV0cmlubyBBUEldKGh0dHBzOi8vd3d3Lm5ldXRyaW5vYXBpLmNvbS9hcGkvZ2VvY29kZS1hZGRyZXNzLylcclxuICAgKi9cblxuICB2YXIgTmV1dHJpbm8gPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE5ldXRyaW5vKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgdXNlcklkOiB1bmRlZmluZWQsXG4gICAgICAgIGFwaUtleTogdW5kZWZpbmVkLFxuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9uZXV0cmlub2FwaS5jb20vJ1xuICAgICAgfTtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfSAvLyBodHRwczovL3d3dy5uZXV0cmlub2FwaS5jb20vYXBpL2dlb2NvZGUtYWRkcmVzcy9cblxuXG4gICAgdmFyIF9wcm90byA9IE5ldXRyaW5vLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGFwaUtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgdXNlcklkOiB0aGlzLm9wdGlvbnMudXNlcklkLFxuICAgICAgICAvL2dldCB0aHJlZSB3b3JkcyBhbmQgbWFrZSBhIGRvdCBiYXNlZCBzdHJpbmdcbiAgICAgICAgYWRkcmVzczogcXVlcnkuc3BsaXQoL1xccysvKS5qb2luKCcuJylcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICdnZW9jb2RlLWFkZHJlc3MnLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEubG9jYXRpb25zKSB7XG4gICAgICAgICAgZGF0YS5nZW9tZXRyeSA9IGRhdGEubG9jYXRpb25zWzBdO1xuICAgICAgICAgIHZhciBjZW50ZXIgPSBMX19uYW1lc3BhY2UubGF0TG5nKGRhdGEuZ2VvbWV0cnlbJ2xhdGl0dWRlJ10sIGRhdGEuZ2VvbWV0cnlbJ2xvbmdpdHVkZSddKTtcbiAgICAgICAgICB2YXIgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgIHJlc3VsdHNbMF0gPSB7XG4gICAgICAgICAgICBuYW1lOiBkYXRhLmdlb21ldHJ5LmFkZHJlc3MsXG4gICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc3VnZ2VzdCA9IGZ1bmN0aW9uIHN1Z2dlc3QocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCk7XG4gICAgfSAvLyBodHRwczovL3d3dy5uZXV0cmlub2FwaS5jb20vYXBpL2dlb2NvZGUtcmV2ZXJzZS9cbiAgICA7XG5cbiAgICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGFwaUtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgdXNlcklkOiB0aGlzLm9wdGlvbnMudXNlcklkLFxuICAgICAgICBsYXRpdHVkZTogbG9jYXRpb24ubGF0LFxuICAgICAgICBsb25naXR1ZGU6IGxvY2F0aW9uLmxuZ1xuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ2dlb2NvZGUtcmV2ZXJzZScsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5zdGF0dXMuc3RhdHVzID09IDIwMCAmJiBkYXRhLmZvdW5kKSB7XG4gICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcobG9jYXRpb24ubGF0LCBsb2NhdGlvbi5sbmcpO1xuICAgICAgICAgIHZhciBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgcmVzdWx0c1swXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGRhdGEuYWRkcmVzcyxcbiAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIHJldHVybiBOZXV0cmlubztcbiAgfSgpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgTmV1dHJpbm99XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICAgKi9cblxuICBmdW5jdGlvbiBuZXV0cmlubyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBOZXV0cmlubyhvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxyXG4gICAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbTm9taW5hdGltXShodHRwczovL3dpa2kub3BlbnN0cmVldG1hcC5vcmcvd2lraS9Ob21pbmF0aW0pIGdlb2NvZGVyLlxyXG4gICAqXHJcbiAgICogVGhpcyBpcyB0aGUgZGVmYXVsdCBnZW9jb2Rpbmcgc2VydmljZSB1c2VkIGJ5IHRoZSBjb250cm9sLCB1bmxlc3Mgb3RoZXJ3aXNlIHNwZWNpZmllZCBpbiB0aGUgb3B0aW9ucy5cclxuICAgKlxyXG4gICAqIFVubGVzcyB1c2luZyB5b3VyIG93biBOb21pbmF0aW0gaW5zdGFsbGF0aW9uLCBwbGVhc2UgcmVmZXIgdG8gdGhlIFtOb21pbmF0aW0gdXNhZ2UgcG9saWN5XShodHRwczovL29wZXJhdGlvbnMub3NtZm91bmRhdGlvbi5vcmcvcG9saWNpZXMvbm9taW5hdGltLykuXHJcbiAgICovXG5cbiAgdmFyIE5vbWluYXRpbSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTm9taW5hdGltKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vbm9taW5hdGltLm9wZW5zdHJlZXRtYXAub3JnLycsXG4gICAgICAgIGh0bWxUZW1wbGF0ZTogZnVuY3Rpb24gaHRtbFRlbXBsYXRlKHIpIHtcbiAgICAgICAgICB2YXIgYWRkcmVzcyA9IHIuYWRkcmVzcztcbiAgICAgICAgICB2YXIgY2xhc3NOYW1lO1xuICAgICAgICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgICAgICAgaWYgKGFkZHJlc3Mucm9hZCB8fCBhZGRyZXNzLmJ1aWxkaW5nKSB7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCd7YnVpbGRpbmd9IHtyb2FkfSB7aG91c2VfbnVtYmVyfScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChhZGRyZXNzLmNpdHkgfHwgYWRkcmVzcy50b3duIHx8IGFkZHJlc3MudmlsbGFnZSB8fCBhZGRyZXNzLmhhbWxldCkge1xuICAgICAgICAgICAgY2xhc3NOYW1lID0gcGFydHMubGVuZ3RoID4gMCA/ICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWRkcmVzcy1kZXRhaWwnIDogJyc7XG4gICAgICAgICAgICBwYXJ0cy5wdXNoKCc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc05hbWUgKyAnXCI+e3Bvc3Rjb2RlfSB7Y2l0eX0ge3Rvd259IHt2aWxsYWdlfSB7aGFtbGV0fTwvc3Bhbj4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoYWRkcmVzcy5zdGF0ZSB8fCBhZGRyZXNzLmNvdW50cnkpIHtcbiAgICAgICAgICAgIGNsYXNzTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLWFkZHJlc3MtY29udGV4dCcgOiAnJztcbiAgICAgICAgICAgIHBhcnRzLnB1c2goJzxzcGFuIGNsYXNzPVwiJyArIGNsYXNzTmFtZSArICdcIj57c3RhdGV9IHtjb3VudHJ5fTwvc3Bhbj4nKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXR1cm4gdGVtcGxhdGUocGFydHMuam9pbignPGJyLz4nKSwgYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMgfHwge30pO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBOb21pbmF0aW0ucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgcTogcXVlcnksXG4gICAgICAgIGxpbWl0OiA1LFxuICAgICAgICBmb3JtYXQ6ICdqc29uJyxcbiAgICAgICAgYWRkcmVzc2RldGFpbHM6IDFcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICdzZWFyY2gnLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IGRhdGEubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB2YXIgYmJveCA9IGRhdGFbaV0uYm91bmRpbmdib3g7XG5cbiAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDQ7IGorKykge1xuICAgICAgICAgICAgYmJveFtqXSA9ICtiYm94W2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdHNbaV0gPSB7XG4gICAgICAgICAgICBpY29uOiBkYXRhW2ldLmljb24sXG4gICAgICAgICAgICBuYW1lOiBkYXRhW2ldLmRpc3BsYXlfbmFtZSxcbiAgICAgICAgICAgIGh0bWw6IF90aGlzLm9wdGlvbnMuaHRtbFRlbXBsYXRlID8gX3RoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUoZGF0YVtpXSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBiYm94OiBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKFtiYm94WzBdLCBiYm94WzJdXSwgW2Jib3hbMV0sIGJib3hbM11dKSxcbiAgICAgICAgICAgIGNlbnRlcjogTF9fbmFtZXNwYWNlLmxhdExuZyhkYXRhW2ldLmxhdCwgZGF0YVtpXS5sb24pLFxuICAgICAgICAgICAgcHJvcGVydGllczogZGF0YVtpXVxuICAgICAgICAgIH07XG4gICAgICAgIH1cblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGxhdDogbG9jYXRpb24ubGF0LFxuICAgICAgICBsb246IGxvY2F0aW9uLmxuZyxcbiAgICAgICAgem9vbTogTWF0aC5yb3VuZChNYXRoLmxvZyhzY2FsZSAvIDI1NikgLyBNYXRoLmxvZygyKSksXG4gICAgICAgIGFkZHJlc3NkZXRhaWxzOiAxLFxuICAgICAgICBmb3JtYXQ6ICdqc29uJ1xuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ3JldmVyc2UnLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmxhdCAmJiBkYXRhLmxvbikge1xuICAgICAgICAgIHZhciBjZW50ZXIgPSBMX19uYW1lc3BhY2UubGF0TG5nKGRhdGEubGF0LCBkYXRhLmxvbik7XG4gICAgICAgICAgdmFyIGJib3ggPSBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBkYXRhLmRpc3BsYXlfbmFtZSxcbiAgICAgICAgICAgIGh0bWw6IF90aGlzMi5vcHRpb25zLmh0bWxUZW1wbGF0ZSA/IF90aGlzMi5vcHRpb25zLmh0bWxUZW1wbGF0ZShkYXRhKSA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IGRhdGFcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gTm9taW5hdGltO1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBOb21pbmF0aW19XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICAgKi9cblxuICBmdW5jdGlvbiBub21pbmF0aW0ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgTm9taW5hdGltKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtQbHVzIGNvZGVzXShodHRwczovL3BsdXMuY29kZXMvKSAoZm9ybWVybHkgT3BlbkxvY2F0aW9uQ29kZSkgKHJlcXVpcmVzIFtvcGVuLWxvY2F0aW9uLWNvZGVdKGh0dHBzOi8vd3d3Lm5wbWpzLmNvbS9wYWNrYWdlL29wZW4tbG9jYXRpb24tY29kZSkpXHJcbiAgICovXG5cbiAgdmFyIE9wZW5Mb2NhdGlvbkNvZGUgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE9wZW5Mb2NhdGlvbkNvZGUob3B0aW9ucykge1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gT3BlbkxvY2F0aW9uQ29kZS5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2VvY29kZSA9IGZ1bmN0aW9uIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZGVjb2RlZCA9IHRoaXMub3B0aW9ucy5PcGVuTG9jYXRpb25Db2RlLmRlY29kZShxdWVyeSk7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgbmFtZTogcXVlcnksXG4gICAgICAgICAgY2VudGVyOiBMX19uYW1lc3BhY2UubGF0TG5nKGRlY29kZWQubGF0aXR1ZGVDZW50ZXIsIGRlY29kZWQubG9uZ2l0dWRlQ2VudGVyKSxcbiAgICAgICAgICBiYm94OiBMX19uYW1lc3BhY2UubGF0TG5nQm91bmRzKExfX25hbWVzcGFjZS5sYXRMbmcoZGVjb2RlZC5sYXRpdHVkZUxvLCBkZWNvZGVkLmxvbmdpdHVkZUxvKSwgTF9fbmFtZXNwYWNlLmxhdExuZyhkZWNvZGVkLmxhdGl0dWRlSGksIGRlY29kZWQubG9uZ2l0dWRlSGkpKVxuICAgICAgICB9O1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIFtyZXN1bHRdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIFtdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgX3Byb3RvLnJldmVyc2UgPSBmdW5jdGlvbiByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBjb2RlID0gdGhpcy5vcHRpb25zLk9wZW5Mb2NhdGlvbkNvZGUuZW5jb2RlKGxvY2F0aW9uLmxhdCwgbG9jYXRpb24ubG5nLCB0aGlzLm9wdGlvbnMuY29kZUxlbmd0aCk7XG4gICAgICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgICAgbmFtZTogY29kZSxcbiAgICAgICAgICBjZW50ZXI6IExfX25hbWVzcGFjZS5sYXRMbmcobG9jYXRpb24ubGF0LCBsb2NhdGlvbi5sbmcpLFxuICAgICAgICAgIGJib3g6IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoTF9fbmFtZXNwYWNlLmxhdExuZyhsb2NhdGlvbi5sYXQsIGxvY2F0aW9uLmxuZyksIExfX25hbWVzcGFjZS5sYXRMbmcobG9jYXRpb24ubGF0LCBsb2NhdGlvbi5sbmcpKVxuICAgICAgICB9O1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIFtyZXN1bHRdKTtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS53YXJuKGUpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIFtdKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIE9wZW5Mb2NhdGlvbkNvZGU7XG4gIH0oKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIE9wZW5Mb2NhdGlvbkNvZGV9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICAgKi9cblxuICBmdW5jdGlvbiBvcGVuTG9jYXRpb25Db2RlKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IE9wZW5Mb2NhdGlvbkNvZGUob3B0aW9ucyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW09wZW5DYWdlIERhdGEgQVBJXShodHRwczovL29wZW5jYWdlZGF0YS5jb20vKVxyXG4gICAqL1xuXG4gIHZhciBPcGVuQ2FnZSA9IC8qI19fUFVSRV9fKi9mdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gT3BlbkNhZ2Uob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9hcGkub3BlbmNhZ2VkYXRhLmNvbS9nZW9jb2RlL3YxL2pzb24nXG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gT3BlbkNhZ2UucHJvdG90eXBlO1xuXG4gICAgX3Byb3RvLmdlb2NvZGUgPSBmdW5jdGlvbiBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAga2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICBxOiBxdWVyeVxuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEucmVzdWx0cyAmJiBkYXRhLnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBkYXRhLnJlc3VsdHNbaV07XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgdmFyIGJib3ggPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChsb2MuYW5ub3RhdGlvbnMgJiYgbG9jLmFubm90YXRpb25zLmJvdW5kcykge1xuICAgICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5hbm5vdGF0aW9ucy5ib3VuZHMubm9ydGhlYXN0KSwgTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuYW5ub3RhdGlvbnMuYm91bmRzLnNvdXRod2VzdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBsb2MuZm9ybWF0dGVkLFxuICAgICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc3VnZ2VzdCA9IGZ1bmN0aW9uIHN1Z2dlc3QocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAga2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICBxOiBbbG9jYXRpb24ubGF0LCBsb2NhdGlvbi5sbmddLmpvaW4oJywnKVxuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHZhciByZXN1bHRzID0gW107XG5cbiAgICAgICAgaWYgKGRhdGEucmVzdWx0cyAmJiBkYXRhLnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLnJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBsb2MgPSBkYXRhLnJlc3VsdHNbaV07XG4gICAgICAgICAgICB2YXIgY2VudGVyID0gTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuZ2VvbWV0cnkpO1xuICAgICAgICAgICAgdmFyIGJib3ggPSB2b2lkIDA7XG5cbiAgICAgICAgICAgIGlmIChsb2MuYW5ub3RhdGlvbnMgJiYgbG9jLmFubm90YXRpb25zLmJvdW5kcykge1xuICAgICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UubGF0TG5nKGxvYy5hbm5vdGF0aW9ucy5ib3VuZHMubm9ydGhlYXN0KSwgTF9fbmFtZXNwYWNlLmxhdExuZyhsb2MuYW5ub3RhdGlvbnMuYm91bmRzLnNvdXRod2VzdCkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgICBuYW1lOiBsb2MuZm9ybWF0dGVkLFxuICAgICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICByZXR1cm4gT3BlbkNhZ2U7XG4gIH0oKTtcbiAgZnVuY3Rpb24gb3BlbmNhZ2Uob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgT3BlbkNhZ2Uob3B0aW9ucyk7XG4gIH1cblxuICAvKipcclxuICAgKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW1BlbGlhc10oaHR0cHM6Ly9wZWxpYXMuaW8vKSwgW2dlb2NvZGUuZWFydGhdKGh0dHBzOi8vZ2VvY29kZS5lYXJ0aC8pIGdlb2NvZGVyIChmb3JtZXJseSBNYXB6ZW4gU2VhcmNoKVxyXG4gICAqL1xuXG4gIHZhciBQZWxpYXMgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFBlbGlhcyhvcHRpb25zKSB7XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2FwaS5nZW9jb2RlLmVhcnRoL3YxJ1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2xhc3RTdWdnZXN0ID0gMDtcbiAgICAgIExfX25hbWVzcGFjZS5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgfVxuXG4gICAgdmFyIF9wcm90byA9IFBlbGlhcy5wcm90b3R5cGU7XG5cbiAgICBfcHJvdG8uZ2VvY29kZSA9IGZ1bmN0aW9uIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gICAgICB2YXIgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBhcGlfa2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgICB0ZXh0OiBxdWVyeVxuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJy9zZWFyY2gnLCBwYXJhbXMsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgX3RoaXMuX3BhcnNlUmVzdWx0cyhkYXRhLCAnYmJveCcpKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc3VnZ2VzdCA9IGZ1bmN0aW9uIHN1Z2dlc3QocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMyID0gdGhpcztcblxuICAgICAgdmFyIHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgICAgYXBpX2tleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgICAgdGV4dDogcXVlcnlcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICcvYXV0b2NvbXBsZXRlJywgcGFyYW1zLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YS5nZW9jb2RpbmcudGltZXN0YW1wID4gX3RoaXMyLl9sYXN0U3VnZ2VzdCkge1xuICAgICAgICAgIF90aGlzMi5fbGFzdFN1Z2dlc3QgPSBkYXRhLmdlb2NvZGluZy50aW1lc3RhbXA7XG4gICAgICAgICAgY2IuY2FsbChjb250ZXh0LCBfdGhpczIuX3BhcnNlUmVzdWx0cyhkYXRhLCAnYmJveCcpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICB2YXIgX3RoaXMzID0gdGhpcztcblxuICAgICAgdmFyIHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIGFwaV9rZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgICdwb2ludC5sYXQnOiBsb2NhdGlvbi5sYXQsXG4gICAgICAgICdwb2ludC5sb24nOiBsb2NhdGlvbi5sbmdcbiAgICAgIH0pO1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICcvcmV2ZXJzZScsIHBhcmFtcywgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCBfdGhpczMuX3BhcnNlUmVzdWx0cyhkYXRhLCAnYm91bmRzJykpO1xuICAgICAgfSk7XG4gICAgfTtcblxuICAgIF9wcm90by5fcGFyc2VSZXN1bHRzID0gZnVuY3Rpb24gX3BhcnNlUmVzdWx0cyhkYXRhLCBiYm94bmFtZSkge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgIExfX25hbWVzcGFjZS5nZW9KU09OKGRhdGEsIHtcbiAgICAgICAgcG9pbnRUb0xheWVyOiBmdW5jdGlvbiBwb2ludFRvTGF5ZXIoZmVhdHVyZSwgbGF0bG5nKSB7XG4gICAgICAgICAgcmV0dXJuIExfX25hbWVzcGFjZS5jaXJjbGVNYXJrZXIobGF0bG5nKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25FYWNoRmVhdHVyZTogZnVuY3Rpb24gb25FYWNoRmVhdHVyZShmZWF0dXJlLCBsYXllcikge1xuICAgICAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgICAgICB2YXIgYmJveDtcbiAgICAgICAgICB2YXIgY2VudGVyO1xuXG4gICAgICAgICAgaWYgKGxheWVyLmdldEJvdW5kcykge1xuICAgICAgICAgICAgYmJveCA9IGxheWVyLmdldEJvdW5kcygpO1xuICAgICAgICAgICAgY2VudGVyID0gYmJveC5nZXRDZW50ZXIoKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGxheWVyLmZlYXR1cmUuYmJveCkge1xuICAgICAgICAgICAgY2VudGVyID0gbGF5ZXIuZ2V0TGF0TG5nKCk7XG4gICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhMX19uYW1lc3BhY2UuR2VvSlNPTi5jb29yZHNUb0xhdExuZyhsYXllci5mZWF0dXJlLmJib3guc2xpY2UoMCwgMikpLCBMX19uYW1lc3BhY2UuR2VvSlNPTi5jb29yZHNUb0xhdExuZyhsYXllci5mZWF0dXJlLmJib3guc2xpY2UoMiwgNCkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2VudGVyID0gbGF5ZXIuZ2V0TGF0TG5nKCk7XG4gICAgICAgICAgICBiYm94ID0gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0Lm5hbWUgPSBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMubGFiZWw7XG4gICAgICAgICAgcmVzdWx0LmNlbnRlciA9IGNlbnRlcjtcbiAgICAgICAgICByZXN1bHRbYmJveG5hbWVdID0gYmJveDtcbiAgICAgICAgICByZXN1bHQucHJvcGVydGllcyA9IGxheWVyLmZlYXR1cmUucHJvcGVydGllcztcbiAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xuXG4gICAgcmV0dXJuIFBlbGlhcztcbiAgfSgpO1xuICAvKipcclxuICAgKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgUGVsaWFzfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gcGVsaWFzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFBlbGlhcyhvcHRpb25zKTtcbiAgfVxuICB2YXIgR2VvY29kZUVhcnRoID0gUGVsaWFzO1xuICB2YXIgZ2VvY29kZUVhcnRoID0gcGVsaWFzO1xuICAvKipcclxuICAgKiByLmkucC5cclxuICAgKiBAZGVwcmVjYXRlZFxyXG4gICAqL1xuXG4gIHZhciBNYXB6ZW4gPSBQZWxpYXM7XG4gIC8qKlxyXG4gICAqIHIuaS5wLlxyXG4gICAqIEBkZXByZWNhdGVkXHJcbiAgICovXG5cbiAgdmFyIG1hcHplbiA9IHBlbGlhcztcbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtPcGVucm91dGVzZXJ2aWNlXShodHRwczovL29wZW5yb3V0ZXNlcnZpY2Uub3JnL2Rldi8jL2FwaS1kb2NzL2dlb2NvZGUpIGdlb2NvZGVyXHJcbiAgICovXG5cbiAgdmFyIE9wZW5yb3V0ZXNlcnZpY2UgPSAvKiNfX1BVUkVfXyovZnVuY3Rpb24gKF9QZWxpYXMpIHtcbiAgICBfaW5oZXJpdHNMb29zZShPcGVucm91dGVzZXJ2aWNlLCBfUGVsaWFzKTtcblxuICAgIGZ1bmN0aW9uIE9wZW5yb3V0ZXNlcnZpY2Uob3B0aW9ucykge1xuICAgICAgcmV0dXJuIF9QZWxpYXMuY2FsbCh0aGlzLCBMX19uYW1lc3BhY2UuVXRpbC5leHRlbmQoe1xuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9hcGkub3BlbnJvdXRlc2VydmljZS5vcmcvZ2VvY29kZSdcbiAgICAgIH0sIG9wdGlvbnMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBPcGVucm91dGVzZXJ2aWNlO1xuICB9KFBlbGlhcyk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBPcGVucm91dGVzZXJ2aWNlfVxyXG4gICAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAgICovXG5cbiAgZnVuY3Rpb24gb3BlbnJvdXRlc2VydmljZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG5ldyBPcGVucm91dGVzZXJ2aWNlKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtQaG90b25dKGh0dHA6Ly9waG90b24ua29tb290LmRlLykgZ2VvY29kZXJcclxuICAgKi9cblxuICB2YXIgUGhvdG9uID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQaG90b24ob3B0aW9ucykge1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9waG90b24ua29tb290LmlvL2FwaS8nLFxuICAgICAgICByZXZlcnNlVXJsOiAnaHR0cHM6Ly9waG90b24ua29tb290LmlvL3JldmVyc2UvJyxcbiAgICAgICAgbmFtZVByb3BlcnRpZXM6IFsnbmFtZScsICdzdHJlZXQnLCAnc3VidXJiJywgJ2hhbWxldCcsICd0b3duJywgJ2NpdHknLCAnc3RhdGUnLCAnY291bnRyeSddXG4gICAgICB9O1xuICAgICAgTF9fbmFtZXNwYWNlLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gUGhvdG9uLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICAgIHE6IHF1ZXJ5XG4gICAgICB9KTtcbiAgICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwsIHBhcmFtcywgTF9fbmFtZXNwYWNlLlV0aWwuYmluZChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuX2RlY29kZUZlYXR1cmVzKGRhdGEpKTtcbiAgICAgIH0sIHRoaXMpKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLnN1Z2dlc3QgPSBmdW5jdGlvbiBzdWdnZXN0KHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmV2ZXJzZSA9IGZ1bmN0aW9uIHJldmVyc2UobGF0TG5nLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIHZhciBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBsYXQ6IGxhdExuZy5sYXQsXG4gICAgICAgIGxvbjogbGF0TG5nLmxuZ1xuICAgICAgfSk7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5yZXZlcnNlVXJsLCBwYXJhbXMsIExfX25hbWVzcGFjZS5VdGlsLmJpbmQoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLl9kZWNvZGVGZWF0dXJlcyhkYXRhKSk7XG4gICAgICB9LCB0aGlzKSk7XG4gICAgfTtcblxuICAgIF9wcm90by5fZGVjb2RlRmVhdHVyZXMgPSBmdW5jdGlvbiBfZGVjb2RlRmVhdHVyZXMoZGF0YSkge1xuICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5mZWF0dXJlcykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGRhdGEuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB2YXIgZiA9IGRhdGEuZmVhdHVyZXNbaV07XG4gICAgICAgICAgdmFyIGMgPSBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgIHZhciBjZW50ZXIgPSBMX19uYW1lc3BhY2UubGF0TG5nKGNbMV0sIGNbMF0pO1xuICAgICAgICAgIHZhciBleHRlbnQgPSBmLnByb3BlcnRpZXMuZXh0ZW50O1xuICAgICAgICAgIHZhciBiYm94ID0gZXh0ZW50ID8gTF9fbmFtZXNwYWNlLmxhdExuZ0JvdW5kcyhbZXh0ZW50WzFdLCBleHRlbnRbMF1dLCBbZXh0ZW50WzNdLCBleHRlbnRbMl1dKSA6IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLl9kZWNvZGVGZWF0dXJlTmFtZShmKSxcbiAgICAgICAgICAgIGh0bWw6IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUgPyB0aGlzLm9wdGlvbnMuaHRtbFRlbXBsYXRlKGYpIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgcHJvcGVydGllczogZi5wcm9wZXJ0aWVzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdHM7XG4gICAgfTtcblxuICAgIF9wcm90by5fZGVjb2RlRmVhdHVyZU5hbWUgPSBmdW5jdGlvbiBfZGVjb2RlRmVhdHVyZU5hbWUoZikge1xuICAgICAgcmV0dXJuICh0aGlzLm9wdGlvbnMubmFtZVByb3BlcnRpZXMgfHwgW10pLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICByZXR1cm4gZi5wcm9wZXJ0aWVzW3BdO1xuICAgICAgfSkuZmlsdGVyKGZ1bmN0aW9uICh2KSB7XG4gICAgICAgIHJldHVybiAhIXY7XG4gICAgICB9KS5qb2luKCcsICcpO1xuICAgIH07XG5cbiAgICByZXR1cm4gUGhvdG9uO1xuICB9KCk7XG4gIC8qKlxyXG4gICAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBQaG90b259XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICAgKi9cblxuICBmdW5jdGlvbiBwaG90b24ob3B0aW9ucykge1xuICAgIHJldHVybiBuZXcgUGhvdG9uKG9wdGlvbnMpO1xuICB9XG5cbiAgLyoqXHJcbiAgICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFdoYXQzV29yZHMgc2VydmljZVxyXG4gICAqL1xuXG4gIHZhciBXaGF0M1dvcmRzID0gLyojX19QVVJFX18qL2Z1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBXaGF0M1dvcmRzKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vYXBpLndoYXQzd29yZHMuY29tL3YyLydcbiAgICAgIH07XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIHZhciBfcHJvdG8gPSBXaGF0M1dvcmRzLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5nZW9jb2RlID0gZnVuY3Rpb24gZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAgIC8vZ2V0IHRocmVlIHdvcmRzIGFuZCBtYWtlIGEgZG90IGJhc2VkIHN0cmluZ1xuICAgICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICdmb3J3YXJkJywgZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIGFkZHI6IHF1ZXJ5LnNwbGl0KC9cXHMrLykuam9pbignLicpXG4gICAgICB9KSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcblxuICAgICAgICBpZiAoZGF0YS5nZW9tZXRyeSkge1xuICAgICAgICAgIHZhciBsYXRMbmcgPSBMX19uYW1lc3BhY2UubGF0TG5nKGRhdGEuZ2VvbWV0cnlbJ2xhdCddLCBkYXRhLmdlb21ldHJ5WydsbmcnXSk7XG4gICAgICAgICAgdmFyIGxhdExuZ0JvdW5kcyA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMobGF0TG5nLCBsYXRMbmcpO1xuICAgICAgICAgIHJlc3VsdHNbMF0gPSB7XG4gICAgICAgICAgICBuYW1lOiBkYXRhLndvcmRzLFxuICAgICAgICAgICAgYmJveDogbGF0TG5nQm91bmRzLFxuICAgICAgICAgICAgY2VudGVyOiBsYXRMbmdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG5cbiAgICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICBfcHJvdG8uc3VnZ2VzdCA9IGZ1bmN0aW9uIHN1Z2dlc3QocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgICByZXR1cm4gdGhpcy5nZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCk7XG4gICAgfTtcblxuICAgIF9wcm90by5yZXZlcnNlID0gZnVuY3Rpb24gcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ3JldmVyc2UnLCByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIGNvb3JkczogW2xvY2F0aW9uLmxhdCwgbG9jYXRpb24ubG5nXS5qb2luKCcsJylcbiAgICAgIH0pLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICB2YXIgcmVzdWx0cyA9IFtdO1xuXG4gICAgICAgIGlmIChkYXRhLnN0YXR1cy5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgdmFyIGNlbnRlciA9IExfX25hbWVzcGFjZS5sYXRMbmcoZGF0YS5nZW9tZXRyeVsnbGF0J10sIGRhdGEuZ2VvbWV0cnlbJ2xuZyddKTtcbiAgICAgICAgICB2YXIgYmJveCA9IExfX25hbWVzcGFjZS5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgIHJlc3VsdHNbMF0gPSB7XG4gICAgICAgICAgICBuYW1lOiBkYXRhLndvcmRzLFxuICAgICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFdoYXQzV29yZHM7XG4gIH0oKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIFdoYXQzV29yZHN9XHJcbiAgICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICAgKi9cblxuICBmdW5jdGlvbiB3aGF0M3dvcmRzKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IFdoYXQzV29yZHMob3B0aW9ucyk7XG4gIH1cblxuICB2YXIgZ2VvY29kZXJzID0ge1xuICAgIF9fcHJvdG9fXzogbnVsbCxcbiAgICBnZW9jb2RpbmdQYXJhbXM6IGdlb2NvZGluZ1BhcmFtcyxcbiAgICByZXZlcnNlUGFyYW1zOiByZXZlcnNlUGFyYW1zLFxuICAgIEFyY0dpczogQXJjR2lzLFxuICAgIGFyY2dpczogYXJjZ2lzLFxuICAgIEJpbmc6IEJpbmcsXG4gICAgYmluZzogYmluZyxcbiAgICBHb29nbGU6IEdvb2dsZSxcbiAgICBnb29nbGU6IGdvb2dsZSxcbiAgICBIRVJFOiBIRVJFLFxuICAgIEhFUkV2MjogSEVSRXYyLFxuICAgIGhlcmU6IGhlcmUsXG4gICAgcGFyc2VMYXRMbmc6IHBhcnNlTGF0TG5nLFxuICAgIExhdExuZzogTGF0TG5nLFxuICAgIGxhdExuZzogbGF0TG5nLFxuICAgIE1hcGJveDogTWFwYm94LFxuICAgIG1hcGJveDogbWFwYm94LFxuICAgIE1hcFF1ZXN0OiBNYXBRdWVzdCxcbiAgICBtYXBRdWVzdDogbWFwUXVlc3QsXG4gICAgTmV1dHJpbm86IE5ldXRyaW5vLFxuICAgIG5ldXRyaW5vOiBuZXV0cmlubyxcbiAgICBOb21pbmF0aW06IE5vbWluYXRpbSxcbiAgICBub21pbmF0aW06IG5vbWluYXRpbSxcbiAgICBPcGVuTG9jYXRpb25Db2RlOiBPcGVuTG9jYXRpb25Db2RlLFxuICAgIG9wZW5Mb2NhdGlvbkNvZGU6IG9wZW5Mb2NhdGlvbkNvZGUsXG4gICAgT3BlbkNhZ2U6IE9wZW5DYWdlLFxuICAgIG9wZW5jYWdlOiBvcGVuY2FnZSxcbiAgICBQZWxpYXM6IFBlbGlhcyxcbiAgICBwZWxpYXM6IHBlbGlhcyxcbiAgICBHZW9jb2RlRWFydGg6IEdlb2NvZGVFYXJ0aCxcbiAgICBnZW9jb2RlRWFydGg6IGdlb2NvZGVFYXJ0aCxcbiAgICBNYXB6ZW46IE1hcHplbixcbiAgICBtYXB6ZW46IG1hcHplbixcbiAgICBPcGVucm91dGVzZXJ2aWNlOiBPcGVucm91dGVzZXJ2aWNlLFxuICAgIG9wZW5yb3V0ZXNlcnZpY2U6IG9wZW5yb3V0ZXNlcnZpY2UsXG4gICAgUGhvdG9uOiBQaG90b24sXG4gICAgcGhvdG9uOiBwaG90b24sXG4gICAgV2hhdDNXb3JkczogV2hhdDNXb3JkcyxcbiAgICB3aGF0M3dvcmRzOiB3aGF0M3dvcmRzXG4gIH07XG5cbiAgLyoqXHJcbiAgICogTGVhZmxldCBtaXhpbnMgaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS0xLjcuMS5odG1sI2NsYXNzLWluY2x1ZGVzXHJcbiAgICogZm9yIFR5cGVTY3JpcHQgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svbWl4aW5zLmh0bWxcclxuICAgKiBAaW50ZXJuYWxcclxuICAgKi9cblxuICB2YXIgRXZlbnRlZENvbnRyb2wgPSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gIGZ1bmN0aW9uIEV2ZW50ZWRDb250cm9sKCkgey8vIGVtcHR5XG4gIH07XG5cbiAgTF9fbmFtZXNwYWNlLlV0aWwuZXh0ZW5kKEV2ZW50ZWRDb250cm9sLnByb3RvdHlwZSwgTF9fbmFtZXNwYWNlLkNvbnRyb2wucHJvdG90eXBlKTtcbiAgTF9fbmFtZXNwYWNlLlV0aWwuZXh0ZW5kKEV2ZW50ZWRDb250cm9sLnByb3RvdHlwZSwgTF9fbmFtZXNwYWNlLkV2ZW50ZWQucHJvdG90eXBlKTtcbiAgLyoqXHJcbiAgICogVGhpcyBpcyB0aGUgZ2VvY29kZXIgY29udHJvbC4gSXQgd29ya3MgbGlrZSBhbnkgb3RoZXIgW0xlYWZsZXQgY29udHJvbF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NvbnRyb2wpLCBhbmQgaXMgYWRkZWQgdG8gdGhlIG1hcC5cclxuICAgKi9cblxuICB2YXIgR2VvY29kZXJDb250cm9sID0gLyojX19QVVJFX18qL2Z1bmN0aW9uIChfRXZlbnRlZENvbnRyb2wpIHtcbiAgICBfaW5oZXJpdHNMb29zZShHZW9jb2RlckNvbnRyb2wsIF9FdmVudGVkQ29udHJvbCk7XG5cbiAgICAvKipcclxuICAgICAqIEluc3RhbnRpYXRlcyBhIGdlb2NvZGVyIGNvbnRyb2wgKHRvIGJlIGludm9rZWQgdXNpbmcgYG5ld2ApXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAgICovXG4gICAgZnVuY3Rpb24gR2VvY29kZXJDb250cm9sKG9wdGlvbnMpIHtcbiAgICAgIHZhciBfdGhpcztcblxuICAgICAgX3RoaXMgPSBfRXZlbnRlZENvbnRyb2wuY2FsbCh0aGlzLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgX3RoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgc2hvd1VuaXF1ZVJlc3VsdDogdHJ1ZSxcbiAgICAgICAgc2hvd1Jlc3VsdEljb25zOiBmYWxzZSxcbiAgICAgICAgY29sbGFwc2VkOiB0cnVlLFxuICAgICAgICBleHBhbmQ6ICd0b3VjaCcsXG4gICAgICAgIHBvc2l0aW9uOiAndG9wcmlnaHQnLFxuICAgICAgICBwbGFjZWhvbGRlcjogJ1NlYXJjaC4uLicsXG4gICAgICAgIGVycm9yTWVzc2FnZTogJ05vdGhpbmcgZm91bmQuJyxcbiAgICAgICAgaWNvbkxhYmVsOiAnSW5pdGlhdGUgYSBuZXcgc2VhcmNoJyxcbiAgICAgICAgcXVlcnk6ICcnLFxuICAgICAgICBxdWVyeU1pbkxlbmd0aDogMSxcbiAgICAgICAgc3VnZ2VzdE1pbkxlbmd0aDogMyxcbiAgICAgICAgc3VnZ2VzdFRpbWVvdXQ6IDI1MCxcbiAgICAgICAgZGVmYXVsdE1hcmtHZW9jb2RlOiB0cnVlXG4gICAgICB9O1xuICAgICAgX3RoaXMuX3JlcXVlc3RDb3VudCA9IDA7XG4gICAgICBMX19uYW1lc3BhY2UuVXRpbC5zZXRPcHRpb25zKF9hc3NlcnRUaGlzSW5pdGlhbGl6ZWQoX3RoaXMpLCBvcHRpb25zKTtcblxuICAgICAgaWYgKCFfdGhpcy5vcHRpb25zLmdlb2NvZGVyKSB7XG4gICAgICAgIF90aGlzLm9wdGlvbnMuZ2VvY29kZXIgPSBuZXcgTm9taW5hdGltKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG5cbiAgICB2YXIgX3Byb3RvID0gR2VvY29kZXJDb250cm9sLnByb3RvdHlwZTtcblxuICAgIF9wcm90by5hZGRUaHJvYmJlckNsYXNzID0gZnVuY3Rpb24gYWRkVGhyb2JiZXJDbGFzcygpIHtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci10aHJvYmJlcicpO1xuICAgIH07XG5cbiAgICBfcHJvdG8ucmVtb3ZlVGhyb2JiZXJDbGFzcyA9IGZ1bmN0aW9uIHJlbW92ZVRocm9iYmVyQ2xhc3MoKSB7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItdGhyb2JiZXInKTtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBjb250YWluZXIgRE9NIGVsZW1lbnQgZm9yIHRoZSBjb250cm9sIGFuZCBhZGQgbGlzdGVuZXJzIG9uIHJlbGV2YW50IG1hcCBldmVudHMuXHJcbiAgICAgKiBAcGFyYW0gbWFwIHRoZSBtYXAgaW5zdGFuY2VcclxuICAgICAqIEBzZWUgaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NvbnRyb2wtb25hZGRcclxuICAgICAqL1xuICAgIDtcblxuICAgIF9wcm90by5vbkFkZCA9IGZ1bmN0aW9uIG9uQWRkKG1hcCkge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIHZhciBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyJztcbiAgICAgIHZhciBjb250YWluZXIgPSBMX19uYW1lc3BhY2UuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICcgbGVhZmxldC1iYXInKTtcbiAgICAgIHZhciBpY29uID0gTF9fbmFtZXNwYWNlLkRvbVV0aWwuY3JlYXRlKCdidXR0b24nLCBjbGFzc05hbWUgKyAnLWljb24nLCBjb250YWluZXIpO1xuICAgICAgdmFyIGZvcm0gPSB0aGlzLl9mb3JtID0gTF9fbmFtZXNwYWNlLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWZvcm0nLCBjb250YWluZXIpO1xuICAgICAgdGhpcy5fbWFwID0gbWFwO1xuICAgICAgdGhpcy5fY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgICAgaWNvbi5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgICAgIGljb24udHlwZSA9ICdidXR0b24nO1xuICAgICAgaWNvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aGlzLm9wdGlvbnMuaWNvbkxhYmVsKTtcbiAgICAgIHZhciBpbnB1dCA9IHRoaXMuX2lucHV0ID0gTF9fbmFtZXNwYWNlLkRvbVV0aWwuY3JlYXRlKCdpbnB1dCcsICcnLCBmb3JtKTtcbiAgICAgIGlucHV0LnR5cGUgPSAndGV4dCc7XG4gICAgICBpbnB1dC52YWx1ZSA9IHRoaXMub3B0aW9ucy5xdWVyeTtcbiAgICAgIGlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyO1xuICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50LmRpc2FibGVDbGlja1Byb3BhZ2F0aW9uKGlucHV0KTtcbiAgICAgIHRoaXMuX2Vycm9yRWxlbWVudCA9IExfX25hbWVzcGFjZS5Eb21VdGlsLmNyZWF0ZSgnZGl2JywgY2xhc3NOYW1lICsgJy1mb3JtLW5vLWVycm9yJywgY29udGFpbmVyKTtcbiAgICAgIHRoaXMuX2Vycm9yRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLm9wdGlvbnMuZXJyb3JNZXNzYWdlO1xuICAgICAgdGhpcy5fYWx0cyA9IExfX25hbWVzcGFjZS5Eb21VdGlsLmNyZWF0ZSgndWwnLCBjbGFzc05hbWUgKyAnLWFsdGVybmF0aXZlcyBsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWx0ZXJuYXRpdmVzLW1pbmltaXplZCcsIGNvbnRhaW5lcik7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fYWx0cyk7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuYWRkTGlzdGVuZXIoaW5wdXQsICdrZXlkb3duJywgdGhpcy5fa2V5ZG93biwgdGhpcyk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZ2VvY29kZXIuc3VnZ2VzdCkge1xuICAgICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuYWRkTGlzdGVuZXIoaW5wdXQsICdpbnB1dCcsIHRoaXMuX2NoYW5nZSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIExfX25hbWVzcGFjZS5Eb21FdmVudC5hZGRMaXN0ZW5lcihpbnB1dCwgJ2JsdXInLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChfdGhpczIub3B0aW9ucy5jb2xsYXBzZWQgJiYgIV90aGlzMi5fcHJldmVudEJsdXJDb2xsYXBzZSkge1xuICAgICAgICAgIF90aGlzMi5fY29sbGFwc2UoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIF90aGlzMi5fcHJldmVudEJsdXJDb2xsYXBzZSA9IGZhbHNlO1xuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZXhwYW5kID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2NsaWNrJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIGlmIChlLmJ1dHRvbiA9PT0gMCAmJiBlLmRldGFpbCAhPT0gMikge1xuICAgICAgICAgICAgICBfdGhpczIuX3RvZ2dsZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMub3B0aW9ucy5leHBhbmQgPT09ICd0b3VjaCcpIHtcbiAgICAgICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCBMX19uYW1lc3BhY2UuQnJvd3Nlci50b3VjaCA/ICd0b3VjaHN0YXJ0IG1vdXNlZG93bicgOiAnbW91c2Vkb3duJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIF90aGlzMi5fdG9nZ2xlKCk7XG5cbiAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTsgLy8gbW9iaWxlOiBjbGlja2luZyBmb2N1c2VzIHRoZSBpY29uLCBzbyBVSSBleHBhbmRzIGFuZCBpbW1lZGlhdGVseSBjb2xsYXBzZXNcblxuICAgICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnbW91c2VvdmVyJywgdGhpcy5fZXhwYW5kLCB0aGlzKTtcbiAgICAgICAgICBMX19uYW1lc3BhY2UuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9jb2xsYXBzZSwgdGhpcyk7XG5cbiAgICAgICAgICB0aGlzLl9tYXAub24oJ21vdmVzdGFydCcsIHRoaXMuX2NvbGxhcHNlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fZXhwYW5kKCk7XG5cbiAgICAgICAgaWYgKExfX25hbWVzcGFjZS5Ccm93c2VyLnRvdWNoKSB7XG4gICAgICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ3RvdWNoc3RhcnQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gX3RoaXMyLl9nZW9jb2RlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzMi5fZ2VvY29kZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGVmYXVsdE1hcmtHZW9jb2RlKSB7XG4gICAgICAgIHRoaXMub24oJ21hcmtnZW9jb2RlJywgdGhpcy5tYXJrR2VvY29kZSwgdGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMub24oJ3N0YXJ0Z2VvY29kZScsIHRoaXMuYWRkVGhyb2JiZXJDbGFzcywgdGhpcyk7XG4gICAgICB0aGlzLm9uKCdmaW5pc2hnZW9jb2RlJywgdGhpcy5yZW1vdmVUaHJvYmJlckNsYXNzLCB0aGlzKTtcbiAgICAgIHRoaXMub24oJ3N0YXJ0c3VnZ2VzdCcsIHRoaXMuYWRkVGhyb2JiZXJDbGFzcywgdGhpcyk7XG4gICAgICB0aGlzLm9uKCdmaW5pc2hzdWdnZXN0JywgdGhpcy5yZW1vdmVUaHJvYmJlckNsYXNzLCB0aGlzKTtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xuICAgICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIHRoZSBxdWVyeSBzdHJpbmcgb24gdGhlIHRleHQgaW5wdXRcclxuICAgICAqIEBwYXJhbSBzdHJpbmcgdGhlIHF1ZXJ5IHN0cmluZ1xyXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLnNldFF1ZXJ5ID0gZnVuY3Rpb24gc2V0UXVlcnkoc3RyaW5nKSB7XG4gICAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHN0cmluZztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2dlb2NvZGVSZXN1bHQgPSBmdW5jdGlvbiBfZ2VvY29kZVJlc3VsdChyZXN1bHRzLCBzdWdnZXN0KSB7XG4gICAgICBpZiAoIXN1Z2dlc3QgJiYgdGhpcy5vcHRpb25zLnNob3dVbmlxdWVSZXN1bHQgJiYgcmVzdWx0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgdGhpcy5fZ2VvY29kZVJlc3VsdFNlbGVjdGVkKHJlc3VsdHNbMF0pO1xuICAgICAgfSBlbHNlIGlmIChyZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdGhpcy5fYWx0cy5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdGhpcy5fcmVzdWx0cyA9IHJlc3VsdHM7XG4gICAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2FsdHMsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWx0ZXJuYXRpdmVzLW1pbmltaXplZCcpO1xuICAgICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItb3B0aW9ucy1vcGVuJyk7XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgdGhpcy5fYWx0cy5hcHBlbmRDaGlsZCh0aGlzLl9jcmVhdGVBbHQocmVzdWx0c1tpXSwgaSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItb3B0aW9ucy1lcnJvcicpO1xuICAgICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9lcnJvckVsZW1lbnQsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItZXJyb3InKTtcbiAgICAgIH1cbiAgICB9XG4gICAgLyoqXHJcbiAgICAgKiBNYXJrcyBhIGdlb2NvZGluZyByZXN1bHQgb24gdGhlIG1hcFxyXG4gICAgICogQHBhcmFtIHJlc3VsdCB0aGUgZ2VvY29kaW5nIHJlc3VsdFxyXG4gICAgICovXG4gICAgO1xuXG4gICAgX3Byb3RvLm1hcmtHZW9jb2RlID0gZnVuY3Rpb24gbWFya0dlb2NvZGUoZXZlbnQpIHtcbiAgICAgIHZhciByZXN1bHQgPSBldmVudC5nZW9jb2RlO1xuXG4gICAgICB0aGlzLl9tYXAuZml0Qm91bmRzKHJlc3VsdC5iYm94KTtcblxuICAgICAgaWYgKHRoaXMuX2dlb2NvZGVNYXJrZXIpIHtcbiAgICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2dlb2NvZGVNYXJrZXIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9nZW9jb2RlTWFya2VyID0gbmV3IExfX25hbWVzcGFjZS5NYXJrZXIocmVzdWx0LmNlbnRlcikuYmluZFBvcHVwKHJlc3VsdC5odG1sIHx8IHJlc3VsdC5uYW1lKS5hZGRUbyh0aGlzLl9tYXApLm9wZW5Qb3B1cCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2VvY29kZSA9IGZ1bmN0aW9uIF9nZW9jb2RlKHN1Z2dlc3QpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9pbnB1dC52YWx1ZTtcblxuICAgICAgaWYgKCFzdWdnZXN0ICYmIHZhbHVlLmxlbmd0aCA8IHRoaXMub3B0aW9ucy5xdWVyeU1pbkxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciByZXF1ZXN0Q291bnQgPSArK3RoaXMuX3JlcXVlc3RDb3VudDtcblxuICAgICAgdmFyIGNiID0gZnVuY3Rpb24gY2IocmVzdWx0cykge1xuICAgICAgICBpZiAocmVxdWVzdENvdW50ID09PSBfdGhpczMuX3JlcXVlc3RDb3VudCkge1xuICAgICAgICAgIHZhciBfZXZlbnQgPSB7XG4gICAgICAgICAgICBpbnB1dDogdmFsdWUsXG4gICAgICAgICAgICByZXN1bHRzOiByZXN1bHRzXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIF90aGlzMy5maXJlKHN1Z2dlc3QgPyAnZmluaXNoc3VnZ2VzdCcgOiAnZmluaXNoZ2VvY29kZScsIF9ldmVudCk7XG5cbiAgICAgICAgICBfdGhpczMuX2dlb2NvZGVSZXN1bHQocmVzdWx0cywgc3VnZ2VzdCk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHRoaXMuX2xhc3RHZW9jb2RlID0gdmFsdWU7XG5cbiAgICAgIGlmICghc3VnZ2VzdCkge1xuICAgICAgICB0aGlzLl9jbGVhclJlc3VsdHMoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIGV2ZW50ID0ge1xuICAgICAgICBpbnB1dDogdmFsdWVcbiAgICAgIH07XG4gICAgICB0aGlzLmZpcmUoc3VnZ2VzdCA/ICdzdGFydHN1Z2dlc3QnIDogJ3N0YXJ0Z2VvY29kZScsIGV2ZW50KTtcblxuICAgICAgaWYgKHN1Z2dlc3QpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLmdlb2NvZGVyLnN1Z2dlc3QodmFsdWUsIGNiKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5nZW9jb2Rlci5nZW9jb2RlKHZhbHVlLCBjYik7XG4gICAgICB9XG4gICAgfTtcblxuICAgIF9wcm90by5fZ2VvY29kZVJlc3VsdFNlbGVjdGVkID0gZnVuY3Rpb24gX2dlb2NvZGVSZXN1bHRTZWxlY3RlZChnZW9jb2RlKSB7XG4gICAgICB2YXIgZXZlbnQgPSB7XG4gICAgICAgIGdlb2NvZGU6IGdlb2NvZGVcbiAgICAgIH07XG4gICAgICB0aGlzLmZpcmUoJ21hcmtnZW9jb2RlJywgZXZlbnQpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX3RvZ2dsZSA9IGZ1bmN0aW9uIF90b2dnbGUoKSB7XG4gICAgICBpZiAoTF9fbmFtZXNwYWNlLkRvbVV0aWwuaGFzQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLWV4cGFuZGVkJykpIHtcbiAgICAgICAgdGhpcy5fY29sbGFwc2UoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2V4cGFuZCgpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICBfcHJvdG8uX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQoKSB7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItZXhwYW5kZWQnKTtcblxuICAgICAgdGhpcy5faW5wdXQuc2VsZWN0KCk7XG5cbiAgICAgIHRoaXMuZmlyZSgnZXhwYW5kJyk7XG4gICAgfTtcblxuICAgIF9wcm90by5fY29sbGFwc2UgPSBmdW5jdGlvbiBfY29sbGFwc2UoKSB7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItZXhwYW5kZWQnKTtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2FsdHMsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWx0ZXJuYXRpdmVzLW1pbmltaXplZCcpO1xuICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fZXJyb3JFbGVtZW50LCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLWVycm9yJyk7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItb3B0aW9ucy1vcGVuJyk7XG4gICAgICBMX19uYW1lc3BhY2UuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItb3B0aW9ucy1lcnJvcicpO1xuXG4gICAgICB0aGlzLl9pbnB1dC5ibHVyKCk7IC8vIG1vYmlsZToga2V5Ym9hcmQgc2hvdWxkbid0IHN0YXkgZXhwYW5kZWRcblxuXG4gICAgICB0aGlzLmZpcmUoJ2NvbGxhcHNlJyk7XG4gICAgfTtcblxuICAgIF9wcm90by5fY2xlYXJSZXN1bHRzID0gZnVuY3Rpb24gX2NsZWFyUmVzdWx0cygpIHtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2FsdHMsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWx0ZXJuYXRpdmVzLW1pbmltaXplZCcpO1xuICAgICAgdGhpcy5fc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2Vycm9yRWxlbWVudCwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1lcnJvcicpO1xuICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLW9wdGlvbnMtb3BlbicpO1xuICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLW9wdGlvbnMtZXJyb3InKTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9jcmVhdGVBbHQgPSBmdW5jdGlvbiBfY3JlYXRlQWx0KHJlc3VsdCwgaW5kZXgpIHtcbiAgICAgIHZhciBfdGhpczQgPSB0aGlzO1xuXG4gICAgICB2YXIgbGkgPSBMX19uYW1lc3BhY2UuRG9tVXRpbC5jcmVhdGUoJ2xpJywgJycpLFxuICAgICAgICAgIGEgPSBMX19uYW1lc3BhY2UuRG9tVXRpbC5jcmVhdGUoJ2EnLCAnJywgbGkpLFxuICAgICAgICAgIGljb24gPSB0aGlzLm9wdGlvbnMuc2hvd1Jlc3VsdEljb25zICYmIHJlc3VsdC5pY29uID8gTF9fbmFtZXNwYWNlLkRvbVV0aWwuY3JlYXRlKCdpbWcnLCAnJywgYSkgOiBudWxsLFxuICAgICAgICAgIHRleHQgPSByZXN1bHQuaHRtbCA/IHVuZGVmaW5lZCA6IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHJlc3VsdC5uYW1lKSxcbiAgICAgICAgICBtb3VzZURvd25IYW5kbGVyID0gZnVuY3Rpb24gbW91c2VEb3duSGFuZGxlcihlKSB7XG4gICAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIGEgY2xpY2sgd2lsbCBmaXJlIG9uIHRoZSBtYXAgaWYgdGhlIGNvbnRyb2wgaXNcbiAgICAgICAgLy8gY29sbGFwc2VkIGRpcmVjdGx5IGFmdGVyIG1vdXNlZG93bi4gVG8gd29yayBhcm91bmQgdGhpcywgd2VcbiAgICAgICAgLy8gd2FpdCB1bnRpbCB0aGUgY2xpY2sgaXMgY29tcGxldGVkLCBhbmQgX3RoZW5fIGNvbGxhcHNlIHRoZVxuICAgICAgICAvLyBjb250cm9sLiBNZXNzeSwgYnV0IHRoaXMgaXMgdGhlIHdvcmthcm91bmQgSSBjb3VsZCBjb21lIHVwIHdpdGhcbiAgICAgICAgLy8gZm9yICMxNDIuXG4gICAgICAgIF90aGlzNC5fcHJldmVudEJsdXJDb2xsYXBzZSA9IHRydWU7XG4gICAgICAgIExfX25hbWVzcGFjZS5Eb21FdmVudC5zdG9wKGUpO1xuXG4gICAgICAgIF90aGlzNC5fZ2VvY29kZVJlc3VsdFNlbGVjdGVkKHJlc3VsdCk7XG5cbiAgICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50Lm9uKGxpLCAnY2xpY2sgdG91Y2hlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzNC5vcHRpb25zLmNvbGxhcHNlZCkge1xuICAgICAgICAgICAgX3RoaXM0Ll9jb2xsYXBzZSgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfdGhpczQuX2NsZWFyUmVzdWx0cygpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAoaWNvbikge1xuICAgICAgICBpY29uLnNyYyA9IHJlc3VsdC5pY29uO1xuICAgICAgfVxuXG4gICAgICBsaS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcmVzdWx0LWluZGV4JywgU3RyaW5nKGluZGV4KSk7XG5cbiAgICAgIGlmIChyZXN1bHQuaHRtbCkge1xuICAgICAgICBhLmlubmVySFRNTCA9IGEuaW5uZXJIVE1MICsgcmVzdWx0Lmh0bWw7XG4gICAgICB9IGVsc2UgaWYgKHRleHQpIHtcbiAgICAgICAgYS5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICAgIH0gLy8gVXNlIG1vdXNlZG93biBhbmQgbm90IGNsaWNrLCBzaW5jZSBjbGljayB3aWxsIGZpcmUgX2FmdGVyXyBibHVyLFxuICAgICAgLy8gY2F1c2luZyB0aGUgY29udHJvbCB0byBoYXZlIGNvbGxhcHNlZCBhbmQgcmVtb3ZlZCB0aGUgaXRlbXNcbiAgICAgIC8vIGJlZm9yZSB0aGUgY2xpY2sgY2FuIGZpcmUuXG5cblxuICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50LmFkZExpc3RlbmVyKGxpLCAnbW91c2Vkb3duIHRvdWNoc3RhcnQnLCBtb3VzZURvd25IYW5kbGVyLCB0aGlzKTtcbiAgICAgIHJldHVybiBsaTtcbiAgICB9O1xuXG4gICAgX3Byb3RvLl9rZXlkb3duID0gZnVuY3Rpb24gX2tleWRvd24oZSkge1xuICAgICAgdmFyIF90aGlzNSA9IHRoaXM7XG5cbiAgICAgIHZhciBzZWxlY3QgPSBmdW5jdGlvbiBzZWxlY3QoZGlyKSB7XG4gICAgICAgIGlmIChfdGhpczUuX3NlbGVjdGlvbikge1xuICAgICAgICAgIExfX25hbWVzcGFjZS5Eb21VdGlsLnJlbW92ZUNsYXNzKF90aGlzNS5fc2VsZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLXNlbGVjdGVkJyk7XG4gICAgICAgICAgX3RoaXM1Ll9zZWxlY3Rpb24gPSBfdGhpczUuX3NlbGVjdGlvbltkaXIgPiAwID8gJ25leHRTaWJsaW5nJyA6ICdwcmV2aW91c1NpYmxpbmcnXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghX3RoaXM1Ll9zZWxlY3Rpb24pIHtcbiAgICAgICAgICBfdGhpczUuX3NlbGVjdGlvbiA9IF90aGlzNS5fYWx0c1tkaXIgPiAwID8gJ2ZpcnN0Q2hpbGQnIDogJ2xhc3RDaGlsZCddO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKF90aGlzNS5fc2VsZWN0aW9uKSB7XG4gICAgICAgICAgTF9fbmFtZXNwYWNlLkRvbVV0aWwuYWRkQ2xhc3MoX3RoaXM1Ll9zZWxlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItc2VsZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgICAgLy8gRXNjYXBlXG4gICAgICAgIGNhc2UgMjc6XG4gICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbGxhcHNlKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2NsZWFyUmVzdWx0cygpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICAvLyBVcFxuXG4gICAgICAgIGNhc2UgMzg6XG4gICAgICAgICAgc2VsZWN0KC0xKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gVXBcblxuICAgICAgICBjYXNlIDQwOlxuICAgICAgICAgIHNlbGVjdCgxKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gRW50ZXJcblxuICAgICAgICBjYXNlIDEzOlxuICAgICAgICAgIGlmICh0aGlzLl9zZWxlY3Rpb24pIHtcbiAgICAgICAgICAgIHZhciBpbmRleCA9IHBhcnNlSW50KHRoaXMuX3NlbGVjdGlvbi5nZXRBdHRyaWJ1dGUoJ2RhdGEtcmVzdWx0LWluZGV4JyksIDEwKTtcblxuICAgICAgICAgICAgdGhpcy5fZ2VvY29kZVJlc3VsdFNlbGVjdGVkKHRoaXMuX3Jlc3VsdHNbaW5kZXhdKTtcblxuICAgICAgICAgICAgdGhpcy5fY2xlYXJSZXN1bHRzKCk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2dlb2NvZGUoKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgTF9fbmFtZXNwYWNlLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICAgIH07XG5cbiAgICBfcHJvdG8uX2NoYW5nZSA9IGZ1bmN0aW9uIF9jaGFuZ2UoKSB7XG4gICAgICB2YXIgX3RoaXM2ID0gdGhpcztcblxuICAgICAgdmFyIHYgPSB0aGlzLl9pbnB1dC52YWx1ZTtcblxuICAgICAgaWYgKHYgIT09IHRoaXMuX2xhc3RHZW9jb2RlKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdWdnZXN0VGltZW91dCk7XG5cbiAgICAgICAgaWYgKHYubGVuZ3RoID49IHRoaXMub3B0aW9ucy5zdWdnZXN0TWluTGVuZ3RoKSB7XG4gICAgICAgICAgdGhpcy5fc3VnZ2VzdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpczYuX2dlb2NvZGUodHJ1ZSk7XG4gICAgICAgICAgfSwgdGhpcy5vcHRpb25zLnN1Z2dlc3RUaW1lb3V0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9jbGVhclJlc3VsdHMoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG5cbiAgICByZXR1cm4gR2VvY29kZXJDb250cm9sO1xuICB9KEV2ZW50ZWRDb250cm9sKTtcbiAgLyoqXHJcbiAgICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIEdlb2NvZGVyQ29udHJvbH1cclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuXG4gIGZ1bmN0aW9uIGdlb2NvZGVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4gbmV3IEdlb2NvZGVyQ29udHJvbChvcHRpb25zKTtcbiAgfVxuXG4gIC8qIEBwcmVzZXJ2ZVxyXG4gICAqIExlYWZsZXQgQ29udHJvbCBHZW9jb2RlclxyXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS9wZXJsaWVkbWFuL2xlYWZsZXQtY29udHJvbC1nZW9jb2RlclxyXG4gICAqXHJcbiAgICogQ29weXJpZ2h0IChjKSAyMDEyIHNhM20gKGh0dHBzOi8vZ2l0aHViLmNvbS9zYTNtKVxyXG4gICAqIENvcHlyaWdodCAoYykgMjAxOCBQZXIgTGllZG1hblxyXG4gICAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAgICovXG4gIExfX25hbWVzcGFjZS5VdGlsLmV4dGVuZChHZW9jb2RlckNvbnRyb2wsIGdlb2NvZGVycyk7XG4gIExfX25hbWVzcGFjZS5VdGlsLmV4dGVuZChMX19uYW1lc3BhY2UuQ29udHJvbCwge1xuICAgIEdlb2NvZGVyOiBHZW9jb2RlckNvbnRyb2wsXG4gICAgZ2VvY29kZXI6IGdlb2NvZGVyXG4gIH0pO1xuXG4gIGV4cG9ydHMuR2VvY29kZXIgPSBHZW9jb2RlckNvbnRyb2w7XG4gIGV4cG9ydHMuZGVmYXVsdCA9IEdlb2NvZGVyQ29udHJvbDtcbiAgZXhwb3J0cy5nZW9jb2RlciA9IGdlb2NvZGVyO1xuICBleHBvcnRzLmdlb2NvZGVycyA9IGdlb2NvZGVycztcblxuICByZXR1cm4gZXhwb3J0cztcblxufSh7fSwgTCkpO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udHJvbC5HZW9jb2Rlci5qcy5tYXBcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.modern.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.modern.js ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Geocoder: () => (/* binding */ GeocoderControl),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   geocoder: () => (/* binding */ geocoder),\n/* harmony export */   geocoders: () => (/* binding */ geocoders)\n/* harmony export */ });\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! leaflet */ \"(ssr)/./node_modules/leaflet/dist/leaflet-src.js\");\n/* harmony import */ var leaflet__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(leaflet__WEBPACK_IMPORTED_MODULE_0__);\n\n\n/**\r\n * @internal\r\n */\n\nfunction geocodingParams(options, params) {\n  return leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(params, options.geocodingQueryParams);\n}\n/**\r\n * @internal\r\n */\n\nfunction reverseParams(options, params) {\n  return leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(params, options.reverseQueryParams);\n}\n\n/**\r\n * @internal\r\n */\n\nlet lastCallbackId = 0; // Adapted from handlebars.js\n// https://github.com/wycats/handlebars.js/\n\n/**\r\n * @internal\r\n */\n\nconst badChars = /[&<>\"'`]/g;\n/**\r\n * @internal\r\n */\n\nconst possible = /[&<>\"'`]/;\n/**\r\n * @internal\r\n */\n\nconst escape = {\n  '&': '&amp;',\n  '<': '&lt;',\n  '>': '&gt;',\n  '\"': '&quot;',\n  \"'\": '&#x27;',\n  '`': '&#x60;'\n};\n/**\r\n * @internal\r\n */\n\nfunction escapeChar(chr) {\n  return escape[chr];\n}\n/**\r\n * @internal\r\n */\n\n\nfunction htmlEscape(string) {\n  if (string == null) {\n    return '';\n  } else if (!string) {\n    return string + '';\n  } // Force a string conversion as this will be done by the append regardless and\n  // the regex test will do this transparently behind the scenes, causing issues if\n  // an object's to string has escaped characters in it.\n\n\n  string = '' + string;\n\n  if (!possible.test(string)) {\n    return string;\n  }\n\n  return string.replace(badChars, escapeChar);\n}\n/**\r\n * @internal\r\n */\n\nfunction jsonp(url, params, callback, context, jsonpParam) {\n  const callbackId = '_l_geocoder_' + lastCallbackId++;\n  params[jsonpParam || 'callback'] = callbackId;\n  window[callbackId] = leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(callback, context);\n  const script = document.createElement('script');\n  script.type = 'text/javascript';\n  script.src = url + getParamString(params);\n  script.id = callbackId;\n  document.getElementsByTagName('head')[0].appendChild(script);\n}\n/**\r\n * @internal\r\n */\n\nfunction getJSON(url, params, callback) {\n  const xmlHttp = new XMLHttpRequest();\n\n  xmlHttp.onreadystatechange = function () {\n    if (xmlHttp.readyState !== 4) {\n      return;\n    }\n\n    let message;\n\n    if (xmlHttp.status !== 200 && xmlHttp.status !== 304) {\n      message = '';\n    } else if (typeof xmlHttp.response === 'string') {\n      // IE doesn't parse JSON responses even with responseType: 'json'.\n      try {\n        message = JSON.parse(xmlHttp.response);\n      } catch (e) {\n        // Not a JSON response\n        message = xmlHttp.response;\n      }\n    } else {\n      message = xmlHttp.response;\n    }\n\n    callback(message);\n  };\n\n  xmlHttp.open('GET', url + getParamString(params), true);\n  xmlHttp.responseType = 'json';\n  xmlHttp.setRequestHeader('Accept', 'application/json');\n  xmlHttp.send(null);\n}\n/**\r\n * @internal\r\n */\n\nfunction template(str, data) {\n  return str.replace(/\\{ *([\\w_]+) *\\}/g, (str, key) => {\n    let value = data[key];\n\n    if (value === undefined) {\n      value = '';\n    } else if (typeof value === 'function') {\n      value = value(data);\n    }\n\n    return htmlEscape(value);\n  });\n}\n/**\r\n * @internal\r\n */\n\nfunction getParamString(obj, existingUrl, uppercase) {\n  const params = [];\n\n  for (const i in obj) {\n    const key = encodeURIComponent(uppercase ? i.toUpperCase() : i);\n    const value = obj[i];\n\n    if (!Array.isArray(value)) {\n      params.push(key + '=' + encodeURIComponent(String(value)));\n    } else {\n      for (let j = 0; j < value.length; j++) {\n        params.push(key + '=' + encodeURIComponent(value[j]));\n      }\n    }\n  }\n\n  return (!existingUrl || existingUrl.indexOf('?') === -1 ? '?' : '&') + params.join('&');\n}\n\n/**\r\n * Implementation of the [ArcGIS geocoder](https://developers.arcgis.com/features/geocoding/)\r\n */\n\nclass ArcGis {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://geocode.arcgis.com/arcgis/rest/services/World/GeocodeServer',\n      apiKey: ''\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      token: this.options.apiKey,\n      SingleLine: query,\n      outFields: 'Addr_Type',\n      forStorage: false,\n      maxLocations: 10,\n      f: 'json'\n    });\n    getJSON(this.options.serviceUrl + '/findAddressCandidates', params, data => {\n      const results = [];\n\n      if (data.candidates && data.candidates.length) {\n        for (let i = 0; i <= data.candidates.length - 1; i++) {\n          const loc = data.candidates[i];\n          const latLng = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.location.y, loc.location.x);\n          const latLngBounds = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.extent.ymax, loc.extent.xmax), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.extent.ymin, loc.extent.xmin));\n          results[i] = {\n            name: loc.address,\n            bbox: latLngBounds,\n            center: latLng\n          };\n        }\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n  suggest(query, cb, context) {\n    return this.geocode(query, cb, context);\n  }\n\n  reverse(location, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      location: location.lng + ',' + location.lat,\n      distance: 100,\n      f: 'json'\n    });\n    getJSON(this.options.serviceUrl + '/reverseGeocode', params, data => {\n      const result = [];\n\n      if (data && !data.error) {\n        const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(data.location.y, data.location.x);\n        const bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n        result.push({\n          name: data.address.Match_addr,\n          center: center,\n          bbox: bbox\n        });\n      }\n\n      cb.call(context, result);\n    });\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link ArcGis}\r\n * @param options the options\r\n */\n\nfunction arcgis(options) {\n  return new ArcGis(options);\n}\n\n/**\r\n * Implementation of the [Bing Locations API](https://docs.microsoft.com/en-us/bingmaps/rest-services/locations/)\r\n */\n\nclass Bing {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://dev.virtualearth.net/REST/v1/Locations'\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      query: query,\n      key: this.options.apiKey\n    });\n    jsonp(this.options.apiKey, params, data => {\n      const results = [];\n\n      if (data.resourceSets.length > 0) {\n        for (let i = data.resourceSets[0].resources.length - 1; i >= 0; i--) {\n          const resource = data.resourceSets[0].resources[i],\n                bbox = resource.bbox;\n          results[i] = {\n            name: resource.name,\n            bbox: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]),\n            center: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(resource.point.coordinates)\n          };\n        }\n      }\n\n      cb.call(context, results);\n    }, this, 'jsonp');\n  }\n\n  reverse(location, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      key: this.options.apiKey\n    });\n    jsonp(this.options.serviceUrl + location.lat + ',' + location.lng, params, data => {\n      const results = [];\n\n      for (let i = data.resourceSets[0].resources.length - 1; i >= 0; i--) {\n        const resource = data.resourceSets[0].resources[i],\n              bbox = resource.bbox;\n        results[i] = {\n          name: resource.name,\n          bbox: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds([bbox[0], bbox[1]], [bbox[2], bbox[3]]),\n          center: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(resource.point.coordinates)\n        };\n      }\n\n      cb.call(context, results);\n    }, this, 'jsonp');\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Bing}\r\n * @param options the options\r\n */\n\nfunction bing(options) {\n  return new Bing(options);\n}\n\nclass Google {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://maps.googleapis.com/maps/api/geocode/json'\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      key: this.options.apiKey,\n      address: query\n    });\n    getJSON(this.options.serviceUrl, params, data => {\n      const results = [];\n\n      if (data.results && data.results.length) {\n        for (let i = 0; i <= data.results.length - 1; i++) {\n          const loc = data.results[i];\n          const latLng = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.geometry.location);\n          const latLngBounds = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.geometry.viewport.northeast), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.geometry.viewport.southwest));\n          results[i] = {\n            name: loc.formatted_address,\n            bbox: latLngBounds,\n            center: latLng,\n            properties: loc.address_components\n          };\n        }\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n  reverse(location, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      key: this.options.apiKey,\n      latlng: location.lat + ',' + location.lng\n    });\n    getJSON(this.options.serviceUrl, params, data => {\n      const results = [];\n\n      if (data.results && data.results.length) {\n        for (let i = 0; i <= data.results.length - 1; i++) {\n          const loc = data.results[i];\n          const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.geometry.location);\n          const bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.geometry.viewport.northeast), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.geometry.viewport.southwest));\n          results[i] = {\n            name: loc.formatted_address,\n            bbox: bbox,\n            center: center,\n            properties: loc.address_components\n          };\n        }\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Google}\r\n * @param options the options\r\n */\n\nfunction google(options) {\n  return new Google(options);\n}\n\n/**\r\n * Implementation of the [HERE Geocoder API](https://developer.here.com/documentation/geocoder/topics/introduction.html)\r\n */\n\nclass HERE {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://geocoder.api.here.com/6.2/',\n      app_id: '',\n      app_code: '',\n      apiKey: '',\n      maxResults: 5\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n    if (options.apiKey) throw Error('apiKey is not supported, use app_id/app_code instead!');\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      searchtext: query,\n      gen: 9,\n      app_id: this.options.app_id,\n      app_code: this.options.app_code,\n      jsonattributes: 1,\n      maxresults: this.options.maxResults\n    });\n    this.getJSON(this.options.serviceUrl + 'geocode.json', params, cb, context);\n  }\n\n  reverse(location, scale, cb, context) {\n    let prox = location.lat + ',' + location.lng;\n\n    if (this.options.reverseGeocodeProxRadius) {\n      prox += ',' + this.options.reverseGeocodeProxRadius;\n    }\n\n    const params = reverseParams(this.options, {\n      prox,\n      mode: 'retrieveAddresses',\n      app_id: this.options.app_id,\n      app_code: this.options.app_code,\n      gen: 9,\n      jsonattributes: 1,\n      maxresults: this.options.maxResults\n    });\n    this.getJSON(this.options.serviceUrl + 'reversegeocode.json', params, cb, context);\n  }\n\n  getJSON(url, params, cb, context) {\n    getJSON(url, params, data => {\n      const results = [];\n\n      if (data.response.view && data.response.view.length) {\n        for (let i = 0; i <= data.response.view[0].result.length - 1; i++) {\n          const loc = data.response.view[0].result[i].location;\n          const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.displayPosition.latitude, loc.displayPosition.longitude);\n          const bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.mapView.topLeft.latitude, loc.mapView.topLeft.longitude), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.mapView.bottomRight.latitude, loc.mapView.bottomRight.longitude));\n          results[i] = {\n            name: loc.address.label,\n            properties: loc.address,\n            bbox: bbox,\n            center: center\n          };\n        }\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n}\n/**\r\n * Implementation of the new [HERE Geocoder API](https://developer.here.com/documentation/geocoding-search-api/api-reference-swagger.html)\r\n */\n\nclass HEREv2 {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://geocode.search.hereapi.com/v1',\n      apiKey: '',\n      app_id: '',\n      app_code: '',\n      maxResults: 10\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      q: query,\n      apiKey: this.options.apiKey,\n      limit: this.options.maxResults\n    });\n\n    if (!params.at && !params.in) {\n      throw Error('at / in parameters not found. Please define coordinates (at=latitude,longitude) or other (in) in your geocodingQueryParams.');\n    }\n\n    this.getJSON(this.options.serviceUrl + '/discover', params, cb, context);\n  }\n\n  reverse(location, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      at: location.lat + ',' + location.lng,\n      limit: this.options.reverseGeocodeProxRadius,\n      apiKey: this.options.apiKey\n    });\n    this.getJSON(this.options.serviceUrl + '/revgeocode', params, cb, context);\n  }\n\n  getJSON(url, params, cb, context) {\n    getJSON(url, params, data => {\n      const results = [];\n\n      if (data.items && data.items.length) {\n        for (let i = 0; i <= data.items.length - 1; i++) {\n          const item = data.items[i];\n          const latLng = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(item.position.lat, item.position.lng);\n          let bbox;\n\n          if (item.mapView) {\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(item.mapView.south, item.mapView.west), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(item.mapView.north, item.mapView.east));\n          } else {\n            // Using only position when not provided\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(item.position.lat, item.position.lng), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(item.position.lat, item.position.lng));\n          }\n\n          results[i] = {\n            name: item.address.label,\n            properties: item.address,\n            bbox: bbox,\n            center: latLng\n          };\n        }\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link HERE}\r\n * @param options the options\r\n */\n\nfunction here(options) {\n  if (options.apiKey) {\n    return new HEREv2(options);\n  } else {\n    return new HERE(options);\n  }\n}\n\n/**\r\n * Parses basic latitude/longitude strings such as `'50.06773 14.37742'`, `'N50.06773 W14.37742'`, `'S 50° 04.064 E 014° 22.645'`, or `'S 50° 4′ 03.828″, W 14° 22′ 38.712″'`\r\n * @param query the latitude/longitude string to parse\r\n * @returns the parsed latitude/longitude\r\n */\n\nfunction parseLatLng(query) {\n  let match; // regex from https://github.com/openstreetmap/openstreetmap-website/blob/master/app/controllers/geocoder_controller.rb\n\n  if (match = query.match(/^([NS])\\s*(\\d{1,3}(?:\\.\\d*)?)\\W*([EW])\\s*(\\d{1,3}(?:\\.\\d*)?)$/)) {\n    // [NSEW] decimal degrees\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng((/N/i.test(match[1]) ? 1 : -1) * +match[2], (/E/i.test(match[3]) ? 1 : -1) * +match[4]);\n  } else if (match = query.match(/^(\\d{1,3}(?:\\.\\d*)?)\\s*([NS])\\W*(\\d{1,3}(?:\\.\\d*)?)\\s*([EW])$/)) {\n    // decimal degrees [NSEW]\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng((/N/i.test(match[2]) ? 1 : -1) * +match[1], (/E/i.test(match[4]) ? 1 : -1) * +match[3]);\n  } else if (match = query.match(/^([NS])\\s*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\W*([EW])\\s*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?$/)) {\n    // [NSEW] degrees, decimal minutes\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng((/N/i.test(match[1]) ? 1 : -1) * (+match[2] + +match[3] / 60), (/E/i.test(match[4]) ? 1 : -1) * (+match[5] + +match[6] / 60));\n  } else if (match = query.match(/^(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\s*([NS])\\W*(\\d{1,3})°?\\s*(\\d{1,3}(?:\\.\\d*)?)?['′]?\\s*([EW])$/)) {\n    // degrees, decimal minutes [NSEW]\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng((/N/i.test(match[3]) ? 1 : -1) * (+match[1] + +match[2] / 60), (/E/i.test(match[6]) ? 1 : -1) * (+match[4] + +match[5] / 60));\n  } else if (match = query.match(/^([NS])\\s*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?\\W*([EW])\\s*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?$/)) {\n    // [NSEW] degrees, minutes, decimal seconds\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng((/N/i.test(match[1]) ? 1 : -1) * (+match[2] + +match[3] / 60 + +match[4] / 3600), (/E/i.test(match[5]) ? 1 : -1) * (+match[6] + +match[7] / 60 + +match[8] / 3600));\n  } else if (match = query.match(/^(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]\\s*([NS])\\W*(\\d{1,3})°?\\s*(\\d{1,2})['′]?\\s*(\\d{1,3}(?:\\.\\d*)?)?[\"″]?\\s*([EW])$/)) {\n    // degrees, minutes, decimal seconds [NSEW]\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng((/N/i.test(match[4]) ? 1 : -1) * (+match[1] + +match[2] / 60 + +match[3] / 3600), (/E/i.test(match[8]) ? 1 : -1) * (+match[5] + +match[6] / 60 + +match[7] / 3600));\n  } else if (match = query.match(/^\\s*([+-]?\\d+(?:\\.\\d*)?)\\s*[\\s,]\\s*([+-]?\\d+(?:\\.\\d*)?)\\s*$/)) {\n    return leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(+match[1], +match[2]);\n  }\n}\n/**\r\n * Parses basic latitude/longitude strings such as `'50.06773 14.37742'`, `'N50.06773 W14.37742'`, `'S 50° 04.064 E 014° 22.645'`, or `'S 50° 4′ 03.828″, W 14° 22′ 38.712″'`\r\n */\n\nclass LatLng {\n  constructor(options) {\n    this.options = {\n      next: undefined,\n      sizeInMeters: 10000\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    const center = parseLatLng(query);\n\n    if (center) {\n      const results = [{\n        name: query,\n        center: center,\n        bbox: center.toBounds(this.options.sizeInMeters)\n      }];\n      cb.call(context, results);\n    } else if (this.options.next) {\n      this.options.next.geocode(query, cb, context);\n    }\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link LatLng}\r\n * @param options the options\r\n */\n\nfunction latLng(options) {\n  return new LatLng(options);\n}\n\n/**\r\n * Implementation of the [Mapbox Geocoding](https://www.mapbox.com/api-documentation/#geocoding)\r\n */\n\nclass Mapbox {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://api.mapbox.com/geocoding/v5/mapbox.places/'\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  _getProperties(loc) {\n    const properties = {\n      text: loc.text,\n      address: loc.address\n    };\n\n    for (let j = 0; j < (loc.context || []).length; j++) {\n      const id = loc.context[j].id.split('.')[0];\n      properties[id] = loc.context[j].text; // Get country code when available\n\n      if (loc.context[j].short_code) {\n        properties['countryShortCode'] = loc.context[j].short_code;\n      }\n    }\n\n    return properties;\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      access_token: this.options.apiKey\n    });\n\n    if (params.proximity !== undefined && params.proximity.lat !== undefined && params.proximity.lng !== undefined) {\n      params.proximity = params.proximity.lng + ',' + params.proximity.lat;\n    }\n\n    getJSON(this.options.serviceUrl + encodeURIComponent(query) + '.json', params, data => {\n      const results = [];\n\n      if (data.features && data.features.length) {\n        for (let i = 0; i <= data.features.length - 1; i++) {\n          const loc = data.features[i];\n          const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.center.reverse());\n          let bbox;\n\n          if (loc.bbox) {\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.bbox.slice(0, 2).reverse()), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.bbox.slice(2, 4).reverse()));\n          } else {\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n          }\n\n          results[i] = {\n            name: loc.place_name,\n            bbox: bbox,\n            center: center,\n            properties: this._getProperties(loc)\n          };\n        }\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n  suggest(query, cb, context) {\n    return this.geocode(query, cb, context);\n  }\n\n  reverse(location, scale, cb, context) {\n    const url = this.options.serviceUrl + location.lng + ',' + location.lat + '.json';\n    const param = reverseParams(this.options, {\n      access_token: this.options.apiKey\n    });\n    getJSON(url, param, data => {\n      const results = [];\n\n      if (data.features && data.features.length) {\n        for (let i = 0; i <= data.features.length - 1; i++) {\n          const loc = data.features[i];\n          const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.center.reverse());\n          let bbox;\n\n          if (loc.bbox) {\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.bbox.slice(0, 2).reverse()), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.bbox.slice(2, 4).reverse()));\n          } else {\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n          }\n\n          results[i] = {\n            name: loc.place_name,\n            bbox: bbox,\n            center: center,\n            properties: this._getProperties(loc)\n          };\n        }\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Mapbox}\r\n * @param options the options\r\n */\n\nfunction mapbox(options) {\n  return new Mapbox(options);\n}\n\n/**\r\n * Implementation of the [MapQuest Geocoding API](http://developer.mapquest.com/web/products/dev-services/geocoding-ws)\r\n */\n\nclass MapQuest {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://www.mapquestapi.com/geocoding/v1'\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options); // MapQuest seems to provide URI encoded API keys,\n    // so to avoid encoding them twice, we decode them here\n\n    this.options.apiKey = decodeURIComponent(this.options.apiKey);\n  }\n\n  _formatName(...parts) {\n    return parts.filter(s => !!s).join(', ');\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      key: this.options.apiKey,\n      location: query,\n      limit: 5,\n      outFormat: 'json'\n    });\n    getJSON(this.options.serviceUrl + '/address', params, leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (data) {\n      const results = [];\n\n      if (data.results && data.results[0].locations) {\n        for (let i = data.results[0].locations.length - 1; i >= 0; i--) {\n          const loc = data.results[0].locations[i];\n          const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.latLng);\n          results[i] = {\n            name: this._formatName(loc.street, loc.adminArea4, loc.adminArea3, loc.adminArea1),\n            bbox: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center),\n            center: center\n          };\n        }\n      }\n\n      cb.call(context, results);\n    }, this));\n  }\n\n  reverse(location, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      key: this.options.apiKey,\n      location: location.lat + ',' + location.lng,\n      outputFormat: 'json'\n    });\n    getJSON(this.options.serviceUrl + '/reverse', params, leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (data) {\n      const results = [];\n\n      if (data.results && data.results[0].locations) {\n        for (let i = data.results[0].locations.length - 1; i >= 0; i--) {\n          const loc = data.results[0].locations[i];\n          const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.latLng);\n          results[i] = {\n            name: this._formatName(loc.street, loc.adminArea4, loc.adminArea3, loc.adminArea1),\n            bbox: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center),\n            center: center\n          };\n        }\n      }\n\n      cb.call(context, results);\n    }, this));\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link MapQuest}\r\n * @param options the options\r\n */\n\nfunction mapQuest(options) {\n  return new MapQuest(options);\n}\n\n/**\r\n * Implementation of the [Neutrino API](https://www.neutrinoapi.com/api/geocode-address/)\r\n */\n\nclass Neutrino {\n  constructor(options) {\n    this.options = {\n      userId: undefined,\n      apiKey: undefined,\n      serviceUrl: 'https://neutrinoapi.com/'\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  } // https://www.neutrinoapi.com/api/geocode-address/\n\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      apiKey: this.options.apiKey,\n      userId: this.options.userId,\n      //get three words and make a dot based string\n      address: query.split(/\\s+/).join('.')\n    });\n    getJSON(this.options.serviceUrl + 'geocode-address', params, data => {\n      const results = [];\n\n      if (data.locations) {\n        data.geometry = data.locations[0];\n        const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(data.geometry['latitude'], data.geometry['longitude']);\n        const bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n        results[0] = {\n          name: data.geometry.address,\n          bbox: bbox,\n          center: center\n        };\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n  suggest(query, cb, context) {\n    return this.geocode(query, cb, context);\n  } // https://www.neutrinoapi.com/api/geocode-reverse/\n\n\n  reverse(location, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      apiKey: this.options.apiKey,\n      userId: this.options.userId,\n      latitude: location.lat,\n      longitude: location.lng\n    });\n    getJSON(this.options.serviceUrl + 'geocode-reverse', params, data => {\n      const results = [];\n\n      if (data.status.status == 200 && data.found) {\n        const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(location.lat, location.lng);\n        const bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n        results[0] = {\n          name: data.address,\n          bbox: bbox,\n          center: center\n        };\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Neutrino}\r\n * @param options the options\r\n */\n\nfunction neutrino(options) {\n  return new Neutrino(options);\n}\n\n/**\r\n * Implementation of the [Nominatim](https://wiki.openstreetmap.org/wiki/Nominatim) geocoder.\r\n *\r\n * This is the default geocoding service used by the control, unless otherwise specified in the options.\r\n *\r\n * Unless using your own Nominatim installation, please refer to the [Nominatim usage policy](https://operations.osmfoundation.org/policies/nominatim/).\r\n */\n\nclass Nominatim {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://nominatim.openstreetmap.org/',\n      htmlTemplate: function (r) {\n        const address = r.address;\n        let className;\n        const parts = [];\n\n        if (address.road || address.building) {\n          parts.push('{building} {road} {house_number}');\n        }\n\n        if (address.city || address.town || address.village || address.hamlet) {\n          className = parts.length > 0 ? 'leaflet-control-geocoder-address-detail' : '';\n          parts.push('<span class=\"' + className + '\">{postcode} {city} {town} {village} {hamlet}</span>');\n        }\n\n        if (address.state || address.country) {\n          className = parts.length > 0 ? 'leaflet-control-geocoder-address-context' : '';\n          parts.push('<span class=\"' + className + '\">{state} {country}</span>');\n        }\n\n        return template(parts.join('<br/>'), address);\n      }\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options || {});\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      q: query,\n      limit: 5,\n      format: 'json',\n      addressdetails: 1\n    });\n    getJSON(this.options.serviceUrl + 'search', params, data => {\n      const results = [];\n\n      for (let i = data.length - 1; i >= 0; i--) {\n        const bbox = data[i].boundingbox;\n\n        for (let j = 0; j < 4; j++) bbox[j] = +bbox[j];\n\n        results[i] = {\n          icon: data[i].icon,\n          name: data[i].display_name,\n          html: this.options.htmlTemplate ? this.options.htmlTemplate(data[i]) : undefined,\n          bbox: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds([bbox[0], bbox[2]], [bbox[1], bbox[3]]),\n          center: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(data[i].lat, data[i].lon),\n          properties: data[i]\n        };\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n  reverse(location, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      lat: location.lat,\n      lon: location.lng,\n      zoom: Math.round(Math.log(scale / 256) / Math.log(2)),\n      addressdetails: 1,\n      format: 'json'\n    });\n    getJSON(this.options.serviceUrl + 'reverse', params, data => {\n      const result = [];\n\n      if (data && data.lat && data.lon) {\n        const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(data.lat, data.lon);\n        const bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n        result.push({\n          name: data.display_name,\n          html: this.options.htmlTemplate ? this.options.htmlTemplate(data) : undefined,\n          center: center,\n          bbox: bbox,\n          properties: data\n        });\n      }\n\n      cb.call(context, result);\n    });\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Nominatim}\r\n * @param options the options\r\n */\n\nfunction nominatim(options) {\n  return new Nominatim(options);\n}\n\n/**\r\n * Implementation of the [Plus codes](https://plus.codes/) (formerly OpenLocationCode) (requires [open-location-code](https://www.npmjs.com/package/open-location-code))\r\n */\n\nclass OpenLocationCode {\n  constructor(options) {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    try {\n      const decoded = this.options.OpenLocationCode.decode(query);\n      const result = {\n        name: query,\n        center: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(decoded.latitudeCenter, decoded.longitudeCenter),\n        bbox: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(decoded.latitudeLo, decoded.longitudeLo), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(decoded.latitudeHi, decoded.longitudeHi))\n      };\n      cb.call(context, [result]);\n    } catch (e) {\n      console.warn(e); // eslint-disable-line no-console\n\n      cb.call(context, []);\n    }\n  }\n\n  reverse(location, scale, cb, context) {\n    try {\n      const code = this.options.OpenLocationCode.encode(location.lat, location.lng, this.options.codeLength);\n      const result = {\n        name: code,\n        center: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(location.lat, location.lng),\n        bbox: leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(location.lat, location.lng), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(location.lat, location.lng))\n      };\n      cb.call(context, [result]);\n    } catch (e) {\n      console.warn(e); // eslint-disable-line no-console\n\n      cb.call(context, []);\n    }\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link OpenLocationCode}\r\n * @param options the options\r\n */\n\nfunction openLocationCode(options) {\n  return new OpenLocationCode(options);\n}\n\n/**\r\n * Implementation of the [OpenCage Data API](https://opencagedata.com/)\r\n */\n\nclass OpenCage {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://api.opencagedata.com/geocode/v1/json'\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      key: this.options.apiKey,\n      q: query\n    });\n    getJSON(this.options.serviceUrl, params, data => {\n      const results = [];\n\n      if (data.results && data.results.length) {\n        for (let i = 0; i < data.results.length; i++) {\n          const loc = data.results[i];\n          const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.geometry);\n          let bbox;\n\n          if (loc.annotations && loc.annotations.bounds) {\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.annotations.bounds.northeast), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.annotations.bounds.southwest));\n          } else {\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n          }\n\n          results.push({\n            name: loc.formatted,\n            bbox: bbox,\n            center: center\n          });\n        }\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n  suggest(query, cb, context) {\n    return this.geocode(query, cb, context);\n  }\n\n  reverse(location, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      key: this.options.apiKey,\n      q: [location.lat, location.lng].join(',')\n    });\n    getJSON(this.options.serviceUrl, params, data => {\n      const results = [];\n\n      if (data.results && data.results.length) {\n        for (let i = 0; i < data.results.length; i++) {\n          const loc = data.results[i];\n          const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.geometry);\n          let bbox;\n\n          if (loc.annotations && loc.annotations.bounds) {\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.annotations.bounds.northeast), leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(loc.annotations.bounds.southwest));\n          } else {\n            bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n          }\n\n          results.push({\n            name: loc.formatted,\n            bbox: bbox,\n            center: center\n          });\n        }\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n}\nfunction opencage(options) {\n  return new OpenCage(options);\n}\n\n/**\r\n * Implementation of the [Pelias](https://pelias.io/), [geocode.earth](https://geocode.earth/) geocoder (formerly Mapzen Search)\r\n */\n\nclass Pelias {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://api.geocode.earth/v1'\n    };\n    this._lastSuggest = 0;\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      api_key: this.options.apiKey,\n      text: query\n    });\n    getJSON(this.options.serviceUrl + '/search', params, data => {\n      cb.call(context, this._parseResults(data, 'bbox'));\n    });\n  }\n\n  suggest(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      api_key: this.options.apiKey,\n      text: query\n    });\n    getJSON(this.options.serviceUrl + '/autocomplete', params, data => {\n      if (data.geocoding.timestamp > this._lastSuggest) {\n        this._lastSuggest = data.geocoding.timestamp;\n        cb.call(context, this._parseResults(data, 'bbox'));\n      }\n    });\n  }\n\n  reverse(location, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      api_key: this.options.apiKey,\n      'point.lat': location.lat,\n      'point.lon': location.lng\n    });\n    getJSON(this.options.serviceUrl + '/reverse', params, data => {\n      cb.call(context, this._parseResults(data, 'bounds'));\n    });\n  }\n\n  _parseResults(data, bboxname) {\n    const results = [];\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.geoJSON(data, {\n      pointToLayer: function (feature, latlng) {\n        return leaflet__WEBPACK_IMPORTED_MODULE_0__.circleMarker(latlng);\n      },\n      onEachFeature: function (feature, layer) {\n        const result = {};\n        let bbox;\n        let center;\n\n        if (layer.getBounds) {\n          bbox = layer.getBounds();\n          center = bbox.getCenter();\n        } else if (layer.feature.bbox) {\n          center = layer.getLatLng();\n          bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.coordsToLatLng(layer.feature.bbox.slice(0, 2)), leaflet__WEBPACK_IMPORTED_MODULE_0__.GeoJSON.coordsToLatLng(layer.feature.bbox.slice(2, 4)));\n        } else {\n          center = layer.getLatLng();\n          bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n        }\n\n        result.name = layer.feature.properties.label;\n        result.center = center;\n        result[bboxname] = bbox;\n        result.properties = layer.feature.properties;\n        results.push(result);\n      }\n    });\n    return results;\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Pelias}\r\n * @param options the options\r\n */\n\nfunction pelias(options) {\n  return new Pelias(options);\n}\nconst GeocodeEarth = Pelias;\nconst geocodeEarth = pelias;\n/**\r\n * r.i.p.\r\n * @deprecated\r\n */\n\nconst Mapzen = Pelias;\n/**\r\n * r.i.p.\r\n * @deprecated\r\n */\n\nconst mapzen = pelias;\n/**\r\n * Implementation of the [Openrouteservice](https://openrouteservice.org/dev/#/api-docs/geocode) geocoder\r\n */\n\nclass Openrouteservice extends Pelias {\n  constructor(options) {\n    super(leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend({\n      serviceUrl: 'https://api.openrouteservice.org/geocode'\n    }, options));\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Openrouteservice}\r\n * @param options the options\r\n */\n\nfunction openrouteservice(options) {\n  return new Openrouteservice(options);\n}\n\n/**\r\n * Implementation of the [Photon](http://photon.komoot.de/) geocoder\r\n */\n\nclass Photon {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://photon.komoot.io/api/',\n      reverseUrl: 'https://photon.komoot.io/reverse/',\n      nameProperties: ['name', 'street', 'suburb', 'hamlet', 'town', 'city', 'state', 'country']\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    const params = geocodingParams(this.options, {\n      q: query\n    });\n    getJSON(this.options.serviceUrl, params, leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (data) {\n      cb.call(context, this._decodeFeatures(data));\n    }, this));\n  }\n\n  suggest(query, cb, context) {\n    return this.geocode(query, cb, context);\n  }\n\n  reverse(latLng, scale, cb, context) {\n    const params = reverseParams(this.options, {\n      lat: latLng.lat,\n      lon: latLng.lng\n    });\n    getJSON(this.options.reverseUrl, params, leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.bind(function (data) {\n      cb.call(context, this._decodeFeatures(data));\n    }, this));\n  }\n\n  _decodeFeatures(data) {\n    const results = [];\n\n    if (data && data.features) {\n      for (let i = 0; i < data.features.length; i++) {\n        const f = data.features[i];\n        const c = f.geometry.coordinates;\n        const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(c[1], c[0]);\n        const extent = f.properties.extent;\n        const bbox = extent ? leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds([extent[1], extent[0]], [extent[3], extent[2]]) : leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n        results.push({\n          name: this._decodeFeatureName(f),\n          html: this.options.htmlTemplate ? this.options.htmlTemplate(f) : undefined,\n          center: center,\n          bbox: bbox,\n          properties: f.properties\n        });\n      }\n    }\n\n    return results;\n  }\n\n  _decodeFeatureName(f) {\n    return (this.options.nameProperties || []).map(p => {\n      return f.properties[p];\n    }).filter(v => {\n      return !!v;\n    }).join(', ');\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link Photon}\r\n * @param options the options\r\n */\n\nfunction photon(options) {\n  return new Photon(options);\n}\n\n/**\r\n * Implementation of the What3Words service\r\n */\n\nclass What3Words {\n  constructor(options) {\n    this.options = {\n      serviceUrl: 'https://api.what3words.com/v2/'\n    };\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n  }\n\n  geocode(query, cb, context) {\n    //get three words and make a dot based string\n    getJSON(this.options.serviceUrl + 'forward', geocodingParams(this.options, {\n      key: this.options.apiKey,\n      addr: query.split(/\\s+/).join('.')\n    }), data => {\n      const results = [];\n\n      if (data.geometry) {\n        const latLng = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(data.geometry['lat'], data.geometry['lng']);\n        const latLngBounds = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(latLng, latLng);\n        results[0] = {\n          name: data.words,\n          bbox: latLngBounds,\n          center: latLng\n        };\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n  suggest(query, cb, context) {\n    return this.geocode(query, cb, context);\n  }\n\n  reverse(location, scale, cb, context) {\n    getJSON(this.options.serviceUrl + 'reverse', reverseParams(this.options, {\n      key: this.options.apiKey,\n      coords: [location.lat, location.lng].join(',')\n    }), data => {\n      const results = [];\n\n      if (data.status.status == 200) {\n        const center = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLng(data.geometry['lat'], data.geometry['lng']);\n        const bbox = leaflet__WEBPACK_IMPORTED_MODULE_0__.latLngBounds(center, center);\n        results[0] = {\n          name: data.words,\n          bbox: bbox,\n          center: center\n        };\n      }\n\n      cb.call(context, results);\n    });\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link What3Words}\r\n * @param options the options\r\n */\n\nfunction what3words(options) {\n  return new What3Words(options);\n}\n\nvar geocoders = {\n  __proto__: null,\n  geocodingParams: geocodingParams,\n  reverseParams: reverseParams,\n  ArcGis: ArcGis,\n  arcgis: arcgis,\n  Bing: Bing,\n  bing: bing,\n  Google: Google,\n  google: google,\n  HERE: HERE,\n  HEREv2: HEREv2,\n  here: here,\n  parseLatLng: parseLatLng,\n  LatLng: LatLng,\n  latLng: latLng,\n  Mapbox: Mapbox,\n  mapbox: mapbox,\n  MapQuest: MapQuest,\n  mapQuest: mapQuest,\n  Neutrino: Neutrino,\n  neutrino: neutrino,\n  Nominatim: Nominatim,\n  nominatim: nominatim,\n  OpenLocationCode: OpenLocationCode,\n  openLocationCode: openLocationCode,\n  OpenCage: OpenCage,\n  opencage: opencage,\n  Pelias: Pelias,\n  pelias: pelias,\n  GeocodeEarth: GeocodeEarth,\n  geocodeEarth: geocodeEarth,\n  Mapzen: Mapzen,\n  mapzen: mapzen,\n  Openrouteservice: Openrouteservice,\n  openrouteservice: openrouteservice,\n  Photon: Photon,\n  photon: photon,\n  What3Words: What3Words,\n  what3words: what3words\n};\n\n/**\r\n * Leaflet mixins https://leafletjs.com/reference-1.7.1.html#class-includes\r\n * for TypeScript https://www.typescriptlang.org/docs/handbook/mixins.html\r\n * @internal\r\n */\n\nclass EventedControl {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  constructor(...args) {// empty\n  }\n\n}\n\nleaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(EventedControl.prototype, leaflet__WEBPACK_IMPORTED_MODULE_0__.Control.prototype);\nleaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(EventedControl.prototype, leaflet__WEBPACK_IMPORTED_MODULE_0__.Evented.prototype);\n/**\r\n * This is the geocoder control. It works like any other [Leaflet control](https://leafletjs.com/reference.html#control), and is added to the map.\r\n */\n\nclass GeocoderControl extends EventedControl {\n  /**\r\n   * Instantiates a geocoder control (to be invoked using `new`)\r\n   * @param options the options\r\n   */\n  constructor(options) {\n    super(options);\n    this.options = {\n      showUniqueResult: true,\n      showResultIcons: false,\n      collapsed: true,\n      expand: 'touch',\n      position: 'topright',\n      placeholder: 'Search...',\n      errorMessage: 'Nothing found.',\n      iconLabel: 'Initiate a new search',\n      query: '',\n      queryMinLength: 1,\n      suggestMinLength: 3,\n      suggestTimeout: 250,\n      defaultMarkGeocode: true\n    };\n    this._requestCount = 0;\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.Util.setOptions(this, options);\n\n    if (!this.options.geocoder) {\n      this.options.geocoder = new Nominatim();\n    }\n  }\n\n  addThrobberClass() {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(this._container, 'leaflet-control-geocoder-throbber');\n  }\n\n  removeThrobberClass() {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-throbber');\n  }\n  /**\r\n   * Returns the container DOM element for the control and add listeners on relevant map events.\r\n   * @param map the map instance\r\n   * @see https://leafletjs.com/reference.html#control-onadd\r\n   */\n\n\n  onAdd(map) {\n    const className = 'leaflet-control-geocoder';\n    const container = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('div', className + ' leaflet-bar');\n    const icon = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('button', className + '-icon', container);\n    const form = this._form = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('div', className + '-form', container);\n    this._map = map;\n    this._container = container;\n    icon.innerHTML = '&nbsp;';\n    icon.type = 'button';\n    icon.setAttribute('aria-label', this.options.iconLabel);\n    const input = this._input = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('input', '', form);\n    input.type = 'text';\n    input.value = this.options.query;\n    input.placeholder = this.options.placeholder;\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.disableClickPropagation(input);\n    this._errorElement = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('div', className + '-form-no-error', container);\n    this._errorElement.innerHTML = this.options.errorMessage;\n    this._alts = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('ul', className + '-alternatives leaflet-control-geocoder-alternatives-minimized', container);\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.disableClickPropagation(this._alts);\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(input, 'keydown', this._keydown, this);\n\n    if (this.options.geocoder.suggest) {\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(input, 'input', this._change, this);\n    }\n\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(input, 'blur', () => {\n      if (this.options.collapsed && !this._preventBlurCollapse) {\n        this._collapse();\n      }\n\n      this._preventBlurCollapse = false;\n    });\n\n    if (this.options.collapsed) {\n      if (this.options.expand === 'click') {\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(container, 'click', e => {\n          if (e.button === 0 && e.detail !== 2) {\n            this._toggle();\n          }\n        });\n      } else if (this.options.expand === 'touch') {\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(container, leaflet__WEBPACK_IMPORTED_MODULE_0__.Browser.touch ? 'touchstart mousedown' : 'mousedown', e => {\n          this._toggle();\n\n          e.preventDefault(); // mobile: clicking focuses the icon, so UI expands and immediately collapses\n\n          e.stopPropagation();\n        }, this);\n      } else {\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(container, 'mouseover', this._expand, this);\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(container, 'mouseout', this._collapse, this);\n\n        this._map.on('movestart', this._collapse, this);\n      }\n    } else {\n      this._expand();\n\n      if (leaflet__WEBPACK_IMPORTED_MODULE_0__.Browser.touch) {\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(container, 'touchstart', () => this._geocode());\n      } else {\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(container, 'click', () => this._geocode());\n      }\n    }\n\n    if (this.options.defaultMarkGeocode) {\n      this.on('markgeocode', this.markGeocode, this);\n    }\n\n    this.on('startgeocode', this.addThrobberClass, this);\n    this.on('finishgeocode', this.removeThrobberClass, this);\n    this.on('startsuggest', this.addThrobberClass, this);\n    this.on('finishsuggest', this.removeThrobberClass, this);\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.disableClickPropagation(container);\n    return container;\n  }\n  /**\r\n   * Sets the query string on the text input\r\n   * @param string the query string\r\n   */\n\n\n  setQuery(string) {\n    this._input.value = string;\n    return this;\n  }\n\n  _geocodeResult(results, suggest) {\n    if (!suggest && this.options.showUniqueResult && results.length === 1) {\n      this._geocodeResultSelected(results[0]);\n    } else if (results.length > 0) {\n      this._alts.innerHTML = '';\n      this._results = results;\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(this._container, 'leaflet-control-geocoder-options-open');\n\n      for (let i = 0; i < results.length; i++) {\n        this._alts.appendChild(this._createAlt(results[i], i));\n      }\n    } else {\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(this._container, 'leaflet-control-geocoder-options-error');\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(this._errorElement, 'leaflet-control-geocoder-error');\n    }\n  }\n  /**\r\n   * Marks a geocoding result on the map\r\n   * @param result the geocoding result\r\n   */\n\n\n  markGeocode(event) {\n    const result = event.geocode;\n\n    this._map.fitBounds(result.bbox);\n\n    if (this._geocodeMarker) {\n      this._map.removeLayer(this._geocodeMarker);\n    }\n\n    this._geocodeMarker = new leaflet__WEBPACK_IMPORTED_MODULE_0__.Marker(result.center).bindPopup(result.html || result.name).addTo(this._map).openPopup();\n    return this;\n  }\n\n  _geocode(suggest) {\n    const value = this._input.value;\n\n    if (!suggest && value.length < this.options.queryMinLength) {\n      return;\n    }\n\n    const requestCount = ++this._requestCount;\n\n    const cb = results => {\n      if (requestCount === this._requestCount) {\n        const event = {\n          input: value,\n          results\n        };\n        this.fire(suggest ? 'finishsuggest' : 'finishgeocode', event);\n\n        this._geocodeResult(results, suggest);\n      }\n    };\n\n    this._lastGeocode = value;\n\n    if (!suggest) {\n      this._clearResults();\n    }\n\n    const event = {\n      input: value\n    };\n    this.fire(suggest ? 'startsuggest' : 'startgeocode', event);\n\n    if (suggest) {\n      this.options.geocoder.suggest(value, cb);\n    } else {\n      this.options.geocoder.geocode(value, cb);\n    }\n  }\n\n  _geocodeResultSelected(geocode) {\n    const event = {\n      geocode\n    };\n    this.fire('markgeocode', event);\n  }\n\n  _toggle() {\n    if (leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.hasClass(this._container, 'leaflet-control-geocoder-expanded')) {\n      this._collapse();\n    } else {\n      this._expand();\n    }\n  }\n\n  _expand() {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(this._container, 'leaflet-control-geocoder-expanded');\n\n    this._input.select();\n\n    this.fire('expand');\n  }\n\n  _collapse() {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-expanded');\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-open');\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-error');\n\n    this._input.blur(); // mobile: keyboard shouldn't stay expanded\n\n\n    this.fire('collapse');\n  }\n\n  _clearResults() {\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(this._alts, 'leaflet-control-geocoder-alternatives-minimized');\n    this._selection = null;\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._errorElement, 'leaflet-control-geocoder-error');\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-open');\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._container, 'leaflet-control-geocoder-options-error');\n  }\n\n  _createAlt(result, index) {\n    const li = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('li', ''),\n          a = leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('a', '', li),\n          icon = this.options.showResultIcons && result.icon ? leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.create('img', '', a) : null,\n          text = result.html ? undefined : document.createTextNode(result.name),\n          mouseDownHandler = e => {\n      // In some browsers, a click will fire on the map if the control is\n      // collapsed directly after mousedown. To work around this, we\n      // wait until the click is completed, and _then_ collapse the\n      // control. Messy, but this is the workaround I could come up with\n      // for #142.\n      this._preventBlurCollapse = true;\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.stop(e);\n\n      this._geocodeResultSelected(result);\n\n      leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.on(li, 'click touchend', () => {\n        if (this.options.collapsed) {\n          this._collapse();\n        } else {\n          this._clearResults();\n        }\n      });\n    };\n\n    if (icon) {\n      icon.src = result.icon;\n    }\n\n    li.setAttribute('data-result-index', String(index));\n\n    if (result.html) {\n      a.innerHTML = a.innerHTML + result.html;\n    } else if (text) {\n      a.appendChild(text);\n    } // Use mousedown and not click, since click will fire _after_ blur,\n    // causing the control to have collapsed and removed the items\n    // before the click can fire.\n\n\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.addListener(li, 'mousedown touchstart', mouseDownHandler, this);\n    return li;\n  }\n\n  _keydown(e) {\n    const select = dir => {\n      if (this._selection) {\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.removeClass(this._selection, 'leaflet-control-geocoder-selected');\n        this._selection = this._selection[dir > 0 ? 'nextSibling' : 'previousSibling'];\n      }\n\n      if (!this._selection) {\n        this._selection = this._alts[dir > 0 ? 'firstChild' : 'lastChild'];\n      }\n\n      if (this._selection) {\n        leaflet__WEBPACK_IMPORTED_MODULE_0__.DomUtil.addClass(this._selection, 'leaflet-control-geocoder-selected');\n      }\n    };\n\n    switch (e.keyCode) {\n      // Escape\n      case 27:\n        if (this.options.collapsed) {\n          this._collapse();\n        } else {\n          this._clearResults();\n        }\n\n        break;\n      // Up\n\n      case 38:\n        select(-1);\n        break;\n      // Up\n\n      case 40:\n        select(1);\n        break;\n      // Enter\n\n      case 13:\n        if (this._selection) {\n          const index = parseInt(this._selection.getAttribute('data-result-index'), 10);\n\n          this._geocodeResultSelected(this._results[index]);\n\n          this._clearResults();\n        } else {\n          this._geocode();\n        }\n\n        break;\n\n      default:\n        return;\n    }\n\n    leaflet__WEBPACK_IMPORTED_MODULE_0__.DomEvent.preventDefault(e);\n  }\n\n  _change() {\n    const v = this._input.value;\n\n    if (v !== this._lastGeocode) {\n      clearTimeout(this._suggestTimeout);\n\n      if (v.length >= this.options.suggestMinLength) {\n        this._suggestTimeout = setTimeout(() => this._geocode(true), this.options.suggestTimeout);\n      } else {\n        this._clearResults();\n      }\n    }\n  }\n\n}\n/**\r\n * [Class factory method](https://leafletjs.com/reference.html#class-class-factories) for {@link GeocoderControl}\r\n * @param options the options\r\n */\n\nfunction geocoder(options) {\n  return new GeocoderControl(options);\n}\n\n/* @preserve\r\n * Leaflet Control Geocoder\r\n * https://github.com/perliedman/leaflet-control-geocoder\r\n *\r\n * Copyright (c) 2012 sa3m (https://github.com/sa3m)\r\n * Copyright (c) 2018 Per Liedman\r\n * All rights reserved.\r\n */\nleaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(GeocoderControl, geocoders);\nleaflet__WEBPACK_IMPORTED_MODULE_0__.Util.extend(leaflet__WEBPACK_IMPORTED_MODULE_0__.Control, {\n  Geocoder: GeocoderControl,\n  geocoder: geocoder\n});\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (GeocoderControl);\n\n//# sourceMappingURL=Control.Geocoder.modern.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC1jb250cm9sLWdlb2NvZGVyL2Rpc3QvQ29udHJvbC5HZW9jb2Rlci5tb2Rlcm4uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTZCOztBQUU3QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlDQUFNO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLHlDQUFNO0FBQ2Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBLHdCQUF3QjtBQUN4Qjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaLFlBQVk7QUFDWixjQUFjO0FBQ2QsY0FBYztBQUNkLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBLElBQUk7QUFDSjtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIseUNBQU07QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCLGFBQWE7QUFDdEM7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztB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YXAtYWR2YW5jZS8uL25vZGVfbW9kdWxlcy9sZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXIvZGlzdC9Db250cm9sLkdlb2NvZGVyLm1vZGVybi5qcz9kMGYxIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIEwgZnJvbSAnbGVhZmxldCc7XG5cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXG5cbmZ1bmN0aW9uIGdlb2NvZGluZ1BhcmFtcyhvcHRpb25zLCBwYXJhbXMpIHtcbiAgcmV0dXJuIEwuVXRpbC5leHRlbmQocGFyYW1zLCBvcHRpb25zLmdlb2NvZGluZ1F1ZXJ5UGFyYW1zKTtcbn1cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXG5cbmZ1bmN0aW9uIHJldmVyc2VQYXJhbXMob3B0aW9ucywgcGFyYW1zKSB7XG4gIHJldHVybiBMLlV0aWwuZXh0ZW5kKHBhcmFtcywgb3B0aW9ucy5yZXZlcnNlUXVlcnlQYXJhbXMpO1xufVxuXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xuXG5sZXQgbGFzdENhbGxiYWNrSWQgPSAwOyAvLyBBZGFwdGVkIGZyb20gaGFuZGxlYmFycy5qc1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3d5Y2F0cy9oYW5kbGViYXJzLmpzL1xuXG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xuXG5jb25zdCBiYWRDaGFycyA9IC9bJjw+XCInYF0vZztcbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXG5cbmNvbnN0IHBvc3NpYmxlID0gL1smPD5cIidgXS87XG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xuXG5jb25zdCBlc2NhcGUgPSB7XG4gICcmJzogJyZhbXA7JyxcbiAgJzwnOiAnJmx0OycsXG4gICc+JzogJyZndDsnLFxuICAnXCInOiAnJnF1b3Q7JyxcbiAgXCInXCI6ICcmI3gyNzsnLFxuICAnYCc6ICcmI3g2MDsnXG59O1xuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cblxuZnVuY3Rpb24gZXNjYXBlQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGVzY2FwZVtjaHJdO1xufVxuLyoqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKi9cblxuXG5mdW5jdGlvbiBodG1sRXNjYXBlKHN0cmluZykge1xuICBpZiAoc3RyaW5nID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gZWxzZSBpZiAoIXN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcgKyAnJztcbiAgfSAvLyBGb3JjZSBhIHN0cmluZyBjb252ZXJzaW9uIGFzIHRoaXMgd2lsbCBiZSBkb25lIGJ5IHRoZSBhcHBlbmQgcmVnYXJkbGVzcyBhbmRcbiAgLy8gdGhlIHJlZ2V4IHRlc3Qgd2lsbCBkbyB0aGlzIHRyYW5zcGFyZW50bHkgYmVoaW5kIHRoZSBzY2VuZXMsIGNhdXNpbmcgaXNzdWVzIGlmXG4gIC8vIGFuIG9iamVjdCdzIHRvIHN0cmluZyBoYXMgZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGl0LlxuXG5cbiAgc3RyaW5nID0gJycgKyBzdHJpbmc7XG5cbiAgaWYgKCFwb3NzaWJsZS50ZXN0KHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nO1xuICB9XG5cbiAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKGJhZENoYXJzLCBlc2NhcGVDaGFyKTtcbn1cbi8qKlxyXG4gKiBAaW50ZXJuYWxcclxuICovXG5cbmZ1bmN0aW9uIGpzb25wKHVybCwgcGFyYW1zLCBjYWxsYmFjaywgY29udGV4dCwganNvbnBQYXJhbSkge1xuICBjb25zdCBjYWxsYmFja0lkID0gJ19sX2dlb2NvZGVyXycgKyBsYXN0Q2FsbGJhY2tJZCsrO1xuICBwYXJhbXNbanNvbnBQYXJhbSB8fCAnY2FsbGJhY2snXSA9IGNhbGxiYWNrSWQ7XG4gIHdpbmRvd1tjYWxsYmFja0lkXSA9IEwuVXRpbC5iaW5kKGNhbGxiYWNrLCBjb250ZXh0KTtcbiAgY29uc3Qgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gIHNjcmlwdC50eXBlID0gJ3RleHQvamF2YXNjcmlwdCc7XG4gIHNjcmlwdC5zcmMgPSB1cmwgKyBnZXRQYXJhbVN0cmluZyhwYXJhbXMpO1xuICBzY3JpcHQuaWQgPSBjYWxsYmFja0lkO1xuICBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdLmFwcGVuZENoaWxkKHNjcmlwdCk7XG59XG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRKU09OKHVybCwgcGFyYW1zLCBjYWxsYmFjaykge1xuICBjb25zdCB4bWxIdHRwID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG5cbiAgeG1sSHR0cC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHhtbEh0dHAucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBtZXNzYWdlO1xuXG4gICAgaWYgKHhtbEh0dHAuc3RhdHVzICE9PSAyMDAgJiYgeG1sSHR0cC5zdGF0dXMgIT09IDMwNCkge1xuICAgICAgbWVzc2FnZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHhtbEh0dHAucmVzcG9uc2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBJRSBkb2Vzbid0IHBhcnNlIEpTT04gcmVzcG9uc2VzIGV2ZW4gd2l0aCByZXNwb25zZVR5cGU6ICdqc29uJy5cbiAgICAgIHRyeSB7XG4gICAgICAgIG1lc3NhZ2UgPSBKU09OLnBhcnNlKHhtbEh0dHAucmVzcG9uc2UpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAvLyBOb3QgYSBKU09OIHJlc3BvbnNlXG4gICAgICAgIG1lc3NhZ2UgPSB4bWxIdHRwLnJlc3BvbnNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBtZXNzYWdlID0geG1sSHR0cC5yZXNwb25zZTtcbiAgICB9XG5cbiAgICBjYWxsYmFjayhtZXNzYWdlKTtcbiAgfTtcblxuICB4bWxIdHRwLm9wZW4oJ0dFVCcsIHVybCArIGdldFBhcmFtU3RyaW5nKHBhcmFtcyksIHRydWUpO1xuICB4bWxIdHRwLnJlc3BvbnNlVHlwZSA9ICdqc29uJztcbiAgeG1sSHR0cC5zZXRSZXF1ZXN0SGVhZGVyKCdBY2NlcHQnLCAnYXBwbGljYXRpb24vanNvbicpO1xuICB4bWxIdHRwLnNlbmQobnVsbCk7XG59XG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShzdHIsIGRhdGEpIHtcbiAgcmV0dXJuIHN0ci5yZXBsYWNlKC9cXHsgKihbXFx3X10rKSAqXFx9L2csIChzdHIsIGtleSkgPT4ge1xuICAgIGxldCB2YWx1ZSA9IGRhdGFba2V5XTtcblxuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YWx1ZSA9ICcnO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YWx1ZSA9IHZhbHVlKGRhdGEpO1xuICAgIH1cblxuICAgIHJldHVybiBodG1sRXNjYXBlKHZhbHVlKTtcbiAgfSk7XG59XG4vKipcclxuICogQGludGVybmFsXHJcbiAqL1xuXG5mdW5jdGlvbiBnZXRQYXJhbVN0cmluZyhvYmosIGV4aXN0aW5nVXJsLCB1cHBlcmNhc2UpIHtcbiAgY29uc3QgcGFyYW1zID0gW107XG5cbiAgZm9yIChjb25zdCBpIGluIG9iaikge1xuICAgIGNvbnN0IGtleSA9IGVuY29kZVVSSUNvbXBvbmVudCh1cHBlcmNhc2UgPyBpLnRvVXBwZXJDYXNlKCkgOiBpKTtcbiAgICBjb25zdCB2YWx1ZSA9IG9ialtpXTtcblxuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHBhcmFtcy5wdXNoKGtleSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChTdHJpbmcodmFsdWUpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsdWUubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFyYW1zLnB1c2goa2V5ICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlW2pdKSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICghZXhpc3RpbmdVcmwgfHwgZXhpc3RpbmdVcmwuaW5kZXhPZignPycpID09PSAtMSA/ICc/JyA6ICcmJykgKyBwYXJhbXMuam9pbignJicpO1xufVxuXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtBcmNHSVMgZ2VvY29kZXJdKGh0dHBzOi8vZGV2ZWxvcGVycy5hcmNnaXMuY29tL2ZlYXR1cmVzL2dlb2NvZGluZy8pXHJcbiAqL1xuXG5jbGFzcyBBcmNHaXMge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vZ2VvY29kZS5hcmNnaXMuY29tL2FyY2dpcy9yZXN0L3NlcnZpY2VzL1dvcmxkL0dlb2NvZGVTZXJ2ZXInLFxuICAgICAgYXBpS2V5OiAnJ1xuICAgIH07XG4gICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgIHRva2VuOiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgU2luZ2xlTGluZTogcXVlcnksXG4gICAgICBvdXRGaWVsZHM6ICdBZGRyX1R5cGUnLFxuICAgICAgZm9yU3RvcmFnZTogZmFsc2UsXG4gICAgICBtYXhMb2NhdGlvbnM6IDEwLFxuICAgICAgZjogJ2pzb24nXG4gICAgfSk7XG4gICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICcvZmluZEFkZHJlc3NDYW5kaWRhdGVzJywgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgaWYgKGRhdGEuY2FuZGlkYXRlcyAmJiBkYXRhLmNhbmRpZGF0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRhdGEuY2FuZGlkYXRlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsb2MgPSBkYXRhLmNhbmRpZGF0ZXNbaV07XG4gICAgICAgICAgY29uc3QgbGF0TG5nID0gTC5sYXRMbmcobG9jLmxvY2F0aW9uLnksIGxvYy5sb2NhdGlvbi54KTtcbiAgICAgICAgICBjb25zdCBsYXRMbmdCb3VuZHMgPSBMLmxhdExuZ0JvdW5kcyhMLmxhdExuZyhsb2MuZXh0ZW50LnltYXgsIGxvYy5leHRlbnQueG1heCksIEwubGF0TG5nKGxvYy5leHRlbnQueW1pbiwgbG9jLmV4dGVudC54bWluKSk7XG4gICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGxvYy5hZGRyZXNzLFxuICAgICAgICAgICAgYmJveDogbGF0TG5nQm91bmRzLFxuICAgICAgICAgICAgY2VudGVyOiBsYXRMbmdcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cblxuICBzdWdnZXN0KHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24ubG5nICsgJywnICsgbG9jYXRpb24ubGF0LFxuICAgICAgZGlzdGFuY2U6IDEwMCxcbiAgICAgIGY6ICdqc29uJ1xuICAgIH0pO1xuICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnL3JldmVyc2VHZW9jb2RlJywgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuXG4gICAgICBpZiAoZGF0YSAmJiAhZGF0YS5lcnJvcikge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBMLmxhdExuZyhkYXRhLmxvY2F0aW9uLnksIGRhdGEubG9jYXRpb24ueCk7XG4gICAgICAgIGNvbnN0IGJib3ggPSBMLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICBuYW1lOiBkYXRhLmFkZHJlc3MuTWF0Y2hfYWRkcixcbiAgICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgICBiYm94OiBiYm94XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdCk7XG4gICAgfSk7XG4gIH1cblxufVxuLyoqXHJcbiAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBBcmNHaXN9XHJcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAqL1xuXG5mdW5jdGlvbiBhcmNnaXMob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEFyY0dpcyhvcHRpb25zKTtcbn1cblxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbQmluZyBMb2NhdGlvbnMgQVBJXShodHRwczovL2RvY3MubWljcm9zb2Z0LmNvbS9lbi11cy9iaW5nbWFwcy9yZXN0LXNlcnZpY2VzL2xvY2F0aW9ucy8pXHJcbiAqL1xuXG5jbGFzcyBCaW5nIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2Rldi52aXJ0dWFsZWFydGgubmV0L1JFU1QvdjEvTG9jYXRpb25zJ1xuICAgIH07XG4gICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgIHF1ZXJ5OiBxdWVyeSxcbiAgICAgIGtleTogdGhpcy5vcHRpb25zLmFwaUtleVxuICAgIH0pO1xuICAgIGpzb25wKHRoaXMub3B0aW9ucy5hcGlLZXksIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgIGlmIChkYXRhLnJlc291cmNlU2V0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBkYXRhLnJlc291cmNlU2V0c1swXS5yZXNvdXJjZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCByZXNvdXJjZSA9IGRhdGEucmVzb3VyY2VTZXRzWzBdLnJlc291cmNlc1tpXSxcbiAgICAgICAgICAgICAgICBiYm94ID0gcmVzb3VyY2UuYmJveDtcbiAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgbmFtZTogcmVzb3VyY2UubmFtZSxcbiAgICAgICAgICAgIGJib3g6IEwubGF0TG5nQm91bmRzKFtiYm94WzBdLCBiYm94WzFdXSwgW2Jib3hbMl0sIGJib3hbM11dKSxcbiAgICAgICAgICAgIGNlbnRlcjogTC5sYXRMbmcocmVzb3VyY2UucG9pbnQuY29vcmRpbmF0ZXMpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgIH0sIHRoaXMsICdqc29ucCcpO1xuICB9XG5cbiAgcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgIGtleTogdGhpcy5vcHRpb25zLmFwaUtleVxuICAgIH0pO1xuICAgIGpzb25wKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nLCBwYXJhbXMsIGRhdGEgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBmb3IgKGxldCBpID0gZGF0YS5yZXNvdXJjZVNldHNbMF0ucmVzb3VyY2VzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IHJlc291cmNlID0gZGF0YS5yZXNvdXJjZVNldHNbMF0ucmVzb3VyY2VzW2ldLFxuICAgICAgICAgICAgICBiYm94ID0gcmVzb3VyY2UuYmJveDtcbiAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICBuYW1lOiByZXNvdXJjZS5uYW1lLFxuICAgICAgICAgIGJib3g6IEwubGF0TG5nQm91bmRzKFtiYm94WzBdLCBiYm94WzFdXSwgW2Jib3hbMl0sIGJib3hbM11dKSxcbiAgICAgICAgICBjZW50ZXI6IEwubGF0TG5nKHJlc291cmNlLnBvaW50LmNvb3JkaW5hdGVzKVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgIH0sIHRoaXMsICdqc29ucCcpO1xuICB9XG5cbn1cbi8qKlxyXG4gKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgQmluZ31cclxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIGJpbmcob3B0aW9ucykge1xuICByZXR1cm4gbmV3IEJpbmcob3B0aW9ucyk7XG59XG5cbmNsYXNzIEdvb2dsZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9tYXBzLmdvb2dsZWFwaXMuY29tL21hcHMvYXBpL2dlb2NvZGUvanNvbidcbiAgICB9O1xuICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICBhZGRyZXNzOiBxdWVyeVxuICAgIH0pO1xuICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwsIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgIGlmIChkYXRhLnJlc3VsdHMgJiYgZGF0YS5yZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBkYXRhLnJlc3VsdHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbG9jID0gZGF0YS5yZXN1bHRzW2ldO1xuICAgICAgICAgIGNvbnN0IGxhdExuZyA9IEwubGF0TG5nKGxvYy5nZW9tZXRyeS5sb2NhdGlvbik7XG4gICAgICAgICAgY29uc3QgbGF0TG5nQm91bmRzID0gTC5sYXRMbmdCb3VuZHMoTC5sYXRMbmcobG9jLmdlb21ldHJ5LnZpZXdwb3J0Lm5vcnRoZWFzdCksIEwubGF0TG5nKGxvYy5nZW9tZXRyeS52aWV3cG9ydC5zb3V0aHdlc3QpKTtcbiAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgbmFtZTogbG9jLmZvcm1hdHRlZF9hZGRyZXNzLFxuICAgICAgICAgICAgYmJveDogbGF0TG5nQm91bmRzLFxuICAgICAgICAgICAgY2VudGVyOiBsYXRMbmcsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBsb2MuYWRkcmVzc19jb21wb25lbnRzXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgIH0pO1xuICB9XG5cbiAgcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgIGtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgIGxhdGxuZzogbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nXG4gICAgfSk7XG4gICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCwgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgaWYgKGRhdGEucmVzdWx0cyAmJiBkYXRhLnJlc3VsdHMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRhdGEucmVzdWx0cy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsb2MgPSBkYXRhLnJlc3VsdHNbaV07XG4gICAgICAgICAgY29uc3QgY2VudGVyID0gTC5sYXRMbmcobG9jLmdlb21ldHJ5LmxvY2F0aW9uKTtcbiAgICAgICAgICBjb25zdCBiYm94ID0gTC5sYXRMbmdCb3VuZHMoTC5sYXRMbmcobG9jLmdlb21ldHJ5LnZpZXdwb3J0Lm5vcnRoZWFzdCksIEwubGF0TG5nKGxvYy5nZW9tZXRyeS52aWV3cG9ydC5zb3V0aHdlc3QpKTtcbiAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgbmFtZTogbG9jLmZvcm1hdHRlZF9hZGRyZXNzLFxuICAgICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgICAgcHJvcGVydGllczogbG9jLmFkZHJlc3NfY29tcG9uZW50c1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICB9KTtcbiAgfVxuXG59XG4vKipcclxuICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIEdvb2dsZX1cclxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIGdvb2dsZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgR29vZ2xlKG9wdGlvbnMpO1xufVxuXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtIRVJFIEdlb2NvZGVyIEFQSV0oaHR0cHM6Ly9kZXZlbG9wZXIuaGVyZS5jb20vZG9jdW1lbnRhdGlvbi9nZW9jb2Rlci90b3BpY3MvaW50cm9kdWN0aW9uLmh0bWwpXHJcbiAqL1xuXG5jbGFzcyBIRVJFIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2dlb2NvZGVyLmFwaS5oZXJlLmNvbS82LjIvJyxcbiAgICAgIGFwcF9pZDogJycsXG4gICAgICBhcHBfY29kZTogJycsXG4gICAgICBhcGlLZXk6ICcnLFxuICAgICAgbWF4UmVzdWx0czogNVxuICAgIH07XG4gICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuYXBpS2V5KSB0aHJvdyBFcnJvcignYXBpS2V5IGlzIG5vdCBzdXBwb3J0ZWQsIHVzZSBhcHBfaWQvYXBwX2NvZGUgaW5zdGVhZCEnKTtcbiAgfVxuXG4gIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgc2VhcmNodGV4dDogcXVlcnksXG4gICAgICBnZW46IDksXG4gICAgICBhcHBfaWQ6IHRoaXMub3B0aW9ucy5hcHBfaWQsXG4gICAgICBhcHBfY29kZTogdGhpcy5vcHRpb25zLmFwcF9jb2RlLFxuICAgICAganNvbmF0dHJpYnV0ZXM6IDEsXG4gICAgICBtYXhyZXN1bHRzOiB0aGlzLm9wdGlvbnMubWF4UmVzdWx0c1xuICAgIH0pO1xuICAgIHRoaXMuZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICdnZW9jb2RlLmpzb24nLCBwYXJhbXMsIGNiLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgIGxldCBwcm94ID0gbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nO1xuXG4gICAgaWYgKHRoaXMub3B0aW9ucy5yZXZlcnNlR2VvY29kZVByb3hSYWRpdXMpIHtcbiAgICAgIHByb3ggKz0gJywnICsgdGhpcy5vcHRpb25zLnJldmVyc2VHZW9jb2RlUHJveFJhZGl1cztcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgcHJveCxcbiAgICAgIG1vZGU6ICdyZXRyaWV2ZUFkZHJlc3NlcycsXG4gICAgICBhcHBfaWQ6IHRoaXMub3B0aW9ucy5hcHBfaWQsXG4gICAgICBhcHBfY29kZTogdGhpcy5vcHRpb25zLmFwcF9jb2RlLFxuICAgICAgZ2VuOiA5LFxuICAgICAganNvbmF0dHJpYnV0ZXM6IDEsXG4gICAgICBtYXhyZXN1bHRzOiB0aGlzLm9wdGlvbnMubWF4UmVzdWx0c1xuICAgIH0pO1xuICAgIHRoaXMuZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICdyZXZlcnNlZ2VvY29kZS5qc29uJywgcGFyYW1zLCBjYiwgY29udGV4dCk7XG4gIH1cblxuICBnZXRKU09OKHVybCwgcGFyYW1zLCBjYiwgY29udGV4dCkge1xuICAgIGdldEpTT04odXJsLCBwYXJhbXMsIGRhdGEgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBpZiAoZGF0YS5yZXNwb25zZS52aWV3ICYmIGRhdGEucmVzcG9uc2Uudmlldy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gZGF0YS5yZXNwb25zZS52aWV3WzBdLnJlc3VsdC5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsb2MgPSBkYXRhLnJlc3BvbnNlLnZpZXdbMF0ucmVzdWx0W2ldLmxvY2F0aW9uO1xuICAgICAgICAgIGNvbnN0IGNlbnRlciA9IEwubGF0TG5nKGxvYy5kaXNwbGF5UG9zaXRpb24ubGF0aXR1ZGUsIGxvYy5kaXNwbGF5UG9zaXRpb24ubG9uZ2l0dWRlKTtcbiAgICAgICAgICBjb25zdCBiYm94ID0gTC5sYXRMbmdCb3VuZHMoTC5sYXRMbmcobG9jLm1hcFZpZXcudG9wTGVmdC5sYXRpdHVkZSwgbG9jLm1hcFZpZXcudG9wTGVmdC5sb25naXR1ZGUpLCBMLmxhdExuZyhsb2MubWFwVmlldy5ib3R0b21SaWdodC5sYXRpdHVkZSwgbG9jLm1hcFZpZXcuYm90dG9tUmlnaHQubG9uZ2l0dWRlKSk7XG4gICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGxvYy5hZGRyZXNzLmxhYmVsLFxuICAgICAgICAgICAgcHJvcGVydGllczogbG9jLmFkZHJlc3MsXG4gICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cblxufVxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBuZXcgW0hFUkUgR2VvY29kZXIgQVBJXShodHRwczovL2RldmVsb3Blci5oZXJlLmNvbS9kb2N1bWVudGF0aW9uL2dlb2NvZGluZy1zZWFyY2gtYXBpL2FwaS1yZWZlcmVuY2Utc3dhZ2dlci5odG1sKVxyXG4gKi9cblxuY2xhc3MgSEVSRXYyIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2dlb2NvZGUuc2VhcmNoLmhlcmVhcGkuY29tL3YxJyxcbiAgICAgIGFwaUtleTogJycsXG4gICAgICBhcHBfaWQ6ICcnLFxuICAgICAgYXBwX2NvZGU6ICcnLFxuICAgICAgbWF4UmVzdWx0czogMTBcbiAgICB9O1xuICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBxOiBxdWVyeSxcbiAgICAgIGFwaUtleTogdGhpcy5vcHRpb25zLmFwaUtleSxcbiAgICAgIGxpbWl0OiB0aGlzLm9wdGlvbnMubWF4UmVzdWx0c1xuICAgIH0pO1xuXG4gICAgaWYgKCFwYXJhbXMuYXQgJiYgIXBhcmFtcy5pbikge1xuICAgICAgdGhyb3cgRXJyb3IoJ2F0IC8gaW4gcGFyYW1ldGVycyBub3QgZm91bmQuIFBsZWFzZSBkZWZpbmUgY29vcmRpbmF0ZXMgKGF0PWxhdGl0dWRlLGxvbmdpdHVkZSkgb3Igb3RoZXIgKGluKSBpbiB5b3VyIGdlb2NvZGluZ1F1ZXJ5UGFyYW1zLicpO1xuICAgIH1cblxuICAgIHRoaXMuZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICcvZGlzY292ZXInLCBwYXJhbXMsIGNiLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBhdDogbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nLFxuICAgICAgbGltaXQ6IHRoaXMub3B0aW9ucy5yZXZlcnNlR2VvY29kZVByb3hSYWRpdXMsXG4gICAgICBhcGlLZXk6IHRoaXMub3B0aW9ucy5hcGlLZXlcbiAgICB9KTtcbiAgICB0aGlzLmdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnL3Jldmdlb2NvZGUnLCBwYXJhbXMsIGNiLCBjb250ZXh0KTtcbiAgfVxuXG4gIGdldEpTT04odXJsLCBwYXJhbXMsIGNiLCBjb250ZXh0KSB7XG4gICAgZ2V0SlNPTih1cmwsIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgIGlmIChkYXRhLml0ZW1zICYmIGRhdGEuaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRhdGEuaXRlbXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgaXRlbSA9IGRhdGEuaXRlbXNbaV07XG4gICAgICAgICAgY29uc3QgbGF0TG5nID0gTC5sYXRMbmcoaXRlbS5wb3NpdGlvbi5sYXQsIGl0ZW0ucG9zaXRpb24ubG5nKTtcbiAgICAgICAgICBsZXQgYmJveDtcblxuICAgICAgICAgIGlmIChpdGVtLm1hcFZpZXcpIHtcbiAgICAgICAgICAgIGJib3ggPSBMLmxhdExuZ0JvdW5kcyhMLmxhdExuZyhpdGVtLm1hcFZpZXcuc291dGgsIGl0ZW0ubWFwVmlldy53ZXN0KSwgTC5sYXRMbmcoaXRlbS5tYXBWaWV3Lm5vcnRoLCBpdGVtLm1hcFZpZXcuZWFzdCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBVc2luZyBvbmx5IHBvc2l0aW9uIHdoZW4gbm90IHByb3ZpZGVkXG4gICAgICAgICAgICBiYm94ID0gTC5sYXRMbmdCb3VuZHMoTC5sYXRMbmcoaXRlbS5wb3NpdGlvbi5sYXQsIGl0ZW0ucG9zaXRpb24ubG5nKSwgTC5sYXRMbmcoaXRlbS5wb3NpdGlvbi5sYXQsIGl0ZW0ucG9zaXRpb24ubG5nKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0uYWRkcmVzcy5sYWJlbCxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IGl0ZW0uYWRkcmVzcyxcbiAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICBjZW50ZXI6IGxhdExuZ1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICB9KTtcbiAgfVxuXG59XG4vKipcclxuICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIEhFUkV9XHJcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAqL1xuXG5mdW5jdGlvbiBoZXJlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMuYXBpS2V5KSB7XG4gICAgcmV0dXJuIG5ldyBIRVJFdjIob3B0aW9ucyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBIRVJFKG9wdGlvbnMpO1xuICB9XG59XG5cbi8qKlxyXG4gKiBQYXJzZXMgYmFzaWMgbGF0aXR1ZGUvbG9uZ2l0dWRlIHN0cmluZ3Mgc3VjaCBhcyBgJzUwLjA2NzczIDE0LjM3NzQyJ2AsIGAnTjUwLjA2NzczIFcxNC4zNzc0MidgLCBgJ1MgNTDCsCAwNC4wNjQgRSAwMTTCsCAyMi42NDUnYCwgb3IgYCdTIDUwwrAgNOKAsiAwMy44MjjigLMsIFcgMTTCsCAyMuKAsiAzOC43MTLigLMnYFxyXG4gKiBAcGFyYW0gcXVlcnkgdGhlIGxhdGl0dWRlL2xvbmdpdHVkZSBzdHJpbmcgdG8gcGFyc2VcclxuICogQHJldHVybnMgdGhlIHBhcnNlZCBsYXRpdHVkZS9sb25naXR1ZGVcclxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTGF0TG5nKHF1ZXJ5KSB7XG4gIGxldCBtYXRjaDsgLy8gcmVnZXggZnJvbSBodHRwczovL2dpdGh1Yi5jb20vb3BlbnN0cmVldG1hcC9vcGVuc3RyZWV0bWFwLXdlYnNpdGUvYmxvYi9tYXN0ZXIvYXBwL2NvbnRyb2xsZXJzL2dlb2NvZGVyX2NvbnRyb2xsZXIucmJcblxuICBpZiAobWF0Y2ggPSBxdWVyeS5tYXRjaCgvXihbTlNdKVxccyooXFxkezEsM30oPzpcXC5cXGQqKT8pXFxXKihbRVddKVxccyooXFxkezEsM30oPzpcXC5cXGQqKT8pJC8pKSB7XG4gICAgLy8gW05TRVddIGRlY2ltYWwgZGVncmVlc1xuICAgIHJldHVybiBMLmxhdExuZygoL04vaS50ZXN0KG1hdGNoWzFdKSA/IDEgOiAtMSkgKiArbWF0Y2hbMl0sICgvRS9pLnRlc3QobWF0Y2hbM10pID8gMSA6IC0xKSAqICttYXRjaFs0XSk7XG4gIH0gZWxzZSBpZiAobWF0Y2ggPSBxdWVyeS5tYXRjaCgvXihcXGR7MSwzfSg/OlxcLlxcZCopPylcXHMqKFtOU10pXFxXKihcXGR7MSwzfSg/OlxcLlxcZCopPylcXHMqKFtFV10pJC8pKSB7XG4gICAgLy8gZGVjaW1hbCBkZWdyZWVzIFtOU0VXXVxuICAgIHJldHVybiBMLmxhdExuZygoL04vaS50ZXN0KG1hdGNoWzJdKSA/IDEgOiAtMSkgKiArbWF0Y2hbMV0sICgvRS9pLnRlc3QobWF0Y2hbNF0pID8gMSA6IC0xKSAqICttYXRjaFszXSk7XG4gIH0gZWxzZSBpZiAobWF0Y2ggPSBxdWVyeS5tYXRjaCgvXihbTlNdKVxccyooXFxkezEsM30pwrA/XFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPyk/WyfigLJdP1xcVyooW0VXXSlcXHMqKFxcZHsxLDN9KcKwP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1sn4oCyXT8kLykpIHtcbiAgICAvLyBbTlNFV10gZGVncmVlcywgZGVjaW1hbCBtaW51dGVzXG4gICAgcmV0dXJuIEwubGF0TG5nKCgvTi9pLnRlc3QobWF0Y2hbMV0pID8gMSA6IC0xKSAqICgrbWF0Y2hbMl0gKyArbWF0Y2hbM10gLyA2MCksICgvRS9pLnRlc3QobWF0Y2hbNF0pID8gMSA6IC0xKSAqICgrbWF0Y2hbNV0gKyArbWF0Y2hbNl0gLyA2MCkpO1xuICB9IGVsc2UgaWYgKG1hdGNoID0gcXVlcnkubWF0Y2goL14oXFxkezEsM30pwrA/XFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPyk/WyfigLJdP1xccyooW05TXSlcXFcqKFxcZHsxLDN9KcKwP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1sn4oCyXT9cXHMqKFtFV10pJC8pKSB7XG4gICAgLy8gZGVncmVlcywgZGVjaW1hbCBtaW51dGVzIFtOU0VXXVxuICAgIHJldHVybiBMLmxhdExuZygoL04vaS50ZXN0KG1hdGNoWzNdKSA/IDEgOiAtMSkgKiAoK21hdGNoWzFdICsgK21hdGNoWzJdIC8gNjApLCAoL0UvaS50ZXN0KG1hdGNoWzZdKSA/IDEgOiAtMSkgKiAoK21hdGNoWzRdICsgK21hdGNoWzVdIC8gNjApKTtcbiAgfSBlbHNlIGlmIChtYXRjaCA9IHF1ZXJ5Lm1hdGNoKC9eKFtOU10pXFxzKihcXGR7MSwzfSnCsD9cXHMqKFxcZHsxLDJ9KVsn4oCyXT9cXHMqKFxcZHsxLDN9KD86XFwuXFxkKik/KT9bXCLigLNdP1xcVyooW0VXXSlcXHMqKFxcZHsxLDN9KcKwP1xccyooXFxkezEsMn0pWyfigLJdP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1tcIuKAs10/JC8pKSB7XG4gICAgLy8gW05TRVddIGRlZ3JlZXMsIG1pbnV0ZXMsIGRlY2ltYWwgc2Vjb25kc1xuICAgIHJldHVybiBMLmxhdExuZygoL04vaS50ZXN0KG1hdGNoWzFdKSA/IDEgOiAtMSkgKiAoK21hdGNoWzJdICsgK21hdGNoWzNdIC8gNjAgKyArbWF0Y2hbNF0gLyAzNjAwKSwgKC9FL2kudGVzdChtYXRjaFs1XSkgPyAxIDogLTEpICogKCttYXRjaFs2XSArICttYXRjaFs3XSAvIDYwICsgK21hdGNoWzhdIC8gMzYwMCkpO1xuICB9IGVsc2UgaWYgKG1hdGNoID0gcXVlcnkubWF0Y2goL14oXFxkezEsM30pwrA/XFxzKihcXGR7MSwyfSlbJ+KAsl0/XFxzKihcXGR7MSwzfSg/OlxcLlxcZCopPyk/W1wi4oCzXVxccyooW05TXSlcXFcqKFxcZHsxLDN9KcKwP1xccyooXFxkezEsMn0pWyfigLJdP1xccyooXFxkezEsM30oPzpcXC5cXGQqKT8pP1tcIuKAs10/XFxzKihbRVddKSQvKSkge1xuICAgIC8vIGRlZ3JlZXMsIG1pbnV0ZXMsIGRlY2ltYWwgc2Vjb25kcyBbTlNFV11cbiAgICByZXR1cm4gTC5sYXRMbmcoKC9OL2kudGVzdChtYXRjaFs0XSkgPyAxIDogLTEpICogKCttYXRjaFsxXSArICttYXRjaFsyXSAvIDYwICsgK21hdGNoWzNdIC8gMzYwMCksICgvRS9pLnRlc3QobWF0Y2hbOF0pID8gMSA6IC0xKSAqICgrbWF0Y2hbNV0gKyArbWF0Y2hbNl0gLyA2MCArICttYXRjaFs3XSAvIDM2MDApKTtcbiAgfSBlbHNlIGlmIChtYXRjaCA9IHF1ZXJ5Lm1hdGNoKC9eXFxzKihbKy1dP1xcZCsoPzpcXC5cXGQqKT8pXFxzKltcXHMsXVxccyooWystXT9cXGQrKD86XFwuXFxkKik/KVxccyokLykpIHtcbiAgICByZXR1cm4gTC5sYXRMbmcoK21hdGNoWzFdLCArbWF0Y2hbMl0pO1xuICB9XG59XG4vKipcclxuICogUGFyc2VzIGJhc2ljIGxhdGl0dWRlL2xvbmdpdHVkZSBzdHJpbmdzIHN1Y2ggYXMgYCc1MC4wNjc3MyAxNC4zNzc0MidgLCBgJ041MC4wNjc3MyBXMTQuMzc3NDInYCwgYCdTIDUwwrAgMDQuMDY0IEUgMDE0wrAgMjIuNjQ1J2AsIG9yIGAnUyA1MMKwIDTigLIgMDMuODI44oCzLCBXIDE0wrAgMjLigLIgMzguNzEy4oCzJ2BcclxuICovXG5cbmNsYXNzIExhdExuZyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBuZXh0OiB1bmRlZmluZWQsXG4gICAgICBzaXplSW5NZXRlcnM6IDEwMDAwXG4gICAgfTtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgY29uc3QgY2VudGVyID0gcGFyc2VMYXRMbmcocXVlcnkpO1xuXG4gICAgaWYgKGNlbnRlcikge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IFt7XG4gICAgICAgIG5hbWU6IHF1ZXJ5LFxuICAgICAgICBjZW50ZXI6IGNlbnRlcixcbiAgICAgICAgYmJveDogY2VudGVyLnRvQm91bmRzKHRoaXMub3B0aW9ucy5zaXplSW5NZXRlcnMpXG4gICAgICB9XTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMubmV4dCkge1xuICAgICAgdGhpcy5vcHRpb25zLm5leHQuZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpO1xuICAgIH1cbiAgfVxuXG59XG4vKipcclxuICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIExhdExuZ31cclxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIGxhdExuZyhvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgTGF0TG5nKG9wdGlvbnMpO1xufVxuXG4vKipcclxuICogSW1wbGVtZW50YXRpb24gb2YgdGhlIFtNYXBib3ggR2VvY29kaW5nXShodHRwczovL3d3dy5tYXBib3guY29tL2FwaS1kb2N1bWVudGF0aW9uLyNnZW9jb2RpbmcpXHJcbiAqL1xuXG5jbGFzcyBNYXBib3gge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vYXBpLm1hcGJveC5jb20vZ2VvY29kaW5nL3Y1L21hcGJveC5wbGFjZXMvJ1xuICAgIH07XG4gICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICBfZ2V0UHJvcGVydGllcyhsb2MpIHtcbiAgICBjb25zdCBwcm9wZXJ0aWVzID0ge1xuICAgICAgdGV4dDogbG9jLnRleHQsXG4gICAgICBhZGRyZXNzOiBsb2MuYWRkcmVzc1xuICAgIH07XG5cbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IChsb2MuY29udGV4dCB8fCBbXSkubGVuZ3RoOyBqKyspIHtcbiAgICAgIGNvbnN0IGlkID0gbG9jLmNvbnRleHRbal0uaWQuc3BsaXQoJy4nKVswXTtcbiAgICAgIHByb3BlcnRpZXNbaWRdID0gbG9jLmNvbnRleHRbal0udGV4dDsgLy8gR2V0IGNvdW50cnkgY29kZSB3aGVuIGF2YWlsYWJsZVxuXG4gICAgICBpZiAobG9jLmNvbnRleHRbal0uc2hvcnRfY29kZSkge1xuICAgICAgICBwcm9wZXJ0aWVzWydjb3VudHJ5U2hvcnRDb2RlJ10gPSBsb2MuY29udGV4dFtqXS5zaG9ydF9jb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICB9XG5cbiAgZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBhY2Nlc3NfdG9rZW46IHRoaXMub3B0aW9ucy5hcGlLZXlcbiAgICB9KTtcblxuICAgIGlmIChwYXJhbXMucHJveGltaXR5ICE9PSB1bmRlZmluZWQgJiYgcGFyYW1zLnByb3hpbWl0eS5sYXQgIT09IHVuZGVmaW5lZCAmJiBwYXJhbXMucHJveGltaXR5LmxuZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwYXJhbXMucHJveGltaXR5ID0gcGFyYW1zLnByb3hpbWl0eS5sbmcgKyAnLCcgKyBwYXJhbXMucHJveGltaXR5LmxhdDtcbiAgICB9XG5cbiAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgZW5jb2RlVVJJQ29tcG9uZW50KHF1ZXJ5KSArICcuanNvbicsIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgIGlmIChkYXRhLmZlYXR1cmVzICYmIGRhdGEuZmVhdHVyZXMubGVuZ3RoKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IGRhdGEuZmVhdHVyZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgbG9jID0gZGF0YS5mZWF0dXJlc1tpXTtcbiAgICAgICAgICBjb25zdCBjZW50ZXIgPSBMLmxhdExuZyhsb2MuY2VudGVyLnJldmVyc2UoKSk7XG4gICAgICAgICAgbGV0IGJib3g7XG5cbiAgICAgICAgICBpZiAobG9jLmJib3gpIHtcbiAgICAgICAgICAgIGJib3ggPSBMLmxhdExuZ0JvdW5kcyhMLmxhdExuZyhsb2MuYmJveC5zbGljZSgwLCAyKS5yZXZlcnNlKCkpLCBMLmxhdExuZyhsb2MuYmJveC5zbGljZSgyLCA0KS5yZXZlcnNlKCkpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmJveCA9IEwubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgbmFtZTogbG9jLnBsYWNlX25hbWUsXG4gICAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXIsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB0aGlzLl9nZXRQcm9wZXJ0aWVzKGxvYylcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cblxuICBzdWdnZXN0KHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgIGNvbnN0IHVybCA9IHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgbG9jYXRpb24ubG5nICsgJywnICsgbG9jYXRpb24ubGF0ICsgJy5qc29uJztcbiAgICBjb25zdCBwYXJhbSA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBhY2Nlc3NfdG9rZW46IHRoaXMub3B0aW9ucy5hcGlLZXlcbiAgICB9KTtcbiAgICBnZXRKU09OKHVybCwgcGFyYW0sIGRhdGEgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBpZiAoZGF0YS5mZWF0dXJlcyAmJiBkYXRhLmZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8PSBkYXRhLmZlYXR1cmVzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxvYyA9IGRhdGEuZmVhdHVyZXNbaV07XG4gICAgICAgICAgY29uc3QgY2VudGVyID0gTC5sYXRMbmcobG9jLmNlbnRlci5yZXZlcnNlKCkpO1xuICAgICAgICAgIGxldCBiYm94O1xuXG4gICAgICAgICAgaWYgKGxvYy5iYm94KSB7XG4gICAgICAgICAgICBiYm94ID0gTC5sYXRMbmdCb3VuZHMoTC5sYXRMbmcobG9jLmJib3guc2xpY2UoMCwgMikucmV2ZXJzZSgpKSwgTC5sYXRMbmcobG9jLmJib3guc2xpY2UoMiwgNCkucmV2ZXJzZSgpKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJib3ggPSBMLmxhdExuZ0JvdW5kcyhjZW50ZXIsIGNlbnRlcik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICAgIG5hbWU6IGxvYy5wbGFjZV9uYW1lLFxuICAgICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgICAgcHJvcGVydGllczogdGhpcy5fZ2V0UHJvcGVydGllcyhsb2MpXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxyXG4gKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgTWFwYm94fVxyXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gKi9cblxuZnVuY3Rpb24gbWFwYm94KG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBNYXBib3gob3B0aW9ucyk7XG59XG5cbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW01hcFF1ZXN0IEdlb2NvZGluZyBBUEldKGh0dHA6Ly9kZXZlbG9wZXIubWFwcXVlc3QuY29tL3dlYi9wcm9kdWN0cy9kZXYtc2VydmljZXMvZ2VvY29kaW5nLXdzKVxyXG4gKi9cblxuY2xhc3MgTWFwUXVlc3Qge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vd3d3Lm1hcHF1ZXN0YXBpLmNvbS9nZW9jb2RpbmcvdjEnXG4gICAgfTtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTsgLy8gTWFwUXVlc3Qgc2VlbXMgdG8gcHJvdmlkZSBVUkkgZW5jb2RlZCBBUEkga2V5cyxcbiAgICAvLyBzbyB0byBhdm9pZCBlbmNvZGluZyB0aGVtIHR3aWNlLCB3ZSBkZWNvZGUgdGhlbSBoZXJlXG5cbiAgICB0aGlzLm9wdGlvbnMuYXBpS2V5ID0gZGVjb2RlVVJJQ29tcG9uZW50KHRoaXMub3B0aW9ucy5hcGlLZXkpO1xuICB9XG5cbiAgX2Zvcm1hdE5hbWUoLi4ucGFydHMpIHtcbiAgICByZXR1cm4gcGFydHMuZmlsdGVyKHMgPT4gISFzKS5qb2luKCcsICcpO1xuICB9XG5cbiAgZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICBsb2NhdGlvbjogcXVlcnksXG4gICAgICBsaW1pdDogNSxcbiAgICAgIG91dEZvcm1hdDogJ2pzb24nXG4gICAgfSk7XG4gICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMuc2VydmljZVVybCArICcvYWRkcmVzcycsIHBhcmFtcywgTC5VdGlsLmJpbmQoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgaWYgKGRhdGEucmVzdWx0cyAmJiBkYXRhLnJlc3VsdHNbMF0ubG9jYXRpb25zKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSBkYXRhLnJlc3VsdHNbMF0ubG9jYXRpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgY29uc3QgbG9jID0gZGF0YS5yZXN1bHRzWzBdLmxvY2F0aW9uc1tpXTtcbiAgICAgICAgICBjb25zdCBjZW50ZXIgPSBMLmxhdExuZyhsb2MubGF0TG5nKTtcbiAgICAgICAgICByZXN1bHRzW2ldID0ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5fZm9ybWF0TmFtZShsb2Muc3RyZWV0LCBsb2MuYWRtaW5BcmVhNCwgbG9jLmFkbWluQXJlYTMsIGxvYy5hZG1pbkFyZWExKSxcbiAgICAgICAgICAgIGJib3g6IEwubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKSxcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgIH0sIHRoaXMpKTtcbiAgfVxuXG4gIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICBsb2NhdGlvbjogbG9jYXRpb24ubGF0ICsgJywnICsgbG9jYXRpb24ubG5nLFxuICAgICAgb3V0cHV0Rm9ybWF0OiAnanNvbidcbiAgICB9KTtcbiAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJy9yZXZlcnNlJywgcGFyYW1zLCBMLlV0aWwuYmluZChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBpZiAoZGF0YS5yZXN1bHRzICYmIGRhdGEucmVzdWx0c1swXS5sb2NhdGlvbnMpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IGRhdGEucmVzdWx0c1swXS5sb2NhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBjb25zdCBsb2MgPSBkYXRhLnJlc3VsdHNbMF0ubG9jYXRpb25zW2ldO1xuICAgICAgICAgIGNvbnN0IGNlbnRlciA9IEwubGF0TG5nKGxvYy5sYXRMbmcpO1xuICAgICAgICAgIHJlc3VsdHNbaV0gPSB7XG4gICAgICAgICAgICBuYW1lOiB0aGlzLl9mb3JtYXROYW1lKGxvYy5zdHJlZXQsIGxvYy5hZG1pbkFyZWE0LCBsb2MuYWRtaW5BcmVhMywgbG9jLmFkbWluQXJlYTEpLFxuICAgICAgICAgICAgYmJveDogTC5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpLFxuICAgICAgICAgICAgY2VudGVyOiBjZW50ZXJcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSwgdGhpcykpO1xuICB9XG5cbn1cbi8qKlxyXG4gKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgTWFwUXVlc3R9XHJcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAqL1xuXG5mdW5jdGlvbiBtYXBRdWVzdChvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgTWFwUXVlc3Qob3B0aW9ucyk7XG59XG5cbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW05ldXRyaW5vIEFQSV0oaHR0cHM6Ly93d3cubmV1dHJpbm9hcGkuY29tL2FwaS9nZW9jb2RlLWFkZHJlc3MvKVxyXG4gKi9cblxuY2xhc3MgTmV1dHJpbm8ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgdXNlcklkOiB1bmRlZmluZWQsXG4gICAgICBhcGlLZXk6IHVuZGVmaW5lZCxcbiAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL25ldXRyaW5vYXBpLmNvbS8nXG4gICAgfTtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgfSAvLyBodHRwczovL3d3dy5uZXV0cmlub2FwaS5jb20vYXBpL2dlb2NvZGUtYWRkcmVzcy9cblxuXG4gIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgYXBpS2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgdXNlcklkOiB0aGlzLm9wdGlvbnMudXNlcklkLFxuICAgICAgLy9nZXQgdGhyZWUgd29yZHMgYW5kIG1ha2UgYSBkb3QgYmFzZWQgc3RyaW5nXG4gICAgICBhZGRyZXNzOiBxdWVyeS5zcGxpdCgvXFxzKy8pLmpvaW4oJy4nKVxuICAgIH0pO1xuICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnZ2VvY29kZS1hZGRyZXNzJywgcGFyYW1zLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgaWYgKGRhdGEubG9jYXRpb25zKSB7XG4gICAgICAgIGRhdGEuZ2VvbWV0cnkgPSBkYXRhLmxvY2F0aW9uc1swXTtcbiAgICAgICAgY29uc3QgY2VudGVyID0gTC5sYXRMbmcoZGF0YS5nZW9tZXRyeVsnbGF0aXR1ZGUnXSwgZGF0YS5nZW9tZXRyeVsnbG9uZ2l0dWRlJ10pO1xuICAgICAgICBjb25zdCBiYm94ID0gTC5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICByZXN1bHRzWzBdID0ge1xuICAgICAgICAgIG5hbWU6IGRhdGEuZ2VvbWV0cnkuYWRkcmVzcyxcbiAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cblxuICBzdWdnZXN0KHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgfSAvLyBodHRwczovL3d3dy5uZXV0cmlub2FwaS5jb20vYXBpL2dlb2NvZGUtcmV2ZXJzZS9cblxuXG4gIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBhcGlLZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICB1c2VySWQ6IHRoaXMub3B0aW9ucy51c2VySWQsXG4gICAgICBsYXRpdHVkZTogbG9jYXRpb24ubGF0LFxuICAgICAgbG9uZ2l0dWRlOiBsb2NhdGlvbi5sbmdcbiAgICB9KTtcbiAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ2dlb2NvZGUtcmV2ZXJzZScsIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgIGlmIChkYXRhLnN0YXR1cy5zdGF0dXMgPT0gMjAwICYmIGRhdGEuZm91bmQpIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gTC5sYXRMbmcobG9jYXRpb24ubGF0LCBsb2NhdGlvbi5sbmcpO1xuICAgICAgICBjb25zdCBiYm94ID0gTC5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICByZXN1bHRzWzBdID0ge1xuICAgICAgICAgIG5hbWU6IGRhdGEuYWRkcmVzcyxcbiAgICAgICAgICBiYm94OiBiYm94LFxuICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cblxufVxuLyoqXHJcbiAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBOZXV0cmlub31cclxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIG5ldXRyaW5vKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBOZXV0cmlubyhvcHRpb25zKTtcbn1cblxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbTm9taW5hdGltXShodHRwczovL3dpa2kub3BlbnN0cmVldG1hcC5vcmcvd2lraS9Ob21pbmF0aW0pIGdlb2NvZGVyLlxyXG4gKlxyXG4gKiBUaGlzIGlzIHRoZSBkZWZhdWx0IGdlb2NvZGluZyBzZXJ2aWNlIHVzZWQgYnkgdGhlIGNvbnRyb2wsIHVubGVzcyBvdGhlcndpc2Ugc3BlY2lmaWVkIGluIHRoZSBvcHRpb25zLlxyXG4gKlxyXG4gKiBVbmxlc3MgdXNpbmcgeW91ciBvd24gTm9taW5hdGltIGluc3RhbGxhdGlvbiwgcGxlYXNlIHJlZmVyIHRvIHRoZSBbTm9taW5hdGltIHVzYWdlIHBvbGljeV0oaHR0cHM6Ly9vcGVyYXRpb25zLm9zbWZvdW5kYXRpb24ub3JnL3BvbGljaWVzL25vbWluYXRpbS8pLlxyXG4gKi9cblxuY2xhc3MgTm9taW5hdGltIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL25vbWluYXRpbS5vcGVuc3RyZWV0bWFwLm9yZy8nLFxuICAgICAgaHRtbFRlbXBsYXRlOiBmdW5jdGlvbiAocikge1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gci5hZGRyZXNzO1xuICAgICAgICBsZXQgY2xhc3NOYW1lO1xuICAgICAgICBjb25zdCBwYXJ0cyA9IFtdO1xuXG4gICAgICAgIGlmIChhZGRyZXNzLnJvYWQgfHwgYWRkcmVzcy5idWlsZGluZykge1xuICAgICAgICAgIHBhcnRzLnB1c2goJ3tidWlsZGluZ30ge3JvYWR9IHtob3VzZV9udW1iZXJ9Jyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYWRkcmVzcy5jaXR5IHx8IGFkZHJlc3MudG93biB8fCBhZGRyZXNzLnZpbGxhZ2UgfHwgYWRkcmVzcy5oYW1sZXQpIHtcbiAgICAgICAgICBjbGFzc05hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1hZGRyZXNzLWRldGFpbCcgOiAnJztcbiAgICAgICAgICBwYXJ0cy5wdXNoKCc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc05hbWUgKyAnXCI+e3Bvc3Rjb2RlfSB7Y2l0eX0ge3Rvd259IHt2aWxsYWdlfSB7aGFtbGV0fTwvc3Bhbj4nKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhZGRyZXNzLnN0YXRlIHx8IGFkZHJlc3MuY291bnRyeSkge1xuICAgICAgICAgIGNsYXNzTmFtZSA9IHBhcnRzLmxlbmd0aCA+IDAgPyAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLWFkZHJlc3MtY29udGV4dCcgOiAnJztcbiAgICAgICAgICBwYXJ0cy5wdXNoKCc8c3BhbiBjbGFzcz1cIicgKyBjbGFzc05hbWUgKyAnXCI+e3N0YXRlfSB7Y291bnRyeX08L3NwYW4+Jyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGVtcGxhdGUocGFydHMuam9pbignPGJyLz4nKSwgYWRkcmVzcyk7XG4gICAgICB9XG4gICAgfTtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zIHx8IHt9KTtcbiAgfVxuXG4gIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgcTogcXVlcnksXG4gICAgICBsaW1pdDogNSxcbiAgICAgIGZvcm1hdDogJ2pzb24nLFxuICAgICAgYWRkcmVzc2RldGFpbHM6IDFcbiAgICB9KTtcbiAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ3NlYXJjaCcsIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgIGZvciAobGV0IGkgPSBkYXRhLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgIGNvbnN0IGJib3ggPSBkYXRhW2ldLmJvdW5kaW5nYm94O1xuXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgNDsgaisrKSBiYm94W2pdID0gK2Jib3hbal07XG5cbiAgICAgICAgcmVzdWx0c1tpXSA9IHtcbiAgICAgICAgICBpY29uOiBkYXRhW2ldLmljb24sXG4gICAgICAgICAgbmFtZTogZGF0YVtpXS5kaXNwbGF5X25hbWUsXG4gICAgICAgICAgaHRtbDogdGhpcy5vcHRpb25zLmh0bWxUZW1wbGF0ZSA/IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUoZGF0YVtpXSkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgYmJveDogTC5sYXRMbmdCb3VuZHMoW2Jib3hbMF0sIGJib3hbMl1dLCBbYmJveFsxXSwgYmJveFszXV0pLFxuICAgICAgICAgIGNlbnRlcjogTC5sYXRMbmcoZGF0YVtpXS5sYXQsIGRhdGFbaV0ubG9uKSxcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBkYXRhW2ldXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cblxuICByZXZlcnNlKGxvY2F0aW9uLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgbGF0OiBsb2NhdGlvbi5sYXQsXG4gICAgICBsb246IGxvY2F0aW9uLmxuZyxcbiAgICAgIHpvb206IE1hdGgucm91bmQoTWF0aC5sb2coc2NhbGUgLyAyNTYpIC8gTWF0aC5sb2coMikpLFxuICAgICAgYWRkcmVzc2RldGFpbHM6IDEsXG4gICAgICBmb3JtYXQ6ICdqc29uJ1xuICAgIH0pO1xuICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAncmV2ZXJzZScsIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSBbXTtcblxuICAgICAgaWYgKGRhdGEgJiYgZGF0YS5sYXQgJiYgZGF0YS5sb24pIHtcbiAgICAgICAgY29uc3QgY2VudGVyID0gTC5sYXRMbmcoZGF0YS5sYXQsIGRhdGEubG9uKTtcbiAgICAgICAgY29uc3QgYmJveCA9IEwubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKTtcbiAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgIG5hbWU6IGRhdGEuZGlzcGxheV9uYW1lLFxuICAgICAgICAgIGh0bWw6IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUgPyB0aGlzLm9wdGlvbnMuaHRtbFRlbXBsYXRlKGRhdGEpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgcHJvcGVydGllczogZGF0YVxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHQpO1xuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxyXG4gKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgTm9taW5hdGltfVxyXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gKi9cblxuZnVuY3Rpb24gbm9taW5hdGltKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBOb21pbmF0aW0ob3B0aW9ucyk7XG59XG5cbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW1BsdXMgY29kZXNdKGh0dHBzOi8vcGx1cy5jb2Rlcy8pIChmb3JtZXJseSBPcGVuTG9jYXRpb25Db2RlKSAocmVxdWlyZXMgW29wZW4tbG9jYXRpb24tY29kZV0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvb3Blbi1sb2NhdGlvbi1jb2RlKSlcclxuICovXG5cbmNsYXNzIE9wZW5Mb2NhdGlvbkNvZGUge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgTC5VdGlsLnNldE9wdGlvbnModGhpcywgb3B0aW9ucyk7XG4gIH1cblxuICBnZW9jb2RlKHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBkZWNvZGVkID0gdGhpcy5vcHRpb25zLk9wZW5Mb2NhdGlvbkNvZGUuZGVjb2RlKHF1ZXJ5KTtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgbmFtZTogcXVlcnksXG4gICAgICAgIGNlbnRlcjogTC5sYXRMbmcoZGVjb2RlZC5sYXRpdHVkZUNlbnRlciwgZGVjb2RlZC5sb25naXR1ZGVDZW50ZXIpLFxuICAgICAgICBiYm94OiBMLmxhdExuZ0JvdW5kcyhMLmxhdExuZyhkZWNvZGVkLmxhdGl0dWRlTG8sIGRlY29kZWQubG9uZ2l0dWRlTG8pLCBMLmxhdExuZyhkZWNvZGVkLmxhdGl0dWRlSGksIGRlY29kZWQubG9uZ2l0dWRlSGkpKVxuICAgICAgfTtcbiAgICAgIGNiLmNhbGwoY29udGV4dCwgW3Jlc3VsdF0pO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUud2FybihlKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgW10pO1xuICAgIH1cbiAgfVxuXG4gIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBjb2RlID0gdGhpcy5vcHRpb25zLk9wZW5Mb2NhdGlvbkNvZGUuZW5jb2RlKGxvY2F0aW9uLmxhdCwgbG9jYXRpb24ubG5nLCB0aGlzLm9wdGlvbnMuY29kZUxlbmd0aCk7XG4gICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgIG5hbWU6IGNvZGUsXG4gICAgICAgIGNlbnRlcjogTC5sYXRMbmcobG9jYXRpb24ubGF0LCBsb2NhdGlvbi5sbmcpLFxuICAgICAgICBiYm94OiBMLmxhdExuZ0JvdW5kcyhMLmxhdExuZyhsb2NhdGlvbi5sYXQsIGxvY2F0aW9uLmxuZyksIEwubGF0TG5nKGxvY2F0aW9uLmxhdCwgbG9jYXRpb24ubG5nKSlcbiAgICAgIH07XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIFtyZXN1bHRdKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLndhcm4oZSk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuXG4gICAgICBjYi5jYWxsKGNvbnRleHQsIFtdKTtcbiAgICB9XG4gIH1cblxufVxuLyoqXHJcbiAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBPcGVuTG9jYXRpb25Db2RlfVxyXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gKi9cblxuZnVuY3Rpb24gb3BlbkxvY2F0aW9uQ29kZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgT3BlbkxvY2F0aW9uQ29kZShvcHRpb25zKTtcbn1cblxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbT3BlbkNhZ2UgRGF0YSBBUEldKGh0dHBzOi8vb3BlbmNhZ2VkYXRhLmNvbS8pXHJcbiAqL1xuXG5jbGFzcyBPcGVuQ2FnZSB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9hcGkub3BlbmNhZ2VkYXRhLmNvbS9nZW9jb2RlL3YxL2pzb24nXG4gICAgfTtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAga2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgcTogcXVlcnlcbiAgICB9KTtcbiAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsLCBwYXJhbXMsIGRhdGEgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBpZiAoZGF0YS5yZXN1bHRzICYmIGRhdGEucmVzdWx0cy5sZW5ndGgpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLnJlc3VsdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICBjb25zdCBsb2MgPSBkYXRhLnJlc3VsdHNbaV07XG4gICAgICAgICAgY29uc3QgY2VudGVyID0gTC5sYXRMbmcobG9jLmdlb21ldHJ5KTtcbiAgICAgICAgICBsZXQgYmJveDtcblxuICAgICAgICAgIGlmIChsb2MuYW5ub3RhdGlvbnMgJiYgbG9jLmFubm90YXRpb25zLmJvdW5kcykge1xuICAgICAgICAgICAgYmJveCA9IEwubGF0TG5nQm91bmRzKEwubGF0TG5nKGxvYy5hbm5vdGF0aW9ucy5ib3VuZHMubm9ydGhlYXN0KSwgTC5sYXRMbmcobG9jLmFubm90YXRpb25zLmJvdW5kcy5zb3V0aHdlc3QpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYmJveCA9IEwubGF0TG5nQm91bmRzKGNlbnRlciwgY2VudGVyKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgICAgbmFtZTogbG9jLmZvcm1hdHRlZCxcbiAgICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cblxuICBzdWdnZXN0KHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICBxOiBbbG9jYXRpb24ubGF0LCBsb2NhdGlvbi5sbmddLmpvaW4oJywnKVxuICAgIH0pO1xuICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwsIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICAgIGlmIChkYXRhLnJlc3VsdHMgJiYgZGF0YS5yZXN1bHRzLmxlbmd0aCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEucmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGNvbnN0IGxvYyA9IGRhdGEucmVzdWx0c1tpXTtcbiAgICAgICAgICBjb25zdCBjZW50ZXIgPSBMLmxhdExuZyhsb2MuZ2VvbWV0cnkpO1xuICAgICAgICAgIGxldCBiYm94O1xuXG4gICAgICAgICAgaWYgKGxvYy5hbm5vdGF0aW9ucyAmJiBsb2MuYW5ub3RhdGlvbnMuYm91bmRzKSB7XG4gICAgICAgICAgICBiYm94ID0gTC5sYXRMbmdCb3VuZHMoTC5sYXRMbmcobG9jLmFubm90YXRpb25zLmJvdW5kcy5ub3J0aGVhc3QpLCBMLmxhdExuZyhsb2MuYW5ub3RhdGlvbnMuYm91bmRzLnNvdXRod2VzdCkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYm94ID0gTC5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJlc3VsdHMucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBsb2MuZm9ybWF0dGVkLFxuICAgICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICAgIGNlbnRlcjogY2VudGVyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2IuY2FsbChjb250ZXh0LCByZXN1bHRzKTtcbiAgICB9KTtcbiAgfVxuXG59XG5mdW5jdGlvbiBvcGVuY2FnZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgT3BlbkNhZ2Uob3B0aW9ucyk7XG59XG5cbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW1BlbGlhc10oaHR0cHM6Ly9wZWxpYXMuaW8vKSwgW2dlb2NvZGUuZWFydGhdKGh0dHBzOi8vZ2VvY29kZS5lYXJ0aC8pIGdlb2NvZGVyIChmb3JtZXJseSBNYXB6ZW4gU2VhcmNoKVxyXG4gKi9cblxuY2xhc3MgUGVsaWFzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIHNlcnZpY2VVcmw6ICdodHRwczovL2FwaS5nZW9jb2RlLmVhcnRoL3YxJ1xuICAgIH07XG4gICAgdGhpcy5fbGFzdFN1Z2dlc3QgPSAwO1xuICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBhcGlfa2V5OiB0aGlzLm9wdGlvbnMuYXBpS2V5LFxuICAgICAgdGV4dDogcXVlcnlcbiAgICB9KTtcbiAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJy9zZWFyY2gnLCBwYXJhbXMsIGRhdGEgPT4ge1xuICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLl9wYXJzZVJlc3VsdHMoZGF0YSwgJ2Jib3gnKSk7XG4gICAgfSk7XG4gIH1cblxuICBzdWdnZXN0KHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIGNvbnN0IHBhcmFtcyA9IGdlb2NvZGluZ1BhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgIGFwaV9rZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICB0ZXh0OiBxdWVyeVxuICAgIH0pO1xuICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnL2F1dG9jb21wbGV0ZScsIHBhcmFtcywgZGF0YSA9PiB7XG4gICAgICBpZiAoZGF0YS5nZW9jb2RpbmcudGltZXN0YW1wID4gdGhpcy5fbGFzdFN1Z2dlc3QpIHtcbiAgICAgICAgdGhpcy5fbGFzdFN1Z2dlc3QgPSBkYXRhLmdlb2NvZGluZy50aW1lc3RhbXA7XG4gICAgICAgIGNiLmNhbGwoY29udGV4dCwgdGhpcy5fcGFyc2VSZXN1bHRzKGRhdGEsICdiYm94JykpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgcmV2ZXJzZShsb2NhdGlvbiwgc2NhbGUsIGNiLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmV2ZXJzZVBhcmFtcyh0aGlzLm9wdGlvbnMsIHtcbiAgICAgIGFwaV9rZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICAncG9pbnQubGF0JzogbG9jYXRpb24ubGF0LFxuICAgICAgJ3BvaW50Lmxvbic6IGxvY2F0aW9uLmxuZ1xuICAgIH0pO1xuICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAnL3JldmVyc2UnLCBwYXJhbXMsIGRhdGEgPT4ge1xuICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLl9wYXJzZVJlc3VsdHMoZGF0YSwgJ2JvdW5kcycpKTtcbiAgICB9KTtcbiAgfVxuXG4gIF9wYXJzZVJlc3VsdHMoZGF0YSwgYmJveG5hbWUpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG4gICAgTC5nZW9KU09OKGRhdGEsIHtcbiAgICAgIHBvaW50VG9MYXllcjogZnVuY3Rpb24gKGZlYXR1cmUsIGxhdGxuZykge1xuICAgICAgICByZXR1cm4gTC5jaXJjbGVNYXJrZXIobGF0bG5nKTtcbiAgICAgIH0sXG4gICAgICBvbkVhY2hGZWF0dXJlOiBmdW5jdGlvbiAoZmVhdHVyZSwgbGF5ZXIpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIGxldCBiYm94O1xuICAgICAgICBsZXQgY2VudGVyO1xuXG4gICAgICAgIGlmIChsYXllci5nZXRCb3VuZHMpIHtcbiAgICAgICAgICBiYm94ID0gbGF5ZXIuZ2V0Qm91bmRzKCk7XG4gICAgICAgICAgY2VudGVyID0gYmJveC5nZXRDZW50ZXIoKTtcbiAgICAgICAgfSBlbHNlIGlmIChsYXllci5mZWF0dXJlLmJib3gpIHtcbiAgICAgICAgICBjZW50ZXIgPSBsYXllci5nZXRMYXRMbmcoKTtcbiAgICAgICAgICBiYm94ID0gTC5sYXRMbmdCb3VuZHMoTC5HZW9KU09OLmNvb3Jkc1RvTGF0TG5nKGxheWVyLmZlYXR1cmUuYmJveC5zbGljZSgwLCAyKSksIEwuR2VvSlNPTi5jb29yZHNUb0xhdExuZyhsYXllci5mZWF0dXJlLmJib3guc2xpY2UoMiwgNCkpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjZW50ZXIgPSBsYXllci5nZXRMYXRMbmcoKTtcbiAgICAgICAgICBiYm94ID0gTC5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVzdWx0Lm5hbWUgPSBsYXllci5mZWF0dXJlLnByb3BlcnRpZXMubGFiZWw7XG4gICAgICAgIHJlc3VsdC5jZW50ZXIgPSBjZW50ZXI7XG4gICAgICAgIHJlc3VsdFtiYm94bmFtZV0gPSBiYm94O1xuICAgICAgICByZXN1bHQucHJvcGVydGllcyA9IGxheWVyLmZlYXR1cmUucHJvcGVydGllcztcbiAgICAgICAgcmVzdWx0cy5wdXNoKHJlc3VsdCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH1cblxufVxuLyoqXHJcbiAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBQZWxpYXN9XHJcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAqL1xuXG5mdW5jdGlvbiBwZWxpYXMob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBlbGlhcyhvcHRpb25zKTtcbn1cbmNvbnN0IEdlb2NvZGVFYXJ0aCA9IFBlbGlhcztcbmNvbnN0IGdlb2NvZGVFYXJ0aCA9IHBlbGlhcztcbi8qKlxyXG4gKiByLmkucC5cclxuICogQGRlcHJlY2F0ZWRcclxuICovXG5cbmNvbnN0IE1hcHplbiA9IFBlbGlhcztcbi8qKlxyXG4gKiByLmkucC5cclxuICogQGRlcHJlY2F0ZWRcclxuICovXG5cbmNvbnN0IG1hcHplbiA9IHBlbGlhcztcbi8qKlxyXG4gKiBJbXBsZW1lbnRhdGlvbiBvZiB0aGUgW09wZW5yb3V0ZXNlcnZpY2VdKGh0dHBzOi8vb3BlbnJvdXRlc2VydmljZS5vcmcvZGV2LyMvYXBpLWRvY3MvZ2VvY29kZSkgZ2VvY29kZXJcclxuICovXG5cbmNsYXNzIE9wZW5yb3V0ZXNlcnZpY2UgZXh0ZW5kcyBQZWxpYXMge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIoTC5VdGlsLmV4dGVuZCh7XG4gICAgICBzZXJ2aWNlVXJsOiAnaHR0cHM6Ly9hcGkub3BlbnJvdXRlc2VydmljZS5vcmcvZ2VvY29kZSdcbiAgICB9LCBvcHRpb25zKSk7XG4gIH1cblxufVxuLyoqXHJcbiAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBPcGVucm91dGVzZXJ2aWNlfVxyXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gKi9cblxuZnVuY3Rpb24gb3BlbnJvdXRlc2VydmljZShvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgT3BlbnJvdXRlc2VydmljZShvcHRpb25zKTtcbn1cblxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBbUGhvdG9uXShodHRwOi8vcGhvdG9uLmtvbW9vdC5kZS8pIGdlb2NvZGVyXHJcbiAqL1xuXG5jbGFzcyBQaG90b24ge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vcGhvdG9uLmtvbW9vdC5pby9hcGkvJyxcbiAgICAgIHJldmVyc2VVcmw6ICdodHRwczovL3Bob3Rvbi5rb21vb3QuaW8vcmV2ZXJzZS8nLFxuICAgICAgbmFtZVByb3BlcnRpZXM6IFsnbmFtZScsICdzdHJlZXQnLCAnc3VidXJiJywgJ2hhbWxldCcsICd0b3duJywgJ2NpdHknLCAnc3RhdGUnLCAnY291bnRyeSddXG4gICAgfTtcbiAgICBMLlV0aWwuc2V0T3B0aW9ucyh0aGlzLCBvcHRpb25zKTtcbiAgfVxuXG4gIGdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KSB7XG4gICAgY29uc3QgcGFyYW1zID0gZ2VvY29kaW5nUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgcTogcXVlcnlcbiAgICB9KTtcbiAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsLCBwYXJhbXMsIEwuVXRpbC5iaW5kKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHRoaXMuX2RlY29kZUZlYXR1cmVzKGRhdGEpKTtcbiAgICB9LCB0aGlzKSk7XG4gIH1cblxuICBzdWdnZXN0KHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldmVyc2UobGF0TG5nLCBzY2FsZSwgY2IsIGNvbnRleHQpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXZlcnNlUGFyYW1zKHRoaXMub3B0aW9ucywge1xuICAgICAgbGF0OiBsYXRMbmcubGF0LFxuICAgICAgbG9uOiBsYXRMbmcubG5nXG4gICAgfSk7XG4gICAgZ2V0SlNPTih0aGlzLm9wdGlvbnMucmV2ZXJzZVVybCwgcGFyYW1zLCBMLlV0aWwuYmluZChmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgY2IuY2FsbChjb250ZXh0LCB0aGlzLl9kZWNvZGVGZWF0dXJlcyhkYXRhKSk7XG4gICAgfSwgdGhpcykpO1xuICB9XG5cbiAgX2RlY29kZUZlYXR1cmVzKGRhdGEpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICBpZiAoZGF0YSAmJiBkYXRhLmZlYXR1cmVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZiA9IGRhdGEuZmVhdHVyZXNbaV07XG4gICAgICAgIGNvbnN0IGMgPSBmLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBMLmxhdExuZyhjWzFdLCBjWzBdKTtcbiAgICAgICAgY29uc3QgZXh0ZW50ID0gZi5wcm9wZXJ0aWVzLmV4dGVudDtcbiAgICAgICAgY29uc3QgYmJveCA9IGV4dGVudCA/IEwubGF0TG5nQm91bmRzKFtleHRlbnRbMV0sIGV4dGVudFswXV0sIFtleHRlbnRbM10sIGV4dGVudFsyXV0pIDogTC5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICByZXN1bHRzLnB1c2goe1xuICAgICAgICAgIG5hbWU6IHRoaXMuX2RlY29kZUZlYXR1cmVOYW1lKGYpLFxuICAgICAgICAgIGh0bWw6IHRoaXMub3B0aW9ucy5odG1sVGVtcGxhdGUgPyB0aGlzLm9wdGlvbnMuaHRtbFRlbXBsYXRlKGYpIDogdW5kZWZpbmVkLFxuICAgICAgICAgIGNlbnRlcjogY2VudGVyLFxuICAgICAgICAgIGJib3g6IGJib3gsXG4gICAgICAgICAgcHJvcGVydGllczogZi5wcm9wZXJ0aWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRzO1xuICB9XG5cbiAgX2RlY29kZUZlYXR1cmVOYW1lKGYpIHtcbiAgICByZXR1cm4gKHRoaXMub3B0aW9ucy5uYW1lUHJvcGVydGllcyB8fCBbXSkubWFwKHAgPT4ge1xuICAgICAgcmV0dXJuIGYucHJvcGVydGllc1twXTtcbiAgICB9KS5maWx0ZXIodiA9PiB7XG4gICAgICByZXR1cm4gISF2O1xuICAgIH0pLmpvaW4oJywgJyk7XG4gIH1cblxufVxuLyoqXHJcbiAqIFtDbGFzcyBmYWN0b3J5IG1ldGhvZF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NsYXNzLWNsYXNzLWZhY3RvcmllcykgZm9yIHtAbGluayBQaG90b259XHJcbiAqIEBwYXJhbSBvcHRpb25zIHRoZSBvcHRpb25zXHJcbiAqL1xuXG5mdW5jdGlvbiBwaG90b24ob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFBob3RvbihvcHRpb25zKTtcbn1cblxuLyoqXHJcbiAqIEltcGxlbWVudGF0aW9uIG9mIHRoZSBXaGF0M1dvcmRzIHNlcnZpY2VcclxuICovXG5cbmNsYXNzIFdoYXQzV29yZHMge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc2VydmljZVVybDogJ2h0dHBzOi8vYXBpLndoYXQzd29yZHMuY29tL3YyLydcbiAgICB9O1xuICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuICB9XG5cbiAgZ2VvY29kZShxdWVyeSwgY2IsIGNvbnRleHQpIHtcbiAgICAvL2dldCB0aHJlZSB3b3JkcyBhbmQgbWFrZSBhIGRvdCBiYXNlZCBzdHJpbmdcbiAgICBnZXRKU09OKHRoaXMub3B0aW9ucy5zZXJ2aWNlVXJsICsgJ2ZvcndhcmQnLCBnZW9jb2RpbmdQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICBhZGRyOiBxdWVyeS5zcGxpdCgvXFxzKy8pLmpvaW4oJy4nKVxuICAgIH0pLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSBbXTtcblxuICAgICAgaWYgKGRhdGEuZ2VvbWV0cnkpIHtcbiAgICAgICAgY29uc3QgbGF0TG5nID0gTC5sYXRMbmcoZGF0YS5nZW9tZXRyeVsnbGF0J10sIGRhdGEuZ2VvbWV0cnlbJ2xuZyddKTtcbiAgICAgICAgY29uc3QgbGF0TG5nQm91bmRzID0gTC5sYXRMbmdCb3VuZHMobGF0TG5nLCBsYXRMbmcpO1xuICAgICAgICByZXN1bHRzWzBdID0ge1xuICAgICAgICAgIG5hbWU6IGRhdGEud29yZHMsXG4gICAgICAgICAgYmJveDogbGF0TG5nQm91bmRzLFxuICAgICAgICAgIGNlbnRlcjogbGF0TG5nXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGNiLmNhbGwoY29udGV4dCwgcmVzdWx0cyk7XG4gICAgfSk7XG4gIH1cblxuICBzdWdnZXN0KHF1ZXJ5LCBjYiwgY29udGV4dCkge1xuICAgIHJldHVybiB0aGlzLmdlb2NvZGUocXVlcnksIGNiLCBjb250ZXh0KTtcbiAgfVxuXG4gIHJldmVyc2UobG9jYXRpb24sIHNjYWxlLCBjYiwgY29udGV4dCkge1xuICAgIGdldEpTT04odGhpcy5vcHRpb25zLnNlcnZpY2VVcmwgKyAncmV2ZXJzZScsIHJldmVyc2VQYXJhbXModGhpcy5vcHRpb25zLCB7XG4gICAgICBrZXk6IHRoaXMub3B0aW9ucy5hcGlLZXksXG4gICAgICBjb29yZHM6IFtsb2NhdGlvbi5sYXQsIGxvY2F0aW9uLmxuZ10uam9pbignLCcpXG4gICAgfSksIGRhdGEgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0cyA9IFtdO1xuXG4gICAgICBpZiAoZGF0YS5zdGF0dXMuc3RhdHVzID09IDIwMCkge1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBMLmxhdExuZyhkYXRhLmdlb21ldHJ5WydsYXQnXSwgZGF0YS5nZW9tZXRyeVsnbG5nJ10pO1xuICAgICAgICBjb25zdCBiYm94ID0gTC5sYXRMbmdCb3VuZHMoY2VudGVyLCBjZW50ZXIpO1xuICAgICAgICByZXN1bHRzWzBdID0ge1xuICAgICAgICAgIG5hbWU6IGRhdGEud29yZHMsXG4gICAgICAgICAgYmJveDogYmJveCxcbiAgICAgICAgICBjZW50ZXI6IGNlbnRlclxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICBjYi5jYWxsKGNvbnRleHQsIHJlc3VsdHMpO1xuICAgIH0pO1xuICB9XG5cbn1cbi8qKlxyXG4gKiBbQ2xhc3MgZmFjdG9yeSBtZXRob2RdKGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjbGFzcy1jbGFzcy1mYWN0b3JpZXMpIGZvciB7QGxpbmsgV2hhdDNXb3Jkc31cclxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIHdoYXQzd29yZHMob3B0aW9ucykge1xuICByZXR1cm4gbmV3IFdoYXQzV29yZHMob3B0aW9ucyk7XG59XG5cbnZhciBnZW9jb2RlcnMgPSB7XG4gIF9fcHJvdG9fXzogbnVsbCxcbiAgZ2VvY29kaW5nUGFyYW1zOiBnZW9jb2RpbmdQYXJhbXMsXG4gIHJldmVyc2VQYXJhbXM6IHJldmVyc2VQYXJhbXMsXG4gIEFyY0dpczogQXJjR2lzLFxuICBhcmNnaXM6IGFyY2dpcyxcbiAgQmluZzogQmluZyxcbiAgYmluZzogYmluZyxcbiAgR29vZ2xlOiBHb29nbGUsXG4gIGdvb2dsZTogZ29vZ2xlLFxuICBIRVJFOiBIRVJFLFxuICBIRVJFdjI6IEhFUkV2MixcbiAgaGVyZTogaGVyZSxcbiAgcGFyc2VMYXRMbmc6IHBhcnNlTGF0TG5nLFxuICBMYXRMbmc6IExhdExuZyxcbiAgbGF0TG5nOiBsYXRMbmcsXG4gIE1hcGJveDogTWFwYm94LFxuICBtYXBib3g6IG1hcGJveCxcbiAgTWFwUXVlc3Q6IE1hcFF1ZXN0LFxuICBtYXBRdWVzdDogbWFwUXVlc3QsXG4gIE5ldXRyaW5vOiBOZXV0cmlubyxcbiAgbmV1dHJpbm86IG5ldXRyaW5vLFxuICBOb21pbmF0aW06IE5vbWluYXRpbSxcbiAgbm9taW5hdGltOiBub21pbmF0aW0sXG4gIE9wZW5Mb2NhdGlvbkNvZGU6IE9wZW5Mb2NhdGlvbkNvZGUsXG4gIG9wZW5Mb2NhdGlvbkNvZGU6IG9wZW5Mb2NhdGlvbkNvZGUsXG4gIE9wZW5DYWdlOiBPcGVuQ2FnZSxcbiAgb3BlbmNhZ2U6IG9wZW5jYWdlLFxuICBQZWxpYXM6IFBlbGlhcyxcbiAgcGVsaWFzOiBwZWxpYXMsXG4gIEdlb2NvZGVFYXJ0aDogR2VvY29kZUVhcnRoLFxuICBnZW9jb2RlRWFydGg6IGdlb2NvZGVFYXJ0aCxcbiAgTWFwemVuOiBNYXB6ZW4sXG4gIG1hcHplbjogbWFwemVuLFxuICBPcGVucm91dGVzZXJ2aWNlOiBPcGVucm91dGVzZXJ2aWNlLFxuICBvcGVucm91dGVzZXJ2aWNlOiBvcGVucm91dGVzZXJ2aWNlLFxuICBQaG90b246IFBob3RvbixcbiAgcGhvdG9uOiBwaG90b24sXG4gIFdoYXQzV29yZHM6IFdoYXQzV29yZHMsXG4gIHdoYXQzd29yZHM6IHdoYXQzd29yZHNcbn07XG5cbi8qKlxyXG4gKiBMZWFmbGV0IG1peGlucyBodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLTEuNy4xLmh0bWwjY2xhc3MtaW5jbHVkZXNcclxuICogZm9yIFR5cGVTY3JpcHQgaHR0cHM6Ly93d3cudHlwZXNjcmlwdGxhbmcub3JnL2RvY3MvaGFuZGJvb2svbWl4aW5zLmh0bWxcclxuICogQGludGVybmFsXHJcbiAqL1xuXG5jbGFzcyBFdmVudGVkQ29udHJvbCB7XG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgY29uc3RydWN0b3IoLi4uYXJncykgey8vIGVtcHR5XG4gIH1cblxufVxuXG5MLlV0aWwuZXh0ZW5kKEV2ZW50ZWRDb250cm9sLnByb3RvdHlwZSwgTC5Db250cm9sLnByb3RvdHlwZSk7XG5MLlV0aWwuZXh0ZW5kKEV2ZW50ZWRDb250cm9sLnByb3RvdHlwZSwgTC5FdmVudGVkLnByb3RvdHlwZSk7XG4vKipcclxuICogVGhpcyBpcyB0aGUgZ2VvY29kZXIgY29udHJvbC4gSXQgd29ya3MgbGlrZSBhbnkgb3RoZXIgW0xlYWZsZXQgY29udHJvbF0oaHR0cHM6Ly9sZWFmbGV0anMuY29tL3JlZmVyZW5jZS5odG1sI2NvbnRyb2wpLCBhbmQgaXMgYWRkZWQgdG8gdGhlIG1hcC5cclxuICovXG5cbmNsYXNzIEdlb2NvZGVyQ29udHJvbCBleHRlbmRzIEV2ZW50ZWRDb250cm9sIHtcbiAgLyoqXHJcbiAgICogSW5zdGFudGlhdGVzIGEgZ2VvY29kZXIgY29udHJvbCAodG8gYmUgaW52b2tlZCB1c2luZyBgbmV3YClcclxuICAgKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9uc1xyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgc3VwZXIob3B0aW9ucyk7XG4gICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgc2hvd1VuaXF1ZVJlc3VsdDogdHJ1ZSxcbiAgICAgIHNob3dSZXN1bHRJY29uczogZmFsc2UsXG4gICAgICBjb2xsYXBzZWQ6IHRydWUsXG4gICAgICBleHBhbmQ6ICd0b3VjaCcsXG4gICAgICBwb3NpdGlvbjogJ3RvcHJpZ2h0JyxcbiAgICAgIHBsYWNlaG9sZGVyOiAnU2VhcmNoLi4uJyxcbiAgICAgIGVycm9yTWVzc2FnZTogJ05vdGhpbmcgZm91bmQuJyxcbiAgICAgIGljb25MYWJlbDogJ0luaXRpYXRlIGEgbmV3IHNlYXJjaCcsXG4gICAgICBxdWVyeTogJycsXG4gICAgICBxdWVyeU1pbkxlbmd0aDogMSxcbiAgICAgIHN1Z2dlc3RNaW5MZW5ndGg6IDMsXG4gICAgICBzdWdnZXN0VGltZW91dDogMjUwLFxuICAgICAgZGVmYXVsdE1hcmtHZW9jb2RlOiB0cnVlXG4gICAgfTtcbiAgICB0aGlzLl9yZXF1ZXN0Q291bnQgPSAwO1xuICAgIEwuVXRpbC5zZXRPcHRpb25zKHRoaXMsIG9wdGlvbnMpO1xuXG4gICAgaWYgKCF0aGlzLm9wdGlvbnMuZ2VvY29kZXIpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5nZW9jb2RlciA9IG5ldyBOb21pbmF0aW0oKTtcbiAgICB9XG4gIH1cblxuICBhZGRUaHJvYmJlckNsYXNzKCkge1xuICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItdGhyb2JiZXInKTtcbiAgfVxuXG4gIHJlbW92ZVRocm9iYmVyQ2xhc3MoKSB7XG4gICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci10aHJvYmJlcicpO1xuICB9XG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIGNvbnRhaW5lciBET00gZWxlbWVudCBmb3IgdGhlIGNvbnRyb2wgYW5kIGFkZCBsaXN0ZW5lcnMgb24gcmVsZXZhbnQgbWFwIGV2ZW50cy5cclxuICAgKiBAcGFyYW0gbWFwIHRoZSBtYXAgaW5zdGFuY2VcclxuICAgKiBAc2VlIGh0dHBzOi8vbGVhZmxldGpzLmNvbS9yZWZlcmVuY2UuaHRtbCNjb250cm9sLW9uYWRkXHJcbiAgICovXG5cblxuICBvbkFkZChtYXApIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyJztcbiAgICBjb25zdCBjb250YWluZXIgPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnIGxlYWZsZXQtYmFyJyk7XG4gICAgY29uc3QgaWNvbiA9IEwuRG9tVXRpbC5jcmVhdGUoJ2J1dHRvbicsIGNsYXNzTmFtZSArICctaWNvbicsIGNvbnRhaW5lcik7XG4gICAgY29uc3QgZm9ybSA9IHRoaXMuX2Zvcm0gPSBMLkRvbVV0aWwuY3JlYXRlKCdkaXYnLCBjbGFzc05hbWUgKyAnLWZvcm0nLCBjb250YWluZXIpO1xuICAgIHRoaXMuX21hcCA9IG1hcDtcbiAgICB0aGlzLl9jb250YWluZXIgPSBjb250YWluZXI7XG4gICAgaWNvbi5pbm5lckhUTUwgPSAnJm5ic3A7JztcbiAgICBpY29uLnR5cGUgPSAnYnV0dG9uJztcbiAgICBpY29uLnNldEF0dHJpYnV0ZSgnYXJpYS1sYWJlbCcsIHRoaXMub3B0aW9ucy5pY29uTGFiZWwpO1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5faW5wdXQgPSBMLkRvbVV0aWwuY3JlYXRlKCdpbnB1dCcsICcnLCBmb3JtKTtcbiAgICBpbnB1dC50eXBlID0gJ3RleHQnO1xuICAgIGlucHV0LnZhbHVlID0gdGhpcy5vcHRpb25zLnF1ZXJ5O1xuICAgIGlucHV0LnBsYWNlaG9sZGVyID0gdGhpcy5vcHRpb25zLnBsYWNlaG9sZGVyO1xuICAgIEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24oaW5wdXQpO1xuICAgIHRoaXMuX2Vycm9yRWxlbWVudCA9IEwuRG9tVXRpbC5jcmVhdGUoJ2RpdicsIGNsYXNzTmFtZSArICctZm9ybS1uby1lcnJvcicsIGNvbnRhaW5lcik7XG4gICAgdGhpcy5fZXJyb3JFbGVtZW50LmlubmVySFRNTCA9IHRoaXMub3B0aW9ucy5lcnJvck1lc3NhZ2U7XG4gICAgdGhpcy5fYWx0cyA9IEwuRG9tVXRpbC5jcmVhdGUoJ3VsJywgY2xhc3NOYW1lICsgJy1hbHRlcm5hdGl2ZXMgbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLWFsdGVybmF0aXZlcy1taW5pbWl6ZWQnLCBjb250YWluZXIpO1xuICAgIEwuRG9tRXZlbnQuZGlzYWJsZUNsaWNrUHJvcGFnYXRpb24odGhpcy5fYWx0cyk7XG4gICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihpbnB1dCwgJ2tleWRvd24nLCB0aGlzLl9rZXlkb3duLCB0aGlzKTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuZ2VvY29kZXIuc3VnZ2VzdCkge1xuICAgICAgTC5Eb21FdmVudC5hZGRMaXN0ZW5lcihpbnB1dCwgJ2lucHV0JywgdGhpcy5fY2hhbmdlLCB0aGlzKTtcbiAgICB9XG5cbiAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGlucHV0LCAnYmx1cicsICgpID0+IHtcbiAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29sbGFwc2VkICYmICF0aGlzLl9wcmV2ZW50Qmx1ckNvbGxhcHNlKSB7XG4gICAgICAgIHRoaXMuX2NvbGxhcHNlKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3ByZXZlbnRCbHVyQ29sbGFwc2UgPSBmYWxzZTtcbiAgICB9KTtcblxuICAgIGlmICh0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XG4gICAgICBpZiAodGhpcy5vcHRpb25zLmV4cGFuZCA9PT0gJ2NsaWNrJykge1xuICAgICAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2NsaWNrJywgZSA9PiB7XG4gICAgICAgICAgaWYgKGUuYnV0dG9uID09PSAwICYmIGUuZGV0YWlsICE9PSAyKSB7XG4gICAgICAgICAgICB0aGlzLl90b2dnbGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm9wdGlvbnMuZXhwYW5kID09PSAndG91Y2gnKSB7XG4gICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCBMLkJyb3dzZXIudG91Y2ggPyAndG91Y2hzdGFydCBtb3VzZWRvd24nIDogJ21vdXNlZG93bicsIGUgPT4ge1xuICAgICAgICAgIHRoaXMuX3RvZ2dsZSgpO1xuXG4gICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCgpOyAvLyBtb2JpbGU6IGNsaWNraW5nIGZvY3VzZXMgdGhlIGljb24sIHNvIFVJIGV4cGFuZHMgYW5kIGltbWVkaWF0ZWx5IGNvbGxhcHNlc1xuXG4gICAgICAgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ21vdXNlb3ZlcicsIHRoaXMuX2V4cGFuZCwgdGhpcyk7XG4gICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAnbW91c2VvdXQnLCB0aGlzLl9jb2xsYXBzZSwgdGhpcyk7XG5cbiAgICAgICAgdGhpcy5fbWFwLm9uKCdtb3Zlc3RhcnQnLCB0aGlzLl9jb2xsYXBzZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2V4cGFuZCgpO1xuXG4gICAgICBpZiAoTC5Ccm93c2VyLnRvdWNoKSB7XG4gICAgICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIoY29udGFpbmVyLCAndG91Y2hzdGFydCcsICgpID0+IHRoaXMuX2dlb2NvZGUoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBMLkRvbUV2ZW50LmFkZExpc3RlbmVyKGNvbnRhaW5lciwgJ2NsaWNrJywgKCkgPT4gdGhpcy5fZ2VvY29kZSgpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLmRlZmF1bHRNYXJrR2VvY29kZSkge1xuICAgICAgdGhpcy5vbignbWFya2dlb2NvZGUnLCB0aGlzLm1hcmtHZW9jb2RlLCB0aGlzKTtcbiAgICB9XG5cbiAgICB0aGlzLm9uKCdzdGFydGdlb2NvZGUnLCB0aGlzLmFkZFRocm9iYmVyQ2xhc3MsIHRoaXMpO1xuICAgIHRoaXMub24oJ2ZpbmlzaGdlb2NvZGUnLCB0aGlzLnJlbW92ZVRocm9iYmVyQ2xhc3MsIHRoaXMpO1xuICAgIHRoaXMub24oJ3N0YXJ0c3VnZ2VzdCcsIHRoaXMuYWRkVGhyb2JiZXJDbGFzcywgdGhpcyk7XG4gICAgdGhpcy5vbignZmluaXNoc3VnZ2VzdCcsIHRoaXMucmVtb3ZlVGhyb2JiZXJDbGFzcywgdGhpcyk7XG4gICAgTC5Eb21FdmVudC5kaXNhYmxlQ2xpY2tQcm9wYWdhdGlvbihjb250YWluZXIpO1xuICAgIHJldHVybiBjb250YWluZXI7XG4gIH1cbiAgLyoqXHJcbiAgICogU2V0cyB0aGUgcXVlcnkgc3RyaW5nIG9uIHRoZSB0ZXh0IGlucHV0XHJcbiAgICogQHBhcmFtIHN0cmluZyB0aGUgcXVlcnkgc3RyaW5nXHJcbiAgICovXG5cblxuICBzZXRRdWVyeShzdHJpbmcpIHtcbiAgICB0aGlzLl9pbnB1dC52YWx1ZSA9IHN0cmluZztcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIF9nZW9jb2RlUmVzdWx0KHJlc3VsdHMsIHN1Z2dlc3QpIHtcbiAgICBpZiAoIXN1Z2dlc3QgJiYgdGhpcy5vcHRpb25zLnNob3dVbmlxdWVSZXN1bHQgJiYgcmVzdWx0cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMuX2dlb2NvZGVSZXN1bHRTZWxlY3RlZChyZXN1bHRzWzBdKTtcbiAgICB9IGVsc2UgaWYgKHJlc3VsdHMubGVuZ3RoID4gMCkge1xuICAgICAgdGhpcy5fYWx0cy5pbm5lckhUTUwgPSAnJztcbiAgICAgIHRoaXMuX3Jlc3VsdHMgPSByZXN1bHRzO1xuICAgICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2FsdHMsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWx0ZXJuYXRpdmVzLW1pbmltaXplZCcpO1xuICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1vcHRpb25zLW9wZW4nKTtcblxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuX2FsdHMuYXBwZW5kQ2hpbGQodGhpcy5fY3JlYXRlQWx0KHJlc3VsdHNbaV0sIGkpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1vcHRpb25zLWVycm9yJyk7XG4gICAgICBMLkRvbVV0aWwuYWRkQ2xhc3ModGhpcy5fZXJyb3JFbGVtZW50LCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLWVycm9yJyk7XG4gICAgfVxuICB9XG4gIC8qKlxyXG4gICAqIE1hcmtzIGEgZ2VvY29kaW5nIHJlc3VsdCBvbiB0aGUgbWFwXHJcbiAgICogQHBhcmFtIHJlc3VsdCB0aGUgZ2VvY29kaW5nIHJlc3VsdFxyXG4gICAqL1xuXG5cbiAgbWFya0dlb2NvZGUoZXZlbnQpIHtcbiAgICBjb25zdCByZXN1bHQgPSBldmVudC5nZW9jb2RlO1xuXG4gICAgdGhpcy5fbWFwLmZpdEJvdW5kcyhyZXN1bHQuYmJveCk7XG5cbiAgICBpZiAodGhpcy5fZ2VvY29kZU1hcmtlcikge1xuICAgICAgdGhpcy5fbWFwLnJlbW92ZUxheWVyKHRoaXMuX2dlb2NvZGVNYXJrZXIpO1xuICAgIH1cblxuICAgIHRoaXMuX2dlb2NvZGVNYXJrZXIgPSBuZXcgTC5NYXJrZXIocmVzdWx0LmNlbnRlcikuYmluZFBvcHVwKHJlc3VsdC5odG1sIHx8IHJlc3VsdC5uYW1lKS5hZGRUbyh0aGlzLl9tYXApLm9wZW5Qb3B1cCgpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgX2dlb2NvZGUoc3VnZ2VzdCkge1xuICAgIGNvbnN0IHZhbHVlID0gdGhpcy5faW5wdXQudmFsdWU7XG5cbiAgICBpZiAoIXN1Z2dlc3QgJiYgdmFsdWUubGVuZ3RoIDwgdGhpcy5vcHRpb25zLnF1ZXJ5TWluTGVuZ3RoKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcmVxdWVzdENvdW50ID0gKyt0aGlzLl9yZXF1ZXN0Q291bnQ7XG5cbiAgICBjb25zdCBjYiA9IHJlc3VsdHMgPT4ge1xuICAgICAgaWYgKHJlcXVlc3RDb3VudCA9PT0gdGhpcy5fcmVxdWVzdENvdW50KSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0ge1xuICAgICAgICAgIGlucHV0OiB2YWx1ZSxcbiAgICAgICAgICByZXN1bHRzXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZmlyZShzdWdnZXN0ID8gJ2ZpbmlzaHN1Z2dlc3QnIDogJ2ZpbmlzaGdlb2NvZGUnLCBldmVudCk7XG5cbiAgICAgICAgdGhpcy5fZ2VvY29kZVJlc3VsdChyZXN1bHRzLCBzdWdnZXN0KTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgdGhpcy5fbGFzdEdlb2NvZGUgPSB2YWx1ZTtcblxuICAgIGlmICghc3VnZ2VzdCkge1xuICAgICAgdGhpcy5fY2xlYXJSZXN1bHRzKCk7XG4gICAgfVxuXG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBpbnB1dDogdmFsdWVcbiAgICB9O1xuICAgIHRoaXMuZmlyZShzdWdnZXN0ID8gJ3N0YXJ0c3VnZ2VzdCcgOiAnc3RhcnRnZW9jb2RlJywgZXZlbnQpO1xuXG4gICAgaWYgKHN1Z2dlc3QpIHtcbiAgICAgIHRoaXMub3B0aW9ucy5nZW9jb2Rlci5zdWdnZXN0KHZhbHVlLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3B0aW9ucy5nZW9jb2Rlci5nZW9jb2RlKHZhbHVlLCBjYik7XG4gICAgfVxuICB9XG5cbiAgX2dlb2NvZGVSZXN1bHRTZWxlY3RlZChnZW9jb2RlKSB7XG4gICAgY29uc3QgZXZlbnQgPSB7XG4gICAgICBnZW9jb2RlXG4gICAgfTtcbiAgICB0aGlzLmZpcmUoJ21hcmtnZW9jb2RlJywgZXZlbnQpO1xuICB9XG5cbiAgX3RvZ2dsZSgpIHtcbiAgICBpZiAoTC5Eb21VdGlsLmhhc0NsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1leHBhbmRlZCcpKSB7XG4gICAgICB0aGlzLl9jb2xsYXBzZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9leHBhbmQoKTtcbiAgICB9XG4gIH1cblxuICBfZXhwYW5kKCkge1xuICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItZXhwYW5kZWQnKTtcblxuICAgIHRoaXMuX2lucHV0LnNlbGVjdCgpO1xuXG4gICAgdGhpcy5maXJlKCdleHBhbmQnKTtcbiAgfVxuXG4gIF9jb2xsYXBzZSgpIHtcbiAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLWV4cGFuZGVkJyk7XG4gICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2FsdHMsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWx0ZXJuYXRpdmVzLW1pbmltaXplZCcpO1xuICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9lcnJvckVsZW1lbnQsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItZXJyb3InKTtcbiAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fY29udGFpbmVyLCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLW9wdGlvbnMtb3BlbicpO1xuICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItb3B0aW9ucy1lcnJvcicpO1xuXG4gICAgdGhpcy5faW5wdXQuYmx1cigpOyAvLyBtb2JpbGU6IGtleWJvYXJkIHNob3VsZG4ndCBzdGF5IGV4cGFuZGVkXG5cblxuICAgIHRoaXMuZmlyZSgnY29sbGFwc2UnKTtcbiAgfVxuXG4gIF9jbGVhclJlc3VsdHMoKSB7XG4gICAgTC5Eb21VdGlsLmFkZENsYXNzKHRoaXMuX2FsdHMsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItYWx0ZXJuYXRpdmVzLW1pbmltaXplZCcpO1xuICAgIHRoaXMuX3NlbGVjdGlvbiA9IG51bGw7XG4gICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2Vycm9yRWxlbWVudCwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1lcnJvcicpO1xuICAgIEwuRG9tVXRpbC5yZW1vdmVDbGFzcyh0aGlzLl9jb250YWluZXIsICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItb3B0aW9ucy1vcGVuJyk7XG4gICAgTC5Eb21VdGlsLnJlbW92ZUNsYXNzKHRoaXMuX2NvbnRhaW5lciwgJ2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci1vcHRpb25zLWVycm9yJyk7XG4gIH1cblxuICBfY3JlYXRlQWx0KHJlc3VsdCwgaW5kZXgpIHtcbiAgICBjb25zdCBsaSA9IEwuRG9tVXRpbC5jcmVhdGUoJ2xpJywgJycpLFxuICAgICAgICAgIGEgPSBMLkRvbVV0aWwuY3JlYXRlKCdhJywgJycsIGxpKSxcbiAgICAgICAgICBpY29uID0gdGhpcy5vcHRpb25zLnNob3dSZXN1bHRJY29ucyAmJiByZXN1bHQuaWNvbiA/IEwuRG9tVXRpbC5jcmVhdGUoJ2ltZycsICcnLCBhKSA6IG51bGwsXG4gICAgICAgICAgdGV4dCA9IHJlc3VsdC5odG1sID8gdW5kZWZpbmVkIDogZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUocmVzdWx0Lm5hbWUpLFxuICAgICAgICAgIG1vdXNlRG93bkhhbmRsZXIgPSBlID0+IHtcbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIGEgY2xpY2sgd2lsbCBmaXJlIG9uIHRoZSBtYXAgaWYgdGhlIGNvbnRyb2wgaXNcbiAgICAgIC8vIGNvbGxhcHNlZCBkaXJlY3RseSBhZnRlciBtb3VzZWRvd24uIFRvIHdvcmsgYXJvdW5kIHRoaXMsIHdlXG4gICAgICAvLyB3YWl0IHVudGlsIHRoZSBjbGljayBpcyBjb21wbGV0ZWQsIGFuZCBfdGhlbl8gY29sbGFwc2UgdGhlXG4gICAgICAvLyBjb250cm9sLiBNZXNzeSwgYnV0IHRoaXMgaXMgdGhlIHdvcmthcm91bmQgSSBjb3VsZCBjb21lIHVwIHdpdGhcbiAgICAgIC8vIGZvciAjMTQyLlxuICAgICAgdGhpcy5fcHJldmVudEJsdXJDb2xsYXBzZSA9IHRydWU7XG4gICAgICBMLkRvbUV2ZW50LnN0b3AoZSk7XG5cbiAgICAgIHRoaXMuX2dlb2NvZGVSZXN1bHRTZWxlY3RlZChyZXN1bHQpO1xuXG4gICAgICBMLkRvbUV2ZW50Lm9uKGxpLCAnY2xpY2sgdG91Y2hlbmQnLCAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuY29sbGFwc2VkKSB7XG4gICAgICAgICAgdGhpcy5fY29sbGFwc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9jbGVhclJlc3VsdHMoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcblxuICAgIGlmIChpY29uKSB7XG4gICAgICBpY29uLnNyYyA9IHJlc3VsdC5pY29uO1xuICAgIH1cblxuICAgIGxpLnNldEF0dHJpYnV0ZSgnZGF0YS1yZXN1bHQtaW5kZXgnLCBTdHJpbmcoaW5kZXgpKTtcblxuICAgIGlmIChyZXN1bHQuaHRtbCkge1xuICAgICAgYS5pbm5lckhUTUwgPSBhLmlubmVySFRNTCArIHJlc3VsdC5odG1sO1xuICAgIH0gZWxzZSBpZiAodGV4dCkge1xuICAgICAgYS5hcHBlbmRDaGlsZCh0ZXh0KTtcbiAgICB9IC8vIFVzZSBtb3VzZWRvd24gYW5kIG5vdCBjbGljaywgc2luY2UgY2xpY2sgd2lsbCBmaXJlIF9hZnRlcl8gYmx1cixcbiAgICAvLyBjYXVzaW5nIHRoZSBjb250cm9sIHRvIGhhdmUgY29sbGFwc2VkIGFuZCByZW1vdmVkIHRoZSBpdGVtc1xuICAgIC8vIGJlZm9yZSB0aGUgY2xpY2sgY2FuIGZpcmUuXG5cblxuICAgIEwuRG9tRXZlbnQuYWRkTGlzdGVuZXIobGksICdtb3VzZWRvd24gdG91Y2hzdGFydCcsIG1vdXNlRG93bkhhbmRsZXIsIHRoaXMpO1xuICAgIHJldHVybiBsaTtcbiAgfVxuXG4gIF9rZXlkb3duKGUpIHtcbiAgICBjb25zdCBzZWxlY3QgPSBkaXIgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NlbGVjdGlvbikge1xuICAgICAgICBMLkRvbVV0aWwucmVtb3ZlQ2xhc3ModGhpcy5fc2VsZWN0aW9uLCAnbGVhZmxldC1jb250cm9sLWdlb2NvZGVyLXNlbGVjdGVkJyk7XG4gICAgICAgIHRoaXMuX3NlbGVjdGlvbiA9IHRoaXMuX3NlbGVjdGlvbltkaXIgPiAwID8gJ25leHRTaWJsaW5nJyA6ICdwcmV2aW91c1NpYmxpbmcnXTtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9zZWxlY3Rpb24pIHtcbiAgICAgICAgdGhpcy5fc2VsZWN0aW9uID0gdGhpcy5fYWx0c1tkaXIgPiAwID8gJ2ZpcnN0Q2hpbGQnIDogJ2xhc3RDaGlsZCddO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fc2VsZWN0aW9uKSB7XG4gICAgICAgIEwuRG9tVXRpbC5hZGRDbGFzcyh0aGlzLl9zZWxlY3Rpb24sICdsZWFmbGV0LWNvbnRyb2wtZ2VvY29kZXItc2VsZWN0ZWQnKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgc3dpdGNoIChlLmtleUNvZGUpIHtcbiAgICAgIC8vIEVzY2FwZVxuICAgICAgY2FzZSAyNzpcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb2xsYXBzZWQpIHtcbiAgICAgICAgICB0aGlzLl9jb2xsYXBzZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuX2NsZWFyUmVzdWx0cygpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBVcFxuXG4gICAgICBjYXNlIDM4OlxuICAgICAgICBzZWxlY3QoLTEpO1xuICAgICAgICBicmVhaztcbiAgICAgIC8vIFVwXG5cbiAgICAgIGNhc2UgNDA6XG4gICAgICAgIHNlbGVjdCgxKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBFbnRlclxuXG4gICAgICBjYXNlIDEzOlxuICAgICAgICBpZiAodGhpcy5fc2VsZWN0aW9uKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludCh0aGlzLl9zZWxlY3Rpb24uZ2V0QXR0cmlidXRlKCdkYXRhLXJlc3VsdC1pbmRleCcpLCAxMCk7XG5cbiAgICAgICAgICB0aGlzLl9nZW9jb2RlUmVzdWx0U2VsZWN0ZWQodGhpcy5fcmVzdWx0c1tpbmRleF0pO1xuXG4gICAgICAgICAgdGhpcy5fY2xlYXJSZXN1bHRzKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5fZ2VvY29kZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBMLkRvbUV2ZW50LnByZXZlbnREZWZhdWx0KGUpO1xuICB9XG5cbiAgX2NoYW5nZSgpIHtcbiAgICBjb25zdCB2ID0gdGhpcy5faW5wdXQudmFsdWU7XG5cbiAgICBpZiAodiAhPT0gdGhpcy5fbGFzdEdlb2NvZGUpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl9zdWdnZXN0VGltZW91dCk7XG5cbiAgICAgIGlmICh2Lmxlbmd0aCA+PSB0aGlzLm9wdGlvbnMuc3VnZ2VzdE1pbkxlbmd0aCkge1xuICAgICAgICB0aGlzLl9zdWdnZXN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5fZ2VvY29kZSh0cnVlKSwgdGhpcy5vcHRpb25zLnN1Z2dlc3RUaW1lb3V0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2NsZWFyUmVzdWx0cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4vKipcclxuICogW0NsYXNzIGZhY3RvcnkgbWV0aG9kXShodHRwczovL2xlYWZsZXRqcy5jb20vcmVmZXJlbmNlLmh0bWwjY2xhc3MtY2xhc3MtZmFjdG9yaWVzKSBmb3Ige0BsaW5rIEdlb2NvZGVyQ29udHJvbH1cclxuICogQHBhcmFtIG9wdGlvbnMgdGhlIG9wdGlvbnNcclxuICovXG5cbmZ1bmN0aW9uIGdlb2NvZGVyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBHZW9jb2RlckNvbnRyb2wob3B0aW9ucyk7XG59XG5cbi8qIEBwcmVzZXJ2ZVxyXG4gKiBMZWFmbGV0IENvbnRyb2wgR2VvY29kZXJcclxuICogaHR0cHM6Ly9naXRodWIuY29tL3BlcmxpZWRtYW4vbGVhZmxldC1jb250cm9sLWdlb2NvZGVyXHJcbiAqXHJcbiAqIENvcHlyaWdodCAoYykgMjAxMiBzYTNtIChodHRwczovL2dpdGh1Yi5jb20vc2EzbSlcclxuICogQ29weXJpZ2h0IChjKSAyMDE4IFBlciBMaWVkbWFuXHJcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXHJcbiAqL1xuTC5VdGlsLmV4dGVuZChHZW9jb2RlckNvbnRyb2wsIGdlb2NvZGVycyk7XG5MLlV0aWwuZXh0ZW5kKEwuQ29udHJvbCwge1xuICBHZW9jb2RlcjogR2VvY29kZXJDb250cm9sLFxuICBnZW9jb2RlcjogZ2VvY29kZXJcbn0pO1xuXG5leHBvcnQgZGVmYXVsdCBHZW9jb2RlckNvbnRyb2w7XG5leHBvcnQgeyBHZW9jb2RlckNvbnRyb2wgYXMgR2VvY29kZXIsIGdlb2NvZGVyLCBnZW9jb2RlcnMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRyb2wuR2VvY29kZXIubW9kZXJuLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.modern.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.css":
/*!*************************************************************************!*\
  !*** ./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.css ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"49d07abefc0b\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbGVhZmxldC1jb250cm9sLWdlb2NvZGVyL2Rpc3QvQ29udHJvbC5HZW9jb2Rlci5jc3MiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLGlFQUFlLGNBQWM7QUFDN0IsSUFBSSxLQUFVLEVBQUUsRUFBdUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0LW1hcC1hZHZhbmNlLy4vbm9kZV9tb2R1bGVzL2xlYWZsZXQtY29udHJvbC1nZW9jb2Rlci9kaXN0L0NvbnRyb2wuR2VvY29kZXIuY3NzPzAxNDYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGRlZmF1bHQgXCI0OWQwN2FiZWZjMGJcIlxuaWYgKG1vZHVsZS5ob3QpIHsgbW9kdWxlLmhvdC5hY2NlcHQoKSB9XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/leaflet-control-geocoder/dist/Control.Geocoder.css\n");

/***/ })

};
;